// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: protobuf/msg.proto

//包名，通过protoc生成时go文件时

package protomsg

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type MsgBase struct {
	ModeType             string   `protobuf:"bytes,1,opt,name=ModeType,proto3" json:"ModeType,omitempty"`
	Uid                  int32    `protobuf:"varint,2,opt,name=Uid,proto3" json:"Uid,omitempty"`
	MsgType              string   `protobuf:"bytes,3,opt,name=MsgType,proto3" json:"MsgType,omitempty"`
	ConnectId            int32    `protobuf:"varint,4,opt,name=ConnectId,proto3" json:"ConnectId,omitempty"`
	Datas                []byte   `protobuf:"bytes,5,opt,name=Datas,proto3" json:"Datas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MsgBase) Reset()         { *m = MsgBase{} }
func (m *MsgBase) String() string { return proto.CompactTextString(m) }
func (*MsgBase) ProtoMessage()    {}
func (*MsgBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{0}
}
func (m *MsgBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgBase.Merge(m, src)
}
func (m *MsgBase) XXX_Size() int {
	return m.Size()
}
func (m *MsgBase) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgBase.DiscardUnknown(m)
}

var xxx_messageInfo_MsgBase proto.InternalMessageInfo

func (m *MsgBase) GetModeType() string {
	if m != nil {
		return m.ModeType
	}
	return ""
}

func (m *MsgBase) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *MsgBase) GetMsgType() string {
	if m != nil {
		return m.MsgType
	}
	return ""
}

func (m *MsgBase) GetConnectId() int32 {
	if m != nil {
		return m.ConnectId
	}
	return 0
}

func (m *MsgBase) GetDatas() []byte {
	if m != nil {
		return m.Datas
	}
	return nil
}

type MsgRegisterToGate struct {
	ModeType             string   `protobuf:"bytes,1,opt,name=ModeType,proto3" json:"ModeType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MsgRegisterToGate) Reset()         { *m = MsgRegisterToGate{} }
func (m *MsgRegisterToGate) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterToGate) ProtoMessage()    {}
func (*MsgRegisterToGate) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{1}
}
func (m *MsgRegisterToGate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterToGate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterToGate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterToGate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterToGate.Merge(m, src)
}
func (m *MsgRegisterToGate) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterToGate) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterToGate.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterToGate proto.InternalMessageInfo

func (m *MsgRegisterToGate) GetModeType() string {
	if m != nil {
		return m.ModeType
	}
	return ""
}

type CS_MsgQuickLogin struct {
	Platform             string   `protobuf:"bytes,1,opt,name=Platform,proto3" json:"Platform,omitempty"`
	Machineid            string   `protobuf:"bytes,2,opt,name=Machineid,proto3" json:"Machineid,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_MsgQuickLogin) Reset()         { *m = CS_MsgQuickLogin{} }
func (m *CS_MsgQuickLogin) String() string { return proto.CompactTextString(m) }
func (*CS_MsgQuickLogin) ProtoMessage()    {}
func (*CS_MsgQuickLogin) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{2}
}
func (m *CS_MsgQuickLogin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_MsgQuickLogin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_MsgQuickLogin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_MsgQuickLogin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_MsgQuickLogin.Merge(m, src)
}
func (m *CS_MsgQuickLogin) XXX_Size() int {
	return m.Size()
}
func (m *CS_MsgQuickLogin) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_MsgQuickLogin.DiscardUnknown(m)
}

var xxx_messageInfo_CS_MsgQuickLogin proto.InternalMessageInfo

func (m *CS_MsgQuickLogin) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *CS_MsgQuickLogin) GetMachineid() string {
	if m != nil {
		return m.Machineid
	}
	return ""
}

func (m *CS_MsgQuickLogin) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type CS_Login struct {
	Phonenumber          string   `protobuf:"bytes,1,opt,name=Phonenumber,proto3" json:"Phonenumber,omitempty"`
	Platform             string   `protobuf:"bytes,2,opt,name=Platform,proto3" json:"Platform,omitempty"`
	Machineid            string   `protobuf:"bytes,3,opt,name=Machineid,proto3" json:"Machineid,omitempty"`
	WechatId             string   `protobuf:"bytes,4,opt,name=Wechat_id,json=WechatId,proto3" json:"Wechat_id,omitempty"`
	QQId                 string   `protobuf:"bytes,5,opt,name=QQ_id,json=QQId,proto3" json:"QQ_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_Login) Reset()         { *m = CS_Login{} }
func (m *CS_Login) String() string { return proto.CompactTextString(m) }
func (*CS_Login) ProtoMessage()    {}
func (*CS_Login) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{3}
}
func (m *CS_Login) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_Login) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_Login.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_Login) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_Login.Merge(m, src)
}
func (m *CS_Login) XXX_Size() int {
	return m.Size()
}
func (m *CS_Login) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_Login.DiscardUnknown(m)
}

var xxx_messageInfo_CS_Login proto.InternalMessageInfo

func (m *CS_Login) GetPhonenumber() string {
	if m != nil {
		return m.Phonenumber
	}
	return ""
}

func (m *CS_Login) GetPlatform() string {
	if m != nil {
		return m.Platform
	}
	return ""
}

func (m *CS_Login) GetMachineid() string {
	if m != nil {
		return m.Machineid
	}
	return ""
}

func (m *CS_Login) GetWechatId() string {
	if m != nil {
		return m.WechatId
	}
	return ""
}

func (m *CS_Login) GetQQId() string {
	if m != nil {
		return m.QQId
	}
	return ""
}

//登录成功后的 选择角色
type CS_SelectCharacter struct {
	SelectCharacter      *CharacterBaseDatas `protobuf:"bytes,1,opt,name=SelectCharacter,proto3" json:"SelectCharacter,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *CS_SelectCharacter) Reset()         { *m = CS_SelectCharacter{} }
func (m *CS_SelectCharacter) String() string { return proto.CompactTextString(m) }
func (*CS_SelectCharacter) ProtoMessage()    {}
func (*CS_SelectCharacter) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{4}
}
func (m *CS_SelectCharacter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_SelectCharacter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_SelectCharacter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_SelectCharacter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_SelectCharacter.Merge(m, src)
}
func (m *CS_SelectCharacter) XXX_Size() int {
	return m.Size()
}
func (m *CS_SelectCharacter) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_SelectCharacter.DiscardUnknown(m)
}

var xxx_messageInfo_CS_SelectCharacter proto.InternalMessageInfo

func (m *CS_SelectCharacter) GetSelectCharacter() *CharacterBaseDatas {
	if m != nil {
		return m.SelectCharacter
	}
	return nil
}

//loading界面加载完成
type CS_LodingScene struct {
	SceneID              int32    `protobuf:"varint,1,opt,name=SceneID,proto3" json:"SceneID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_LodingScene) Reset()         { *m = CS_LodingScene{} }
func (m *CS_LodingScene) String() string { return proto.CompactTextString(m) }
func (*CS_LodingScene) ProtoMessage()    {}
func (*CS_LodingScene) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{5}
}
func (m *CS_LodingScene) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_LodingScene) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_LodingScene.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_LodingScene) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_LodingScene.Merge(m, src)
}
func (m *CS_LodingScene) XXX_Size() int {
	return m.Size()
}
func (m *CS_LodingScene) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_LodingScene.DiscardUnknown(m)
}

var xxx_messageInfo_CS_LodingScene proto.InternalMessageInfo

func (m *CS_LodingScene) GetSceneID() int32 {
	if m != nil {
		return m.SceneID
	}
	return 0
}

//观看视频
type CS_LookVedioSucc struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_LookVedioSucc) Reset()         { *m = CS_LookVedioSucc{} }
func (m *CS_LookVedioSucc) String() string { return proto.CompactTextString(m) }
func (*CS_LookVedioSucc) ProtoMessage()    {}
func (*CS_LookVedioSucc) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{6}
}
func (m *CS_LookVedioSucc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_LookVedioSucc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_LookVedioSucc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_LookVedioSucc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_LookVedioSucc.Merge(m, src)
}
func (m *CS_LookVedioSucc) XXX_Size() int {
	return m.Size()
}
func (m *CS_LookVedioSucc) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_LookVedioSucc.DiscardUnknown(m)
}

var xxx_messageInfo_CS_LookVedioSucc proto.InternalMessageInfo

func (m *CS_LookVedioSucc) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

//使用AI
type CS_UseAI struct {
	AIid                 int32    `protobuf:"varint,1,opt,name=AIid,proto3" json:"AIid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_UseAI) Reset()         { *m = CS_UseAI{} }
func (m *CS_UseAI) String() string { return proto.CompactTextString(m) }
func (*CS_UseAI) ProtoMessage()    {}
func (*CS_UseAI) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{7}
}
func (m *CS_UseAI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_UseAI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_UseAI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_UseAI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_UseAI.Merge(m, src)
}
func (m *CS_UseAI) XXX_Size() int {
	return m.Size()
}
func (m *CS_UseAI) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_UseAI.DiscardUnknown(m)
}

var xxx_messageInfo_CS_UseAI proto.InternalMessageInfo

func (m *CS_UseAI) GetAIid() int32 {
	if m != nil {
		return m.AIid
	}
	return 0
}

//进入游戏失败 需要排队
type SC_NeedLineUp struct {
	FrontCount           int32    `protobuf:"varint,1,opt,name=FrontCount,proto3" json:"FrontCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SC_NeedLineUp) Reset()         { *m = SC_NeedLineUp{} }
func (m *SC_NeedLineUp) String() string { return proto.CompactTextString(m) }
func (*SC_NeedLineUp) ProtoMessage()    {}
func (*SC_NeedLineUp) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{8}
}
func (m *SC_NeedLineUp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_NeedLineUp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_NeedLineUp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_NeedLineUp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_NeedLineUp.Merge(m, src)
}
func (m *SC_NeedLineUp) XXX_Size() int {
	return m.Size()
}
func (m *SC_NeedLineUp) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_NeedLineUp.DiscardUnknown(m)
}

var xxx_messageInfo_SC_NeedLineUp proto.InternalMessageInfo

func (m *SC_NeedLineUp) GetFrontCount() int32 {
	if m != nil {
		return m.FrontCount
	}
	return 0
}

//获取排队前面的人数
type CS_GetLineUpFrontCount struct {
	Nothing1             int32    `protobuf:"varint,1,opt,name=Nothing1,proto3" json:"Nothing1,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetLineUpFrontCount) Reset()         { *m = CS_GetLineUpFrontCount{} }
func (m *CS_GetLineUpFrontCount) String() string { return proto.CompactTextString(m) }
func (*CS_GetLineUpFrontCount) ProtoMessage()    {}
func (*CS_GetLineUpFrontCount) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{9}
}
func (m *CS_GetLineUpFrontCount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetLineUpFrontCount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetLineUpFrontCount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetLineUpFrontCount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetLineUpFrontCount.Merge(m, src)
}
func (m *CS_GetLineUpFrontCount) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetLineUpFrontCount) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetLineUpFrontCount.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetLineUpFrontCount proto.InternalMessageInfo

func (m *CS_GetLineUpFrontCount) GetNothing1() int32 {
	if m != nil {
		return m.Nothing1
	}
	return 0
}

//返回获取排队前面的人数
type SC_GetLineUpFrontCount struct {
	FrontCount           int32    `protobuf:"varint,1,opt,name=FrontCount,proto3" json:"FrontCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SC_GetLineUpFrontCount) Reset()         { *m = SC_GetLineUpFrontCount{} }
func (m *SC_GetLineUpFrontCount) String() string { return proto.CompactTextString(m) }
func (*SC_GetLineUpFrontCount) ProtoMessage()    {}
func (*SC_GetLineUpFrontCount) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{10}
}
func (m *SC_GetLineUpFrontCount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetLineUpFrontCount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetLineUpFrontCount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetLineUpFrontCount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetLineUpFrontCount.Merge(m, src)
}
func (m *SC_GetLineUpFrontCount) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetLineUpFrontCount) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetLineUpFrontCount.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetLineUpFrontCount proto.InternalMessageInfo

func (m *SC_GetLineUpFrontCount) GetFrontCount() int32 {
	if m != nil {
		return m.FrontCount
	}
	return 0
}

//取消排队
type CS_CancelLineUp struct {
	Nothing              int32    `protobuf:"varint,1,opt,name=Nothing,proto3" json:"Nothing,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_CancelLineUp) Reset()         { *m = CS_CancelLineUp{} }
func (m *CS_CancelLineUp) String() string { return proto.CompactTextString(m) }
func (*CS_CancelLineUp) ProtoMessage()    {}
func (*CS_CancelLineUp) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{11}
}
func (m *CS_CancelLineUp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_CancelLineUp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_CancelLineUp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_CancelLineUp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_CancelLineUp.Merge(m, src)
}
func (m *CS_CancelLineUp) XXX_Size() int {
	return m.Size()
}
func (m *CS_CancelLineUp) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_CancelLineUp.DiscardUnknown(m)
}

var xxx_messageInfo_CS_CancelLineUp proto.InternalMessageInfo

func (m *CS_CancelLineUp) GetNothing() int32 {
	if m != nil {
		return m.Nothing
	}
	return 0
}

//装备栏
type UnitEquip struct {
	Pos                  int32    `protobuf:"varint,1,opt,name=Pos,proto3" json:"Pos,omitempty"`
	TypdID               int32    `protobuf:"varint,2,opt,name=TypdID,proto3" json:"TypdID,omitempty"`
	Level                int32    `protobuf:"varint,3,opt,name=Level,proto3" json:"Level,omitempty"`
	PriceType            int32    `protobuf:"varint,4,opt,name=PriceType,proto3" json:"PriceType,omitempty"`
	Price                int32    `protobuf:"varint,5,opt,name=Price,proto3" json:"Price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UnitEquip) Reset()         { *m = UnitEquip{} }
func (m *UnitEquip) String() string { return proto.CompactTextString(m) }
func (*UnitEquip) ProtoMessage()    {}
func (*UnitEquip) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{12}
}
func (m *UnitEquip) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnitEquip) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnitEquip.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnitEquip) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnitEquip.Merge(m, src)
}
func (m *UnitEquip) XXX_Size() int {
	return m.Size()
}
func (m *UnitEquip) XXX_DiscardUnknown() {
	xxx_messageInfo_UnitEquip.DiscardUnknown(m)
}

var xxx_messageInfo_UnitEquip proto.InternalMessageInfo

func (m *UnitEquip) GetPos() int32 {
	if m != nil {
		return m.Pos
	}
	return 0
}

func (m *UnitEquip) GetTypdID() int32 {
	if m != nil {
		return m.TypdID
	}
	return 0
}

func (m *UnitEquip) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *UnitEquip) GetPriceType() int32 {
	if m != nil {
		return m.PriceType
	}
	return 0
}

func (m *UnitEquip) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

//单位面板详细信息
type UnitBoardDatas struct {
	ID                       int32        `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name                     string       `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	AttributeStrength        float32      `protobuf:"fixed32,3,opt,name=AttributeStrength,proto3" json:"AttributeStrength,omitempty"`
	AttributeAgility         float32      `protobuf:"fixed32,4,opt,name=AttributeAgility,proto3" json:"AttributeAgility,omitempty"`
	AttributeIntelligence    float32      `protobuf:"fixed32,5,opt,name=AttributeIntelligence,proto3" json:"AttributeIntelligence,omitempty"`
	Attack                   int32        `protobuf:"varint,6,opt,name=Attack,proto3" json:"Attack,omitempty"`
	AttackSpeed              float32      `protobuf:"fixed32,7,opt,name=AttackSpeed,proto3" json:"AttackSpeed,omitempty"`
	AttackRange              float32      `protobuf:"fixed32,8,opt,name=AttackRange,proto3" json:"AttackRange,omitempty"`
	MoveSpeed                float32      `protobuf:"fixed32,9,opt,name=MoveSpeed,proto3" json:"MoveSpeed,omitempty"`
	MagicScale               float32      `protobuf:"fixed32,10,opt,name=MagicScale,proto3" json:"MagicScale,omitempty"`
	MPRegain                 float32      `protobuf:"fixed32,11,opt,name=MPRegain,proto3" json:"MPRegain,omitempty"`
	PhysicalAmaor            float32      `protobuf:"fixed32,12,opt,name=PhysicalAmaor,proto3" json:"PhysicalAmaor,omitempty"`
	PhysicalResist           float32      `protobuf:"fixed32,13,opt,name=PhysicalResist,proto3" json:"PhysicalResist,omitempty"`
	MagicAmaor               float32      `protobuf:"fixed32,14,opt,name=MagicAmaor,proto3" json:"MagicAmaor,omitempty"`
	StatusAmaor              float32      `protobuf:"fixed32,15,opt,name=StatusAmaor,proto3" json:"StatusAmaor,omitempty"`
	Dodge                    float32      `protobuf:"fixed32,16,opt,name=Dodge,proto3" json:"Dodge,omitempty"`
	HPRegain                 float32      `protobuf:"fixed32,17,opt,name=HPRegain,proto3" json:"HPRegain,omitempty"`
	RawAttributeStrength     float32      `protobuf:"fixed32,18,opt,name=RawAttributeStrength,proto3" json:"RawAttributeStrength,omitempty"`
	RawAttributeAgility      float32      `protobuf:"fixed32,19,opt,name=RawAttributeAgility,proto3" json:"RawAttributeAgility,omitempty"`
	RawAttributeIntelligence float32      `protobuf:"fixed32,20,opt,name=RawAttributeIntelligence,proto3" json:"RawAttributeIntelligence,omitempty"`
	RawAttack                int32        `protobuf:"varint,21,opt,name=RawAttack,proto3" json:"RawAttack,omitempty"`
	RawAttackSpeed           float32      `protobuf:"fixed32,22,opt,name=RawAttackSpeed,proto3" json:"RawAttackSpeed,omitempty"`
	RawAttackRange           float32      `protobuf:"fixed32,23,opt,name=RawAttackRange,proto3" json:"RawAttackRange,omitempty"`
	RawMoveSpeed             float32      `protobuf:"fixed32,24,opt,name=RawMoveSpeed,proto3" json:"RawMoveSpeed,omitempty"`
	RawMagicScale            float32      `protobuf:"fixed32,25,opt,name=RawMagicScale,proto3" json:"RawMagicScale,omitempty"`
	RawMPRegain              float32      `protobuf:"fixed32,26,opt,name=RawMPRegain,proto3" json:"RawMPRegain,omitempty"`
	RawPhysicalAmaor         float32      `protobuf:"fixed32,27,opt,name=RawPhysicalAmaor,proto3" json:"RawPhysicalAmaor,omitempty"`
	RawPhysicalResist        float32      `protobuf:"fixed32,28,opt,name=RawPhysicalResist,proto3" json:"RawPhysicalResist,omitempty"`
	RawMagicAmaor            float32      `protobuf:"fixed32,29,opt,name=RawMagicAmaor,proto3" json:"RawMagicAmaor,omitempty"`
	RawStatusAmaor           float32      `protobuf:"fixed32,30,opt,name=RawStatusAmaor,proto3" json:"RawStatusAmaor,omitempty"`
	RawDodge                 float32      `protobuf:"fixed32,31,opt,name=RawDodge,proto3" json:"RawDodge,omitempty"`
	RawHPRegain              float32      `protobuf:"fixed32,32,opt,name=RawHPRegain,proto3" json:"RawHPRegain,omitempty"`
	AttributePrimary         int32        `protobuf:"varint,33,opt,name=AttributePrimary,proto3" json:"AttributePrimary,omitempty"`
	DropItems                string       `protobuf:"bytes,34,opt,name=DropItems,proto3" json:"DropItems,omitempty"`
	RemainExperience         int32        `protobuf:"varint,35,opt,name=RemainExperience,proto3" json:"RemainExperience,omitempty"`
	Equips                   []*UnitEquip `protobuf:"bytes,36,rep,name=Equips,proto3" json:"Equips,omitempty"`
	XXX_NoUnkeyedLiteral     struct{}     `json:"-"`
	XXX_unrecognized         []byte       `json:"-"`
	XXX_sizecache            int32        `json:"-"`
}

func (m *UnitBoardDatas) Reset()         { *m = UnitBoardDatas{} }
func (m *UnitBoardDatas) String() string { return proto.CompactTextString(m) }
func (*UnitBoardDatas) ProtoMessage()    {}
func (*UnitBoardDatas) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{13}
}
func (m *UnitBoardDatas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnitBoardDatas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnitBoardDatas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnitBoardDatas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnitBoardDatas.Merge(m, src)
}
func (m *UnitBoardDatas) XXX_Size() int {
	return m.Size()
}
func (m *UnitBoardDatas) XXX_DiscardUnknown() {
	xxx_messageInfo_UnitBoardDatas.DiscardUnknown(m)
}

var xxx_messageInfo_UnitBoardDatas proto.InternalMessageInfo

func (m *UnitBoardDatas) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UnitBoardDatas) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UnitBoardDatas) GetAttributeStrength() float32 {
	if m != nil {
		return m.AttributeStrength
	}
	return 0
}

func (m *UnitBoardDatas) GetAttributeAgility() float32 {
	if m != nil {
		return m.AttributeAgility
	}
	return 0
}

func (m *UnitBoardDatas) GetAttributeIntelligence() float32 {
	if m != nil {
		return m.AttributeIntelligence
	}
	return 0
}

func (m *UnitBoardDatas) GetAttack() int32 {
	if m != nil {
		return m.Attack
	}
	return 0
}

func (m *UnitBoardDatas) GetAttackSpeed() float32 {
	if m != nil {
		return m.AttackSpeed
	}
	return 0
}

func (m *UnitBoardDatas) GetAttackRange() float32 {
	if m != nil {
		return m.AttackRange
	}
	return 0
}

func (m *UnitBoardDatas) GetMoveSpeed() float32 {
	if m != nil {
		return m.MoveSpeed
	}
	return 0
}

func (m *UnitBoardDatas) GetMagicScale() float32 {
	if m != nil {
		return m.MagicScale
	}
	return 0
}

func (m *UnitBoardDatas) GetMPRegain() float32 {
	if m != nil {
		return m.MPRegain
	}
	return 0
}

func (m *UnitBoardDatas) GetPhysicalAmaor() float32 {
	if m != nil {
		return m.PhysicalAmaor
	}
	return 0
}

func (m *UnitBoardDatas) GetPhysicalResist() float32 {
	if m != nil {
		return m.PhysicalResist
	}
	return 0
}

func (m *UnitBoardDatas) GetMagicAmaor() float32 {
	if m != nil {
		return m.MagicAmaor
	}
	return 0
}

func (m *UnitBoardDatas) GetStatusAmaor() float32 {
	if m != nil {
		return m.StatusAmaor
	}
	return 0
}

func (m *UnitBoardDatas) GetDodge() float32 {
	if m != nil {
		return m.Dodge
	}
	return 0
}

func (m *UnitBoardDatas) GetHPRegain() float32 {
	if m != nil {
		return m.HPRegain
	}
	return 0
}

func (m *UnitBoardDatas) GetRawAttributeStrength() float32 {
	if m != nil {
		return m.RawAttributeStrength
	}
	return 0
}

func (m *UnitBoardDatas) GetRawAttributeAgility() float32 {
	if m != nil {
		return m.RawAttributeAgility
	}
	return 0
}

func (m *UnitBoardDatas) GetRawAttributeIntelligence() float32 {
	if m != nil {
		return m.RawAttributeIntelligence
	}
	return 0
}

func (m *UnitBoardDatas) GetRawAttack() int32 {
	if m != nil {
		return m.RawAttack
	}
	return 0
}

func (m *UnitBoardDatas) GetRawAttackSpeed() float32 {
	if m != nil {
		return m.RawAttackSpeed
	}
	return 0
}

func (m *UnitBoardDatas) GetRawAttackRange() float32 {
	if m != nil {
		return m.RawAttackRange
	}
	return 0
}

func (m *UnitBoardDatas) GetRawMoveSpeed() float32 {
	if m != nil {
		return m.RawMoveSpeed
	}
	return 0
}

func (m *UnitBoardDatas) GetRawMagicScale() float32 {
	if m != nil {
		return m.RawMagicScale
	}
	return 0
}

func (m *UnitBoardDatas) GetRawMPRegain() float32 {
	if m != nil {
		return m.RawMPRegain
	}
	return 0
}

func (m *UnitBoardDatas) GetRawPhysicalAmaor() float32 {
	if m != nil {
		return m.RawPhysicalAmaor
	}
	return 0
}

func (m *UnitBoardDatas) GetRawPhysicalResist() float32 {
	if m != nil {
		return m.RawPhysicalResist
	}
	return 0
}

func (m *UnitBoardDatas) GetRawMagicAmaor() float32 {
	if m != nil {
		return m.RawMagicAmaor
	}
	return 0
}

func (m *UnitBoardDatas) GetRawStatusAmaor() float32 {
	if m != nil {
		return m.RawStatusAmaor
	}
	return 0
}

func (m *UnitBoardDatas) GetRawDodge() float32 {
	if m != nil {
		return m.RawDodge
	}
	return 0
}

func (m *UnitBoardDatas) GetRawHPRegain() float32 {
	if m != nil {
		return m.RawHPRegain
	}
	return 0
}

func (m *UnitBoardDatas) GetAttributePrimary() int32 {
	if m != nil {
		return m.AttributePrimary
	}
	return 0
}

func (m *UnitBoardDatas) GetDropItems() string {
	if m != nil {
		return m.DropItems
	}
	return ""
}

func (m *UnitBoardDatas) GetRemainExperience() int32 {
	if m != nil {
		return m.RemainExperience
	}
	return 0
}

func (m *UnitBoardDatas) GetEquips() []*UnitEquip {
	if m != nil {
		return m.Equips
	}
	return nil
}

//技能数据
type SimpleSkillDatas struct {
	TypeID               int32    `protobuf:"varint,1,opt,name=TypeID,proto3" json:"TypeID,omitempty"`
	Level                int32    `protobuf:"varint,2,opt,name=Level,proto3" json:"Level,omitempty"`
	Index                int32    `protobuf:"varint,5,opt,name=Index,proto3" json:"Index,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SimpleSkillDatas) Reset()         { *m = SimpleSkillDatas{} }
func (m *SimpleSkillDatas) String() string { return proto.CompactTextString(m) }
func (*SimpleSkillDatas) ProtoMessage()    {}
func (*SimpleSkillDatas) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{14}
}
func (m *SimpleSkillDatas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SimpleSkillDatas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SimpleSkillDatas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SimpleSkillDatas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SimpleSkillDatas.Merge(m, src)
}
func (m *SimpleSkillDatas) XXX_Size() int {
	return m.Size()
}
func (m *SimpleSkillDatas) XXX_DiscardUnknown() {
	xxx_messageInfo_SimpleSkillDatas.DiscardUnknown(m)
}

var xxx_messageInfo_SimpleSkillDatas proto.InternalMessageInfo

func (m *SimpleSkillDatas) GetTypeID() int32 {
	if m != nil {
		return m.TypeID
	}
	return 0
}

func (m *SimpleSkillDatas) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *SimpleSkillDatas) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

//获取单位面板详细信息
type CS_GetUnitInfo struct {
	UnitID               int32    `protobuf:"varint,1,opt,name=UnitID,proto3" json:"UnitID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetUnitInfo) Reset()         { *m = CS_GetUnitInfo{} }
func (m *CS_GetUnitInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetUnitInfo) ProtoMessage()    {}
func (*CS_GetUnitInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{15}
}
func (m *CS_GetUnitInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetUnitInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetUnitInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetUnitInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetUnitInfo.Merge(m, src)
}
func (m *CS_GetUnitInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetUnitInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetUnitInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetUnitInfo proto.InternalMessageInfo

func (m *CS_GetUnitInfo) GetUnitID() int32 {
	if m != nil {
		return m.UnitID
	}
	return 0
}

//获取角色简要信息(装备和技能)
type CS_GetCharacterSimpleInfo struct {
	CharacterID          int32    `protobuf:"varint,1,opt,name=CharacterID,proto3" json:"CharacterID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetCharacterSimpleInfo) Reset()         { *m = CS_GetCharacterSimpleInfo{} }
func (m *CS_GetCharacterSimpleInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetCharacterSimpleInfo) ProtoMessage()    {}
func (*CS_GetCharacterSimpleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{16}
}
func (m *CS_GetCharacterSimpleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetCharacterSimpleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetCharacterSimpleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetCharacterSimpleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetCharacterSimpleInfo.Merge(m, src)
}
func (m *CS_GetCharacterSimpleInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetCharacterSimpleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetCharacterSimpleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetCharacterSimpleInfo proto.InternalMessageInfo

func (m *CS_GetCharacterSimpleInfo) GetCharacterID() int32 {
	if m != nil {
		return m.CharacterID
	}
	return 0
}

//返回获取角色简要信息(装备和技能)
type SC_GetCharacterSimpleInfo struct {
	CharacterID          int32    `protobuf:"varint,1,opt,name=CharacterID,proto3" json:"CharacterID,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Level                int32    `protobuf:"varint,3,opt,name=Level,proto3" json:"Level,omitempty"`
	ModeType             string   `protobuf:"bytes,4,opt,name=ModeType,proto3" json:"ModeType,omitempty"`
	EquipItems           []string `protobuf:"bytes,5,rep,name=EquipItems,proto3" json:"EquipItems,omitempty"`
	Skills               string   `protobuf:"bytes,6,opt,name=Skills,proto3" json:"Skills,omitempty"`
	LastLoginDate        string   `protobuf:"bytes,7,opt,name=LastLoginDate,proto3" json:"LastLoginDate,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SC_GetCharacterSimpleInfo) Reset()         { *m = SC_GetCharacterSimpleInfo{} }
func (m *SC_GetCharacterSimpleInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetCharacterSimpleInfo) ProtoMessage()    {}
func (*SC_GetCharacterSimpleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{17}
}
func (m *SC_GetCharacterSimpleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetCharacterSimpleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetCharacterSimpleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetCharacterSimpleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetCharacterSimpleInfo.Merge(m, src)
}
func (m *SC_GetCharacterSimpleInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetCharacterSimpleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetCharacterSimpleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetCharacterSimpleInfo proto.InternalMessageInfo

func (m *SC_GetCharacterSimpleInfo) GetCharacterID() int32 {
	if m != nil {
		return m.CharacterID
	}
	return 0
}

func (m *SC_GetCharacterSimpleInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SC_GetCharacterSimpleInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *SC_GetCharacterSimpleInfo) GetModeType() string {
	if m != nil {
		return m.ModeType
	}
	return ""
}

func (m *SC_GetCharacterSimpleInfo) GetEquipItems() []string {
	if m != nil {
		return m.EquipItems
	}
	return nil
}

func (m *SC_GetCharacterSimpleInfo) GetSkills() string {
	if m != nil {
		return m.Skills
	}
	return ""
}

func (m *SC_GetCharacterSimpleInfo) GetLastLoginDate() string {
	if m != nil {
		return m.LastLoginDate
	}
	return ""
}

//获取道具额外信息
type CS_GetItemExtraInfo struct {
	TypeId               int32    `protobuf:"varint,1,opt,name=TypeId,proto3" json:"TypeId,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetItemExtraInfo) Reset()         { *m = CS_GetItemExtraInfo{} }
func (m *CS_GetItemExtraInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetItemExtraInfo) ProtoMessage()    {}
func (*CS_GetItemExtraInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{18}
}
func (m *CS_GetItemExtraInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetItemExtraInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetItemExtraInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetItemExtraInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetItemExtraInfo.Merge(m, src)
}
func (m *CS_GetItemExtraInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetItemExtraInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetItemExtraInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetItemExtraInfo proto.InternalMessageInfo

func (m *CS_GetItemExtraInfo) GetTypeId() int32 {
	if m != nil {
		return m.TypeId
	}
	return 0
}

type SC_GetItemExtraInfo struct {
	TypeId               int32    `protobuf:"varint,1,opt,name=TypeId,proto3" json:"TypeId,omitempty"`
	Exception            int32    `protobuf:"varint,2,opt,name=Exception,proto3" json:"Exception,omitempty"`
	ExceptionParam       string   `protobuf:"bytes,3,opt,name=ExceptionParam,proto3" json:"ExceptionParam,omitempty"`
	EquipNeedLevel       int32    `protobuf:"varint,4,opt,name=EquipNeedLevel,proto3" json:"EquipNeedLevel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SC_GetItemExtraInfo) Reset()         { *m = SC_GetItemExtraInfo{} }
func (m *SC_GetItemExtraInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetItemExtraInfo) ProtoMessage()    {}
func (*SC_GetItemExtraInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{19}
}
func (m *SC_GetItemExtraInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetItemExtraInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetItemExtraInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetItemExtraInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetItemExtraInfo.Merge(m, src)
}
func (m *SC_GetItemExtraInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetItemExtraInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetItemExtraInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetItemExtraInfo proto.InternalMessageInfo

func (m *SC_GetItemExtraInfo) GetTypeId() int32 {
	if m != nil {
		return m.TypeId
	}
	return 0
}

func (m *SC_GetItemExtraInfo) GetException() int32 {
	if m != nil {
		return m.Exception
	}
	return 0
}

func (m *SC_GetItemExtraInfo) GetExceptionParam() string {
	if m != nil {
		return m.ExceptionParam
	}
	return ""
}

func (m *SC_GetItemExtraInfo) GetEquipNeedLevel() int32 {
	if m != nil {
		return m.EquipNeedLevel
	}
	return 0
}

//获取自己背包详细信息
type CS_GetBagInfo struct {
	UnitID               int32    `protobuf:"varint,1,opt,name=UnitID,proto3" json:"UnitID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetBagInfo) Reset()         { *m = CS_GetBagInfo{} }
func (m *CS_GetBagInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetBagInfo) ProtoMessage()    {}
func (*CS_GetBagInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{20}
}
func (m *CS_GetBagInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetBagInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetBagInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetBagInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetBagInfo.Merge(m, src)
}
func (m *CS_GetBagInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetBagInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetBagInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetBagInfo proto.InternalMessageInfo

func (m *CS_GetBagInfo) GetUnitID() int32 {
	if m != nil {
		return m.UnitID
	}
	return 0
}

//交换道具位置 背包位置
type CS_ChangeItemPos struct {
	SrcPos               int32    `protobuf:"varint,1,opt,name=SrcPos,proto3" json:"SrcPos,omitempty"`
	DestPos              int32    `protobuf:"varint,2,opt,name=DestPos,proto3" json:"DestPos,omitempty"`
	SrcType              int32    `protobuf:"varint,3,opt,name=SrcType,proto3" json:"SrcType,omitempty"`
	DestType             int32    `protobuf:"varint,4,opt,name=DestType,proto3" json:"DestType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_ChangeItemPos) Reset()         { *m = CS_ChangeItemPos{} }
func (m *CS_ChangeItemPos) String() string { return proto.CompactTextString(m) }
func (*CS_ChangeItemPos) ProtoMessage()    {}
func (*CS_ChangeItemPos) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{21}
}
func (m *CS_ChangeItemPos) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_ChangeItemPos) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_ChangeItemPos.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_ChangeItemPos) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_ChangeItemPos.Merge(m, src)
}
func (m *CS_ChangeItemPos) XXX_Size() int {
	return m.Size()
}
func (m *CS_ChangeItemPos) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_ChangeItemPos.DiscardUnknown(m)
}

var xxx_messageInfo_CS_ChangeItemPos proto.InternalMessageInfo

func (m *CS_ChangeItemPos) GetSrcPos() int32 {
	if m != nil {
		return m.SrcPos
	}
	return 0
}

func (m *CS_ChangeItemPos) GetDestPos() int32 {
	if m != nil {
		return m.DestPos
	}
	return 0
}

func (m *CS_ChangeItemPos) GetSrcType() int32 {
	if m != nil {
		return m.SrcType
	}
	return 0
}

func (m *CS_ChangeItemPos) GetDestType() int32 {
	if m != nil {
		return m.DestType
	}
	return 0
}

//删除道具
type CS_DestroyItem struct {
	SrcPos               int32    `protobuf:"varint,1,opt,name=SrcPos,proto3" json:"SrcPos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_DestroyItem) Reset()         { *m = CS_DestroyItem{} }
func (m *CS_DestroyItem) String() string { return proto.CompactTextString(m) }
func (*CS_DestroyItem) ProtoMessage()    {}
func (*CS_DestroyItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{22}
}
func (m *CS_DestroyItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_DestroyItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_DestroyItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_DestroyItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_DestroyItem.Merge(m, src)
}
func (m *CS_DestroyItem) XXX_Size() int {
	return m.Size()
}
func (m *CS_DestroyItem) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_DestroyItem.DiscardUnknown(m)
}

var xxx_messageInfo_CS_DestroyItem proto.InternalMessageInfo

func (m *CS_DestroyItem) GetSrcPos() int32 {
	if m != nil {
		return m.SrcPos
	}
	return 0
}

//系统回收道具
type CS_SystemHuiShouItem struct {
	SrcPos               int32    `protobuf:"varint,1,opt,name=SrcPos,proto3" json:"SrcPos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_SystemHuiShouItem) Reset()         { *m = CS_SystemHuiShouItem{} }
func (m *CS_SystemHuiShouItem) String() string { return proto.CompactTextString(m) }
func (*CS_SystemHuiShouItem) ProtoMessage()    {}
func (*CS_SystemHuiShouItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{23}
}
func (m *CS_SystemHuiShouItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_SystemHuiShouItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_SystemHuiShouItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_SystemHuiShouItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_SystemHuiShouItem.Merge(m, src)
}
func (m *CS_SystemHuiShouItem) XXX_Size() int {
	return m.Size()
}
func (m *CS_SystemHuiShouItem) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_SystemHuiShouItem.DiscardUnknown(m)
}

var xxx_messageInfo_CS_SystemHuiShouItem proto.InternalMessageInfo

func (m *CS_SystemHuiShouItem) GetSrcPos() int32 {
	if m != nil {
		return m.SrcPos
	}
	return 0
}

type SC_UnitInfo struct {
	UnitData             *UnitBoardDatas `protobuf:"bytes,1,opt,name=UnitData,proto3" json:"UnitData,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SC_UnitInfo) Reset()         { *m = SC_UnitInfo{} }
func (m *SC_UnitInfo) String() string { return proto.CompactTextString(m) }
func (*SC_UnitInfo) ProtoMessage()    {}
func (*SC_UnitInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{24}
}
func (m *SC_UnitInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_UnitInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_UnitInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_UnitInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_UnitInfo.Merge(m, src)
}
func (m *SC_UnitInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_UnitInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_UnitInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_UnitInfo proto.InternalMessageInfo

func (m *SC_UnitInfo) GetUnitData() *UnitBoardDatas {
	if m != nil {
		return m.UnitData
	}
	return nil
}

type SC_BagInfo struct {
	Equips               []*UnitEquip `protobuf:"bytes,1,rep,name=Equips,proto3" json:"Equips,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SC_BagInfo) Reset()         { *m = SC_BagInfo{} }
func (m *SC_BagInfo) String() string { return proto.CompactTextString(m) }
func (*SC_BagInfo) ProtoMessage()    {}
func (*SC_BagInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{25}
}
func (m *SC_BagInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_BagInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_BagInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_BagInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_BagInfo.Merge(m, src)
}
func (m *SC_BagInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_BagInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_BagInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_BagInfo proto.InternalMessageInfo

func (m *SC_BagInfo) GetEquips() []*UnitEquip {
	if m != nil {
		return m.Equips
	}
	return nil
}

//玩家升级技能
type CS_PlayerUpgradeSkill struct {
	TypeID               int32    `protobuf:"varint,1,opt,name=TypeID,proto3" json:"TypeID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_PlayerUpgradeSkill) Reset()         { *m = CS_PlayerUpgradeSkill{} }
func (m *CS_PlayerUpgradeSkill) String() string { return proto.CompactTextString(m) }
func (*CS_PlayerUpgradeSkill) ProtoMessage()    {}
func (*CS_PlayerUpgradeSkill) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{26}
}
func (m *CS_PlayerUpgradeSkill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_PlayerUpgradeSkill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_PlayerUpgradeSkill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_PlayerUpgradeSkill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_PlayerUpgradeSkill.Merge(m, src)
}
func (m *CS_PlayerUpgradeSkill) XXX_Size() int {
	return m.Size()
}
func (m *CS_PlayerUpgradeSkill) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_PlayerUpgradeSkill.DiscardUnknown(m)
}

var xxx_messageInfo_CS_PlayerUpgradeSkill proto.InternalMessageInfo

func (m *CS_PlayerUpgradeSkill) GetTypeID() int32 {
	if m != nil {
		return m.TypeID
	}
	return 0
}

//玩家移动操作
type CS_PlayerMove struct {
	IDs                  []int32  `protobuf:"varint,1,rep,packed,name=IDs,proto3" json:"IDs,omitempty"`
	X                    float32  `protobuf:"fixed32,2,opt,name=X,proto3" json:"X,omitempty"`
	Y                    float32  `protobuf:"fixed32,3,opt,name=Y,proto3" json:"Y,omitempty"`
	IsStart              bool     `protobuf:"varint,4,opt,name=IsStart,proto3" json:"IsStart,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_PlayerMove) Reset()         { *m = CS_PlayerMove{} }
func (m *CS_PlayerMove) String() string { return proto.CompactTextString(m) }
func (*CS_PlayerMove) ProtoMessage()    {}
func (*CS_PlayerMove) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{27}
}
func (m *CS_PlayerMove) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_PlayerMove) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_PlayerMove.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_PlayerMove) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_PlayerMove.Merge(m, src)
}
func (m *CS_PlayerMove) XXX_Size() int {
	return m.Size()
}
func (m *CS_PlayerMove) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_PlayerMove.DiscardUnknown(m)
}

var xxx_messageInfo_CS_PlayerMove proto.InternalMessageInfo

func (m *CS_PlayerMove) GetIDs() []int32 {
	if m != nil {
		return m.IDs
	}
	return nil
}

func (m *CS_PlayerMove) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *CS_PlayerMove) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *CS_PlayerMove) GetIsStart() bool {
	if m != nil {
		return m.IsStart
	}
	return false
}

//玩家攻击操作
type CS_PlayerAttack struct {
	IDs                  []int32  `protobuf:"varint,1,rep,packed,name=IDs,proto3" json:"IDs,omitempty"`
	TargetUnitID         int32    `protobuf:"varint,2,opt,name=TargetUnitID,proto3" json:"TargetUnitID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_PlayerAttack) Reset()         { *m = CS_PlayerAttack{} }
func (m *CS_PlayerAttack) String() string { return proto.CompactTextString(m) }
func (*CS_PlayerAttack) ProtoMessage()    {}
func (*CS_PlayerAttack) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{28}
}
func (m *CS_PlayerAttack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_PlayerAttack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_PlayerAttack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_PlayerAttack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_PlayerAttack.Merge(m, src)
}
func (m *CS_PlayerAttack) XXX_Size() int {
	return m.Size()
}
func (m *CS_PlayerAttack) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_PlayerAttack.DiscardUnknown(m)
}

var xxx_messageInfo_CS_PlayerAttack proto.InternalMessageInfo

func (m *CS_PlayerAttack) GetIDs() []int32 {
	if m != nil {
		return m.IDs
	}
	return nil
}

func (m *CS_PlayerAttack) GetTargetUnitID() int32 {
	if m != nil {
		return m.TargetUnitID
	}
	return 0
}

//玩家技能操作(包括道具)
type CS_PlayerSkill struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	SkillID              int32    `protobuf:"varint,2,opt,name=SkillID,proto3" json:"SkillID,omitempty"`
	X                    float32  `protobuf:"fixed32,3,opt,name=X,proto3" json:"X,omitempty"`
	Y                    float32  `protobuf:"fixed32,4,opt,name=Y,proto3" json:"Y,omitempty"`
	TargetUnitID         int32    `protobuf:"varint,5,opt,name=TargetUnitID,proto3" json:"TargetUnitID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_PlayerSkill) Reset()         { *m = CS_PlayerSkill{} }
func (m *CS_PlayerSkill) String() string { return proto.CompactTextString(m) }
func (*CS_PlayerSkill) ProtoMessage()    {}
func (*CS_PlayerSkill) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{29}
}
func (m *CS_PlayerSkill) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_PlayerSkill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_PlayerSkill.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_PlayerSkill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_PlayerSkill.Merge(m, src)
}
func (m *CS_PlayerSkill) XXX_Size() int {
	return m.Size()
}
func (m *CS_PlayerSkill) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_PlayerSkill.DiscardUnknown(m)
}

var xxx_messageInfo_CS_PlayerSkill proto.InternalMessageInfo

func (m *CS_PlayerSkill) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CS_PlayerSkill) GetSkillID() int32 {
	if m != nil {
		return m.SkillID
	}
	return 0
}

func (m *CS_PlayerSkill) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *CS_PlayerSkill) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *CS_PlayerSkill) GetTargetUnitID() int32 {
	if m != nil {
		return m.TargetUnitID
	}
	return 0
}

//玩家切换攻击模式
type CS_ChangeAttackMode struct {
	AttackMode           int32    `protobuf:"varint,1,opt,name=AttackMode,proto3" json:"AttackMode,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_ChangeAttackMode) Reset()         { *m = CS_ChangeAttackMode{} }
func (m *CS_ChangeAttackMode) String() string { return proto.CompactTextString(m) }
func (*CS_ChangeAttackMode) ProtoMessage()    {}
func (*CS_ChangeAttackMode) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{30}
}
func (m *CS_ChangeAttackMode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_ChangeAttackMode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_ChangeAttackMode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_ChangeAttackMode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_ChangeAttackMode.Merge(m, src)
}
func (m *CS_ChangeAttackMode) XXX_Size() int {
	return m.Size()
}
func (m *CS_ChangeAttackMode) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_ChangeAttackMode.DiscardUnknown(m)
}

var xxx_messageInfo_CS_ChangeAttackMode proto.InternalMessageInfo

func (m *CS_ChangeAttackMode) GetAttackMode() int32 {
	if m != nil {
		return m.AttackMode
	}
	return 0
}

//组队操作
type CS_OrganizeTeam struct {
	Player1              int32    `protobuf:"varint,1,opt,name=Player1,proto3" json:"Player1,omitempty"`
	Player2              int32    `protobuf:"varint,2,opt,name=Player2,proto3" json:"Player2,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_OrganizeTeam) Reset()         { *m = CS_OrganizeTeam{} }
func (m *CS_OrganizeTeam) String() string { return proto.CompactTextString(m) }
func (*CS_OrganizeTeam) ProtoMessage()    {}
func (*CS_OrganizeTeam) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{31}
}
func (m *CS_OrganizeTeam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_OrganizeTeam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_OrganizeTeam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_OrganizeTeam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_OrganizeTeam.Merge(m, src)
}
func (m *CS_OrganizeTeam) XXX_Size() int {
	return m.Size()
}
func (m *CS_OrganizeTeam) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_OrganizeTeam.DiscardUnknown(m)
}

var xxx_messageInfo_CS_OrganizeTeam proto.InternalMessageInfo

func (m *CS_OrganizeTeam) GetPlayer1() int32 {
	if m != nil {
		return m.Player1
	}
	return 0
}

func (m *CS_OrganizeTeam) GetPlayer2() int32 {
	if m != nil {
		return m.Player2
	}
	return 0
}

//组队请求
type SC_RequestTeam struct {
	SrcPlayerUID         int32    `protobuf:"varint,1,opt,name=SrcPlayerUID,proto3" json:"SrcPlayerUID,omitempty"`
	SrcName              string   `protobuf:"bytes,2,opt,name=SrcName,proto3" json:"SrcName,omitempty"`
	SrcUnitTypeID        int32    `protobuf:"varint,3,opt,name=SrcUnitTypeID,proto3" json:"SrcUnitTypeID,omitempty"`
	SrcLevel             int32    `protobuf:"varint,4,opt,name=SrcLevel,proto3" json:"SrcLevel,omitempty"`
	RequestType          int32    `protobuf:"varint,5,opt,name=RequestType,proto3" json:"RequestType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SC_RequestTeam) Reset()         { *m = SC_RequestTeam{} }
func (m *SC_RequestTeam) String() string { return proto.CompactTextString(m) }
func (*SC_RequestTeam) ProtoMessage()    {}
func (*SC_RequestTeam) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{32}
}
func (m *SC_RequestTeam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_RequestTeam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_RequestTeam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_RequestTeam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_RequestTeam.Merge(m, src)
}
func (m *SC_RequestTeam) XXX_Size() int {
	return m.Size()
}
func (m *SC_RequestTeam) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_RequestTeam.DiscardUnknown(m)
}

var xxx_messageInfo_SC_RequestTeam proto.InternalMessageInfo

func (m *SC_RequestTeam) GetSrcPlayerUID() int32 {
	if m != nil {
		return m.SrcPlayerUID
	}
	return 0
}

func (m *SC_RequestTeam) GetSrcName() string {
	if m != nil {
		return m.SrcName
	}
	return ""
}

func (m *SC_RequestTeam) GetSrcUnitTypeID() int32 {
	if m != nil {
		return m.SrcUnitTypeID
	}
	return 0
}

func (m *SC_RequestTeam) GetSrcLevel() int32 {
	if m != nil {
		return m.SrcLevel
	}
	return 0
}

func (m *SC_RequestTeam) GetRequestType() int32 {
	if m != nil {
		return m.RequestType
	}
	return 0
}

//回复组队请求
type CS_ResponseOrgTeam struct {
	SrcPlayerUID         int32    `protobuf:"varint,1,opt,name=SrcPlayerUID,proto3" json:"SrcPlayerUID,omitempty"`
	IsAgree              int32    `protobuf:"varint,2,opt,name=IsAgree,proto3" json:"IsAgree,omitempty"`
	RequestType          int32    `protobuf:"varint,3,opt,name=RequestType,proto3" json:"RequestType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_ResponseOrgTeam) Reset()         { *m = CS_ResponseOrgTeam{} }
func (m *CS_ResponseOrgTeam) String() string { return proto.CompactTextString(m) }
func (*CS_ResponseOrgTeam) ProtoMessage()    {}
func (*CS_ResponseOrgTeam) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{33}
}
func (m *CS_ResponseOrgTeam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_ResponseOrgTeam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_ResponseOrgTeam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_ResponseOrgTeam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_ResponseOrgTeam.Merge(m, src)
}
func (m *CS_ResponseOrgTeam) XXX_Size() int {
	return m.Size()
}
func (m *CS_ResponseOrgTeam) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_ResponseOrgTeam.DiscardUnknown(m)
}

var xxx_messageInfo_CS_ResponseOrgTeam proto.InternalMessageInfo

func (m *CS_ResponseOrgTeam) GetSrcPlayerUID() int32 {
	if m != nil {
		return m.SrcPlayerUID
	}
	return 0
}

func (m *CS_ResponseOrgTeam) GetIsAgree() int32 {
	if m != nil {
		return m.IsAgree
	}
	return 0
}

func (m *CS_ResponseOrgTeam) GetRequestType() int32 {
	if m != nil {
		return m.RequestType
	}
	return 0
}

//队伍踢人
type CS_OutTeam struct {
	OutPlayerUID         int32    `protobuf:"varint,1,opt,name=OutPlayerUID,proto3" json:"OutPlayerUID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_OutTeam) Reset()         { *m = CS_OutTeam{} }
func (m *CS_OutTeam) String() string { return proto.CompactTextString(m) }
func (*CS_OutTeam) ProtoMessage()    {}
func (*CS_OutTeam) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{34}
}
func (m *CS_OutTeam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_OutTeam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_OutTeam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_OutTeam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_OutTeam.Merge(m, src)
}
func (m *CS_OutTeam) XXX_Size() int {
	return m.Size()
}
func (m *CS_OutTeam) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_OutTeam.DiscardUnknown(m)
}

var xxx_messageInfo_CS_OutTeam proto.InternalMessageInfo

func (m *CS_OutTeam) GetOutPlayerUID() int32 {
	if m != nil {
		return m.OutPlayerUID
	}
	return 0
}

//队伍玩家信息
type TeamPlayerInfo struct {
	UID                  int32    `protobuf:"varint,1,opt,name=UID,proto3" json:"UID,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	HP                   int32    `protobuf:"varint,3,opt,name=HP,proto3" json:"HP,omitempty"`
	MP                   int32    `protobuf:"varint,4,opt,name=MP,proto3" json:"MP,omitempty"`
	MaxHP                int32    `protobuf:"varint,5,opt,name=MaxHP,proto3" json:"MaxHP,omitempty"`
	MaxMP                int32    `protobuf:"varint,6,opt,name=MaxMP,proto3" json:"MaxMP,omitempty"`
	ID                   int32    `protobuf:"varint,7,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TeamPlayerInfo) Reset()         { *m = TeamPlayerInfo{} }
func (m *TeamPlayerInfo) String() string { return proto.CompactTextString(m) }
func (*TeamPlayerInfo) ProtoMessage()    {}
func (*TeamPlayerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{35}
}
func (m *TeamPlayerInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TeamPlayerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TeamPlayerInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TeamPlayerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TeamPlayerInfo.Merge(m, src)
}
func (m *TeamPlayerInfo) XXX_Size() int {
	return m.Size()
}
func (m *TeamPlayerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TeamPlayerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TeamPlayerInfo proto.InternalMessageInfo

func (m *TeamPlayerInfo) GetUID() int32 {
	if m != nil {
		return m.UID
	}
	return 0
}

func (m *TeamPlayerInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TeamPlayerInfo) GetHP() int32 {
	if m != nil {
		return m.HP
	}
	return 0
}

func (m *TeamPlayerInfo) GetMP() int32 {
	if m != nil {
		return m.MP
	}
	return 0
}

func (m *TeamPlayerInfo) GetMaxHP() int32 {
	if m != nil {
		return m.MaxHP
	}
	return 0
}

func (m *TeamPlayerInfo) GetMaxMP() int32 {
	if m != nil {
		return m.MaxMP
	}
	return 0
}

func (m *TeamPlayerInfo) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

//更新队伍信息
type SC_UpdateTeamInfo struct {
	TeamID               int32             `protobuf:"varint,1,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	MainUID              int32             `protobuf:"varint,2,opt,name=MainUID,proto3" json:"MainUID,omitempty"`
	TPInfo               []*TeamPlayerInfo `protobuf:"bytes,3,rep,name=TPInfo,proto3" json:"TPInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SC_UpdateTeamInfo) Reset()         { *m = SC_UpdateTeamInfo{} }
func (m *SC_UpdateTeamInfo) String() string { return proto.CompactTextString(m) }
func (*SC_UpdateTeamInfo) ProtoMessage()    {}
func (*SC_UpdateTeamInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{36}
}
func (m *SC_UpdateTeamInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_UpdateTeamInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_UpdateTeamInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_UpdateTeamInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_UpdateTeamInfo.Merge(m, src)
}
func (m *SC_UpdateTeamInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_UpdateTeamInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_UpdateTeamInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_UpdateTeamInfo proto.InternalMessageInfo

func (m *SC_UpdateTeamInfo) GetTeamID() int32 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *SC_UpdateTeamInfo) GetMainUID() int32 {
	if m != nil {
		return m.MainUID
	}
	return 0
}

func (m *SC_UpdateTeamInfo) GetTPInfo() []*TeamPlayerInfo {
	if m != nil {
		return m.TPInfo
	}
	return nil
}

//提示文字
type SC_NoticeWords struct {
	TypeID               int32    `protobuf:"varint,1,opt,name=TypeID,proto3" json:"TypeID,omitempty"`
	P                    []string `protobuf:"bytes,2,rep,name=P,proto3" json:"P,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SC_NoticeWords) Reset()         { *m = SC_NoticeWords{} }
func (m *SC_NoticeWords) String() string { return proto.CompactTextString(m) }
func (*SC_NoticeWords) ProtoMessage()    {}
func (*SC_NoticeWords) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{37}
}
func (m *SC_NoticeWords) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_NoticeWords) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_NoticeWords.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_NoticeWords) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_NoticeWords.Merge(m, src)
}
func (m *SC_NoticeWords) XXX_Size() int {
	return m.Size()
}
func (m *SC_NoticeWords) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_NoticeWords.DiscardUnknown(m)
}

var xxx_messageInfo_SC_NoticeWords proto.InternalMessageInfo

func (m *SC_NoticeWords) GetTypeID() int32 {
	if m != nil {
		return m.TypeID
	}
	return 0
}

func (m *SC_NoticeWords) GetP() []string {
	if m != nil {
		return m.P
	}
	return nil
}

//技能数据
type SkillDatas struct {
	TypeID                int32    `protobuf:"varint,1,opt,name=TypeID,proto3" json:"TypeID,omitempty"`
	Level                 int32    `protobuf:"varint,2,opt,name=Level,proto3" json:"Level,omitempty"`
	RemainCDTime          float32  `protobuf:"fixed32,3,opt,name=RemainCDTime,proto3" json:"RemainCDTime,omitempty"`
	CanUpgrade            int32    `protobuf:"varint,4,opt,name=CanUpgrade,proto3" json:"CanUpgrade,omitempty"`
	Index                 int32    `protobuf:"varint,5,opt,name=Index,proto3" json:"Index,omitempty"`
	CastType              int32    `protobuf:"varint,6,opt,name=CastType,proto3" json:"CastType,omitempty"`
	CastTargetType        int32    `protobuf:"varint,7,opt,name=CastTargetType,proto3" json:"CastTargetType,omitempty"`
	UnitTargetTeam        int32    `protobuf:"varint,8,opt,name=UnitTargetTeam,proto3" json:"UnitTargetTeam,omitempty"`
	UnitTargetCamp        int32    `protobuf:"varint,9,opt,name=UnitTargetCamp,proto3" json:"UnitTargetCamp,omitempty"`
	NoCareMagicImmune     int32    `protobuf:"varint,10,opt,name=NoCareMagicImmune,proto3" json:"NoCareMagicImmune,omitempty"`
	CastRange             float32  `protobuf:"fixed32,11,opt,name=CastRange,proto3" json:"CastRange,omitempty"`
	Cooldown              float32  `protobuf:"fixed32,12,opt,name=Cooldown,proto3" json:"Cooldown,omitempty"`
	HurtRange             float32  `protobuf:"fixed32,13,opt,name=HurtRange,proto3" json:"HurtRange,omitempty"`
	ManaCost              int32    `protobuf:"varint,14,opt,name=ManaCost,proto3" json:"ManaCost,omitempty"`
	AttackAutoActive      int32    `protobuf:"varint,15,opt,name=AttackAutoActive,proto3" json:"AttackAutoActive,omitempty"`
	Visible               int32    `protobuf:"varint,16,opt,name=Visible,proto3" json:"Visible,omitempty"`
	RemainSkillCount      int32    `protobuf:"varint,17,opt,name=RemainSkillCount,proto3" json:"RemainSkillCount,omitempty"`
	MaxLevel              int32    `protobuf:"varint,18,opt,name=MaxLevel,proto3" json:"MaxLevel,omitempty"`
	RequiredLevel         int32    `protobuf:"varint,19,opt,name=RequiredLevel,proto3" json:"RequiredLevel,omitempty"`
	LevelsBetweenUpgrades int32    `protobuf:"varint,20,opt,name=LevelsBetweenUpgrades,proto3" json:"LevelsBetweenUpgrades,omitempty"`
	InitLevel             int32    `protobuf:"varint,21,opt,name=InitLevel,proto3" json:"InitLevel,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *SkillDatas) Reset()         { *m = SkillDatas{} }
func (m *SkillDatas) String() string { return proto.CompactTextString(m) }
func (*SkillDatas) ProtoMessage()    {}
func (*SkillDatas) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{38}
}
func (m *SkillDatas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SkillDatas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SkillDatas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SkillDatas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SkillDatas.Merge(m, src)
}
func (m *SkillDatas) XXX_Size() int {
	return m.Size()
}
func (m *SkillDatas) XXX_DiscardUnknown() {
	xxx_messageInfo_SkillDatas.DiscardUnknown(m)
}

var xxx_messageInfo_SkillDatas proto.InternalMessageInfo

func (m *SkillDatas) GetTypeID() int32 {
	if m != nil {
		return m.TypeID
	}
	return 0
}

func (m *SkillDatas) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *SkillDatas) GetRemainCDTime() float32 {
	if m != nil {
		return m.RemainCDTime
	}
	return 0
}

func (m *SkillDatas) GetCanUpgrade() int32 {
	if m != nil {
		return m.CanUpgrade
	}
	return 0
}

func (m *SkillDatas) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SkillDatas) GetCastType() int32 {
	if m != nil {
		return m.CastType
	}
	return 0
}

func (m *SkillDatas) GetCastTargetType() int32 {
	if m != nil {
		return m.CastTargetType
	}
	return 0
}

func (m *SkillDatas) GetUnitTargetTeam() int32 {
	if m != nil {
		return m.UnitTargetTeam
	}
	return 0
}

func (m *SkillDatas) GetUnitTargetCamp() int32 {
	if m != nil {
		return m.UnitTargetCamp
	}
	return 0
}

func (m *SkillDatas) GetNoCareMagicImmune() int32 {
	if m != nil {
		return m.NoCareMagicImmune
	}
	return 0
}

func (m *SkillDatas) GetCastRange() float32 {
	if m != nil {
		return m.CastRange
	}
	return 0
}

func (m *SkillDatas) GetCooldown() float32 {
	if m != nil {
		return m.Cooldown
	}
	return 0
}

func (m *SkillDatas) GetHurtRange() float32 {
	if m != nil {
		return m.HurtRange
	}
	return 0
}

func (m *SkillDatas) GetManaCost() int32 {
	if m != nil {
		return m.ManaCost
	}
	return 0
}

func (m *SkillDatas) GetAttackAutoActive() int32 {
	if m != nil {
		return m.AttackAutoActive
	}
	return 0
}

func (m *SkillDatas) GetVisible() int32 {
	if m != nil {
		return m.Visible
	}
	return 0
}

func (m *SkillDatas) GetRemainSkillCount() int32 {
	if m != nil {
		return m.RemainSkillCount
	}
	return 0
}

func (m *SkillDatas) GetMaxLevel() int32 {
	if m != nil {
		return m.MaxLevel
	}
	return 0
}

func (m *SkillDatas) GetRequiredLevel() int32 {
	if m != nil {
		return m.RequiredLevel
	}
	return 0
}

func (m *SkillDatas) GetLevelsBetweenUpgrades() int32 {
	if m != nil {
		return m.LevelsBetweenUpgrades
	}
	return 0
}

func (m *SkillDatas) GetInitLevel() int32 {
	if m != nil {
		return m.InitLevel
	}
	return 0
}

//buff数据
type BuffDatas struct {
	TypeID               int32    `protobuf:"varint,1,opt,name=TypeID,proto3" json:"TypeID,omitempty"`
	RemainTime           float32  `protobuf:"fixed32,2,opt,name=RemainTime,proto3" json:"RemainTime,omitempty"`
	Time                 float32  `protobuf:"fixed32,3,opt,name=Time,proto3" json:"Time,omitempty"`
	TagNum               int32    `protobuf:"varint,4,opt,name=TagNum,proto3" json:"TagNum,omitempty"`
	ConnectionType       int32    `protobuf:"varint,5,opt,name=ConnectionType,proto3" json:"ConnectionType,omitempty"`
	ConnectionX          float32  `protobuf:"fixed32,6,opt,name=ConnectionX,proto3" json:"ConnectionX,omitempty"`
	ConnectionY          float32  `protobuf:"fixed32,7,opt,name=ConnectionY,proto3" json:"ConnectionY,omitempty"`
	ConnectionZ          float32  `protobuf:"fixed32,8,opt,name=ConnectionZ,proto3" json:"ConnectionZ,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuffDatas) Reset()         { *m = BuffDatas{} }
func (m *BuffDatas) String() string { return proto.CompactTextString(m) }
func (*BuffDatas) ProtoMessage()    {}
func (*BuffDatas) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{39}
}
func (m *BuffDatas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuffDatas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuffDatas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuffDatas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuffDatas.Merge(m, src)
}
func (m *BuffDatas) XXX_Size() int {
	return m.Size()
}
func (m *BuffDatas) XXX_DiscardUnknown() {
	xxx_messageInfo_BuffDatas.DiscardUnknown(m)
}

var xxx_messageInfo_BuffDatas proto.InternalMessageInfo

func (m *BuffDatas) GetTypeID() int32 {
	if m != nil {
		return m.TypeID
	}
	return 0
}

func (m *BuffDatas) GetRemainTime() float32 {
	if m != nil {
		return m.RemainTime
	}
	return 0
}

func (m *BuffDatas) GetTime() float32 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *BuffDatas) GetTagNum() int32 {
	if m != nil {
		return m.TagNum
	}
	return 0
}

func (m *BuffDatas) GetConnectionType() int32 {
	if m != nil {
		return m.ConnectionType
	}
	return 0
}

func (m *BuffDatas) GetConnectionX() float32 {
	if m != nil {
		return m.ConnectionX
	}
	return 0
}

func (m *BuffDatas) GetConnectionY() float32 {
	if m != nil {
		return m.ConnectionY
	}
	return 0
}

func (m *BuffDatas) GetConnectionZ() float32 {
	if m != nil {
		return m.ConnectionZ
	}
	return 0
}

//单位数据
type UnitDatas struct {
	Name                       string        `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	Level                      int32         `protobuf:"varint,2,opt,name=Level,proto3" json:"Level,omitempty"`
	HP                         int32         `protobuf:"varint,3,opt,name=HP,proto3" json:"HP,omitempty"`
	MP                         int32         `protobuf:"varint,4,opt,name=MP,proto3" json:"MP,omitempty"`
	X                          float32       `protobuf:"fixed32,5,opt,name=X,proto3" json:"X,omitempty"`
	Y                          float32       `protobuf:"fixed32,6,opt,name=Y,proto3" json:"Y,omitempty"`
	ID                         int32         `protobuf:"varint,7,opt,name=ID,proto3" json:"ID,omitempty"`
	ModeType                   string        `protobuf:"bytes,8,opt,name=ModeType,proto3" json:"ModeType,omitempty"`
	MaxHP                      int32         `protobuf:"varint,9,opt,name=MaxHP,proto3" json:"MaxHP,omitempty"`
	MaxMP                      int32         `protobuf:"varint,10,opt,name=MaxMP,proto3" json:"MaxMP,omitempty"`
	Experience                 int32         `protobuf:"varint,11,opt,name=Experience,proto3" json:"Experience,omitempty"`
	MaxExperience              int32         `protobuf:"varint,12,opt,name=MaxExperience,proto3" json:"MaxExperience,omitempty"`
	ControlID                  int32         `protobuf:"varint,13,opt,name=ControlID,proto3" json:"ControlID,omitempty"`
	AnimotorState              int32         `protobuf:"varint,14,opt,name=AnimotorState,proto3" json:"AnimotorState,omitempty"`
	AttackTime                 float32       `protobuf:"fixed32,15,opt,name=AttackTime,proto3" json:"AttackTime,omitempty"`
	DirectionX                 float32       `protobuf:"fixed32,16,opt,name=DirectionX,proto3" json:"DirectionX,omitempty"`
	DirectionY                 float32       `protobuf:"fixed32,17,opt,name=DirectionY,proto3" json:"DirectionY,omitempty"`
	UnitType                   int32         `protobuf:"varint,18,opt,name=UnitType,proto3" json:"UnitType,omitempty"`
	AttackAcpabilities         int32         `protobuf:"varint,19,opt,name=AttackAcpabilities,proto3" json:"AttackAcpabilities,omitempty"`
	AttackMode                 int32         `protobuf:"varint,20,opt,name=AttackMode,proto3" json:"AttackMode,omitempty"`
	IsMain                     int32         `protobuf:"varint,21,opt,name=IsMain,proto3" json:"IsMain,omitempty"`
	IsDeath                    int32         `protobuf:"varint,22,opt,name=IsDeath,proto3" json:"IsDeath,omitempty"`
	Invisible                  int32         `protobuf:"varint,23,opt,name=Invisible,proto3" json:"Invisible,omitempty"`
	Camp                       int32         `protobuf:"varint,24,opt,name=Camp,proto3" json:"Camp,omitempty"`
	IsMiss                     bool          `protobuf:"varint,25,opt,name=IsMiss,proto3" json:"IsMiss,omitempty"`
	AnimotorPause              int32         `protobuf:"varint,26,opt,name=AnimotorPause,proto3" json:"AnimotorPause,omitempty"`
	SkillEnable                int32         `protobuf:"varint,27,opt,name=SkillEnable,proto3" json:"SkillEnable,omitempty"`
	ItemEnable                 int32         `protobuf:"varint,28,opt,name=ItemEnable,proto3" json:"ItemEnable,omitempty"`
	Z                          float32       `protobuf:"fixed32,29,opt,name=Z,proto3" json:"Z,omitempty"`
	IsMirrorImage              int32         `protobuf:"varint,30,opt,name=IsMirrorImage,proto3" json:"IsMirrorImage,omitempty"`
	AttackRange                float32       `protobuf:"fixed32,31,opt,name=AttackRange,proto3" json:"AttackRange,omitempty"`
	AttackAnim                 int32         `protobuf:"varint,32,opt,name=AttackAnim,proto3" json:"AttackAnim,omitempty"`
	TypeID                     int32         `protobuf:"varint,33,opt,name=TypeID,proto3" json:"TypeID,omitempty"`
	RemainReviveTime           float32       `protobuf:"fixed32,34,opt,name=RemainReviveTime,proto3" json:"RemainReviveTime,omitempty"`
	TeamID                     int32         `protobuf:"varint,35,opt,name=TeamID,proto3" json:"TeamID,omitempty"`
	Gold                       int32         `protobuf:"varint,36,opt,name=Gold,proto3" json:"Gold,omitempty"`
	Diamond                    int32         `protobuf:"varint,37,opt,name=Diamond,proto3" json:"Diamond,omitempty"`
	ReviveGold                 int32         `protobuf:"varint,38,opt,name=ReviveGold,proto3" json:"ReviveGold,omitempty"`
	ReviveDiamond              int32         `protobuf:"varint,39,opt,name=ReviveDiamond,proto3" json:"ReviveDiamond,omitempty"`
	Characterid                int32         `protobuf:"varint,40,opt,name=Characterid,proto3" json:"Characterid,omitempty"`
	RemainWatchVedioCountToday int32         `protobuf:"varint,41,opt,name=RemainWatchVedioCountToday,proto3" json:"RemainWatchVedioCountToday,omitempty"`
	WatchVedioAddDiamond       int32         `protobuf:"varint,42,opt,name=WatchVedioAddDiamond,proto3" json:"WatchVedioAddDiamond,omitempty"`
	GuildID                    int32         `protobuf:"varint,43,opt,name=GuildID,proto3" json:"GuildID,omitempty"`
	GuildName                  string        `protobuf:"bytes,44,opt,name=GuildName,proto3" json:"GuildName,omitempty"`
	GroupID                    int32         `protobuf:"varint,45,opt,name=GroupID,proto3" json:"GroupID,omitempty"`
	RemainExperience           int32         `protobuf:"varint,46,opt,name=RemainExperience,proto3" json:"RemainExperience,omitempty"`
	BattleRank                 int32         `protobuf:"varint,47,opt,name=BattleRank,proto3" json:"BattleRank,omitempty"`
	SD                         []*SkillDatas `protobuf:"bytes,48,rep,name=SD,proto3" json:"SD,omitempty"`
	BD                         []*BuffDatas  `protobuf:"bytes,49,rep,name=BD,proto3" json:"BD,omitempty"`
	ISD                        []*SkillDatas `protobuf:"bytes,50,rep,name=ISD,proto3" json:"ISD,omitempty"`
	XXX_NoUnkeyedLiteral       struct{}      `json:"-"`
	XXX_unrecognized           []byte        `json:"-"`
	XXX_sizecache              int32         `json:"-"`
}

func (m *UnitDatas) Reset()         { *m = UnitDatas{} }
func (m *UnitDatas) String() string { return proto.CompactTextString(m) }
func (*UnitDatas) ProtoMessage()    {}
func (*UnitDatas) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{40}
}
func (m *UnitDatas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnitDatas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnitDatas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnitDatas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnitDatas.Merge(m, src)
}
func (m *UnitDatas) XXX_Size() int {
	return m.Size()
}
func (m *UnitDatas) XXX_DiscardUnknown() {
	xxx_messageInfo_UnitDatas.DiscardUnknown(m)
}

var xxx_messageInfo_UnitDatas proto.InternalMessageInfo

func (m *UnitDatas) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UnitDatas) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *UnitDatas) GetHP() int32 {
	if m != nil {
		return m.HP
	}
	return 0
}

func (m *UnitDatas) GetMP() int32 {
	if m != nil {
		return m.MP
	}
	return 0
}

func (m *UnitDatas) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *UnitDatas) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *UnitDatas) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UnitDatas) GetModeType() string {
	if m != nil {
		return m.ModeType
	}
	return ""
}

func (m *UnitDatas) GetMaxHP() int32 {
	if m != nil {
		return m.MaxHP
	}
	return 0
}

func (m *UnitDatas) GetMaxMP() int32 {
	if m != nil {
		return m.MaxMP
	}
	return 0
}

func (m *UnitDatas) GetExperience() int32 {
	if m != nil {
		return m.Experience
	}
	return 0
}

func (m *UnitDatas) GetMaxExperience() int32 {
	if m != nil {
		return m.MaxExperience
	}
	return 0
}

func (m *UnitDatas) GetControlID() int32 {
	if m != nil {
		return m.ControlID
	}
	return 0
}

func (m *UnitDatas) GetAnimotorState() int32 {
	if m != nil {
		return m.AnimotorState
	}
	return 0
}

func (m *UnitDatas) GetAttackTime() float32 {
	if m != nil {
		return m.AttackTime
	}
	return 0
}

func (m *UnitDatas) GetDirectionX() float32 {
	if m != nil {
		return m.DirectionX
	}
	return 0
}

func (m *UnitDatas) GetDirectionY() float32 {
	if m != nil {
		return m.DirectionY
	}
	return 0
}

func (m *UnitDatas) GetUnitType() int32 {
	if m != nil {
		return m.UnitType
	}
	return 0
}

func (m *UnitDatas) GetAttackAcpabilities() int32 {
	if m != nil {
		return m.AttackAcpabilities
	}
	return 0
}

func (m *UnitDatas) GetAttackMode() int32 {
	if m != nil {
		return m.AttackMode
	}
	return 0
}

func (m *UnitDatas) GetIsMain() int32 {
	if m != nil {
		return m.IsMain
	}
	return 0
}

func (m *UnitDatas) GetIsDeath() int32 {
	if m != nil {
		return m.IsDeath
	}
	return 0
}

func (m *UnitDatas) GetInvisible() int32 {
	if m != nil {
		return m.Invisible
	}
	return 0
}

func (m *UnitDatas) GetCamp() int32 {
	if m != nil {
		return m.Camp
	}
	return 0
}

func (m *UnitDatas) GetIsMiss() bool {
	if m != nil {
		return m.IsMiss
	}
	return false
}

func (m *UnitDatas) GetAnimotorPause() int32 {
	if m != nil {
		return m.AnimotorPause
	}
	return 0
}

func (m *UnitDatas) GetSkillEnable() int32 {
	if m != nil {
		return m.SkillEnable
	}
	return 0
}

func (m *UnitDatas) GetItemEnable() int32 {
	if m != nil {
		return m.ItemEnable
	}
	return 0
}

func (m *UnitDatas) GetZ() float32 {
	if m != nil {
		return m.Z
	}
	return 0
}

func (m *UnitDatas) GetIsMirrorImage() int32 {
	if m != nil {
		return m.IsMirrorImage
	}
	return 0
}

func (m *UnitDatas) GetAttackRange() float32 {
	if m != nil {
		return m.AttackRange
	}
	return 0
}

func (m *UnitDatas) GetAttackAnim() int32 {
	if m != nil {
		return m.AttackAnim
	}
	return 0
}

func (m *UnitDatas) GetTypeID() int32 {
	if m != nil {
		return m.TypeID
	}
	return 0
}

func (m *UnitDatas) GetRemainReviveTime() float32 {
	if m != nil {
		return m.RemainReviveTime
	}
	return 0
}

func (m *UnitDatas) GetTeamID() int32 {
	if m != nil {
		return m.TeamID
	}
	return 0
}

func (m *UnitDatas) GetGold() int32 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *UnitDatas) GetDiamond() int32 {
	if m != nil {
		return m.Diamond
	}
	return 0
}

func (m *UnitDatas) GetReviveGold() int32 {
	if m != nil {
		return m.ReviveGold
	}
	return 0
}

func (m *UnitDatas) GetReviveDiamond() int32 {
	if m != nil {
		return m.ReviveDiamond
	}
	return 0
}

func (m *UnitDatas) GetCharacterid() int32 {
	if m != nil {
		return m.Characterid
	}
	return 0
}

func (m *UnitDatas) GetRemainWatchVedioCountToday() int32 {
	if m != nil {
		return m.RemainWatchVedioCountToday
	}
	return 0
}

func (m *UnitDatas) GetWatchVedioAddDiamond() int32 {
	if m != nil {
		return m.WatchVedioAddDiamond
	}
	return 0
}

func (m *UnitDatas) GetGuildID() int32 {
	if m != nil {
		return m.GuildID
	}
	return 0
}

func (m *UnitDatas) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *UnitDatas) GetGroupID() int32 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *UnitDatas) GetRemainExperience() int32 {
	if m != nil {
		return m.RemainExperience
	}
	return 0
}

func (m *UnitDatas) GetBattleRank() int32 {
	if m != nil {
		return m.BattleRank
	}
	return 0
}

func (m *UnitDatas) GetSD() []*SkillDatas {
	if m != nil {
		return m.SD
	}
	return nil
}

func (m *UnitDatas) GetBD() []*BuffDatas {
	if m != nil {
		return m.BD
	}
	return nil
}

func (m *UnitDatas) GetISD() []*SkillDatas {
	if m != nil {
		return m.ISD
	}
	return nil
}

type BulletDatas struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	ModeType             string   `protobuf:"bytes,2,opt,name=ModeType,proto3" json:"ModeType,omitempty"`
	X                    float32  `protobuf:"fixed32,3,opt,name=X,proto3" json:"X,omitempty"`
	Y                    float32  `protobuf:"fixed32,4,opt,name=Y,proto3" json:"Y,omitempty"`
	Z                    float32  `protobuf:"fixed32,5,opt,name=Z,proto3" json:"Z,omitempty"`
	State                int32    `protobuf:"varint,6,opt,name=State,proto3" json:"State,omitempty"`
	StartX               float32  `protobuf:"fixed32,7,opt,name=StartX,proto3" json:"StartX,omitempty"`
	StartY               float32  `protobuf:"fixed32,8,opt,name=StartY,proto3" json:"StartY,omitempty"`
	StartZ               float32  `protobuf:"fixed32,9,opt,name=StartZ,proto3" json:"StartZ,omitempty"`
	EndX                 float32  `protobuf:"fixed32,10,opt,name=EndX,proto3" json:"EndX,omitempty"`
	EndY                 float32  `protobuf:"fixed32,11,opt,name=EndY,proto3" json:"EndY,omitempty"`
	EndZ                 float32  `protobuf:"fixed32,12,opt,name=EndZ,proto3" json:"EndZ,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BulletDatas) Reset()         { *m = BulletDatas{} }
func (m *BulletDatas) String() string { return proto.CompactTextString(m) }
func (*BulletDatas) ProtoMessage()    {}
func (*BulletDatas) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{41}
}
func (m *BulletDatas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BulletDatas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BulletDatas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BulletDatas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BulletDatas.Merge(m, src)
}
func (m *BulletDatas) XXX_Size() int {
	return m.Size()
}
func (m *BulletDatas) XXX_DiscardUnknown() {
	xxx_messageInfo_BulletDatas.DiscardUnknown(m)
}

var xxx_messageInfo_BulletDatas proto.InternalMessageInfo

func (m *BulletDatas) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *BulletDatas) GetModeType() string {
	if m != nil {
		return m.ModeType
	}
	return ""
}

func (m *BulletDatas) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *BulletDatas) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *BulletDatas) GetZ() float32 {
	if m != nil {
		return m.Z
	}
	return 0
}

func (m *BulletDatas) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *BulletDatas) GetStartX() float32 {
	if m != nil {
		return m.StartX
	}
	return 0
}

func (m *BulletDatas) GetStartY() float32 {
	if m != nil {
		return m.StartY
	}
	return 0
}

func (m *BulletDatas) GetStartZ() float32 {
	if m != nil {
		return m.StartZ
	}
	return 0
}

func (m *BulletDatas) GetEndX() float32 {
	if m != nil {
		return m.EndX
	}
	return 0
}

func (m *BulletDatas) GetEndY() float32 {
	if m != nil {
		return m.EndY
	}
	return 0
}

func (m *BulletDatas) GetEndZ() float32 {
	if m != nil {
		return m.EndZ
	}
	return 0
}

type SceneItemDatas struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	TypeID               int32    `protobuf:"varint,2,opt,name=TypeID,proto3" json:"TypeID,omitempty"`
	X                    float32  `protobuf:"fixed32,3,opt,name=X,proto3" json:"X,omitempty"`
	Y                    float32  `protobuf:"fixed32,4,opt,name=Y,proto3" json:"Y,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SceneItemDatas) Reset()         { *m = SceneItemDatas{} }
func (m *SceneItemDatas) String() string { return proto.CompactTextString(m) }
func (*SceneItemDatas) ProtoMessage()    {}
func (*SceneItemDatas) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{42}
}
func (m *SceneItemDatas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SceneItemDatas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SceneItemDatas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SceneItemDatas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SceneItemDatas.Merge(m, src)
}
func (m *SceneItemDatas) XXX_Size() int {
	return m.Size()
}
func (m *SceneItemDatas) XXX_DiscardUnknown() {
	xxx_messageInfo_SceneItemDatas.DiscardUnknown(m)
}

var xxx_messageInfo_SceneItemDatas proto.InternalMessageInfo

func (m *SceneItemDatas) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *SceneItemDatas) GetTypeID() int32 {
	if m != nil {
		return m.TypeID
	}
	return 0
}

func (m *SceneItemDatas) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *SceneItemDatas) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

type HaloDatas struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	ModeType             string   `protobuf:"bytes,2,opt,name=ModeType,proto3" json:"ModeType,omitempty"`
	X                    float32  `protobuf:"fixed32,3,opt,name=X,proto3" json:"X,omitempty"`
	Y                    float32  `protobuf:"fixed32,4,opt,name=Y,proto3" json:"Y,omitempty"`
	Z                    float32  `protobuf:"fixed32,5,opt,name=Z,proto3" json:"Z,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HaloDatas) Reset()         { *m = HaloDatas{} }
func (m *HaloDatas) String() string { return proto.CompactTextString(m) }
func (*HaloDatas) ProtoMessage()    {}
func (*HaloDatas) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{43}
}
func (m *HaloDatas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HaloDatas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HaloDatas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HaloDatas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HaloDatas.Merge(m, src)
}
func (m *HaloDatas) XXX_Size() int {
	return m.Size()
}
func (m *HaloDatas) XXX_DiscardUnknown() {
	xxx_messageInfo_HaloDatas.DiscardUnknown(m)
}

var xxx_messageInfo_HaloDatas proto.InternalMessageInfo

func (m *HaloDatas) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *HaloDatas) GetModeType() string {
	if m != nil {
		return m.ModeType
	}
	return ""
}

func (m *HaloDatas) GetX() float32 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *HaloDatas) GetY() float32 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *HaloDatas) GetZ() float32 {
	if m != nil {
		return m.Z
	}
	return 0
}

type MsgUserEnterScene struct {
	Uid                  int32    `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	ConnectId            int32    `protobuf:"varint,2,opt,name=ConnectId,proto3" json:"ConnectId,omitempty"`
	SrcServerName        string   `protobuf:"bytes,3,opt,name=SrcServerName,proto3" json:"SrcServerName,omitempty"`
	DestServerName       string   `protobuf:"bytes,4,opt,name=DestServerName,proto3" json:"DestServerName,omitempty"`
	SceneID              int32    `protobuf:"varint,5,opt,name=SceneID,proto3" json:"SceneID,omitempty"`
	Datas                []byte   `protobuf:"bytes,6,opt,name=Datas,proto3" json:"Datas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MsgUserEnterScene) Reset()         { *m = MsgUserEnterScene{} }
func (m *MsgUserEnterScene) String() string { return proto.CompactTextString(m) }
func (*MsgUserEnterScene) ProtoMessage()    {}
func (*MsgUserEnterScene) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{44}
}
func (m *MsgUserEnterScene) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUserEnterScene) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUserEnterScene.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUserEnterScene) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUserEnterScene.Merge(m, src)
}
func (m *MsgUserEnterScene) XXX_Size() int {
	return m.Size()
}
func (m *MsgUserEnterScene) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUserEnterScene.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUserEnterScene proto.InternalMessageInfo

func (m *MsgUserEnterScene) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *MsgUserEnterScene) GetConnectId() int32 {
	if m != nil {
		return m.ConnectId
	}
	return 0
}

func (m *MsgUserEnterScene) GetSrcServerName() string {
	if m != nil {
		return m.SrcServerName
	}
	return ""
}

func (m *MsgUserEnterScene) GetDestServerName() string {
	if m != nil {
		return m.DestServerName
	}
	return ""
}

func (m *MsgUserEnterScene) GetSceneID() int32 {
	if m != nil {
		return m.SceneID
	}
	return 0
}

func (m *MsgUserEnterScene) GetDatas() []byte {
	if m != nil {
		return m.Datas
	}
	return nil
}

//玩家自己造成的伤害数据
type MsgPlayerHurt struct {
	HurtUnitID           int32    `protobuf:"varint,1,opt,name=HurtUnitID,proto3" json:"HurtUnitID,omitempty"`
	HurtAllValue         int32    `protobuf:"varint,2,opt,name=HurtAllValue,proto3" json:"HurtAllValue,omitempty"`
	HurtMagicValue       int32    `protobuf:"varint,3,opt,name=HurtMagicValue,proto3" json:"HurtMagicValue,omitempty"`
	IsCrit               int32    `protobuf:"varint,4,opt,name=IsCrit,proto3" json:"IsCrit,omitempty"`
	GetGold              int32    `protobuf:"varint,5,opt,name=GetGold,proto3" json:"GetGold,omitempty"`
	GetDiamond           int32    `protobuf:"varint,6,opt,name=GetDiamond,proto3" json:"GetDiamond,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MsgPlayerHurt) Reset()         { *m = MsgPlayerHurt{} }
func (m *MsgPlayerHurt) String() string { return proto.CompactTextString(m) }
func (*MsgPlayerHurt) ProtoMessage()    {}
func (*MsgPlayerHurt) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{45}
}
func (m *MsgPlayerHurt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgPlayerHurt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgPlayerHurt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgPlayerHurt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgPlayerHurt.Merge(m, src)
}
func (m *MsgPlayerHurt) XXX_Size() int {
	return m.Size()
}
func (m *MsgPlayerHurt) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgPlayerHurt.DiscardUnknown(m)
}

var xxx_messageInfo_MsgPlayerHurt proto.InternalMessageInfo

func (m *MsgPlayerHurt) GetHurtUnitID() int32 {
	if m != nil {
		return m.HurtUnitID
	}
	return 0
}

func (m *MsgPlayerHurt) GetHurtAllValue() int32 {
	if m != nil {
		return m.HurtAllValue
	}
	return 0
}

func (m *MsgPlayerHurt) GetHurtMagicValue() int32 {
	if m != nil {
		return m.HurtMagicValue
	}
	return 0
}

func (m *MsgPlayerHurt) GetIsCrit() int32 {
	if m != nil {
		return m.IsCrit
	}
	return 0
}

func (m *MsgPlayerHurt) GetGetGold() int32 {
	if m != nil {
		return m.GetGold
	}
	return 0
}

func (m *MsgPlayerHurt) GetGetDiamond() int32 {
	if m != nil {
		return m.GetDiamond
	}
	return 0
}

//每帧更新单位数据
type SC_Update struct {
	CurFrame             int32             `protobuf:"varint,1,opt,name=CurFrame,proto3" json:"CurFrame,omitempty"`
	NewUnits             []*UnitDatas      `protobuf:"bytes,2,rep,name=NewUnits,proto3" json:"NewUnits,omitempty"`
	OldUnits             []*UnitDatas      `protobuf:"bytes,3,rep,name=OldUnits,proto3" json:"OldUnits,omitempty"`
	RemoveUnits          []int32           `protobuf:"varint,4,rep,packed,name=RemoveUnits,proto3" json:"RemoveUnits,omitempty"`
	NewBullets           []*BulletDatas    `protobuf:"bytes,5,rep,name=NewBullets,proto3" json:"NewBullets,omitempty"`
	OldBullets           []*BulletDatas    `protobuf:"bytes,6,rep,name=OldBullets,proto3" json:"OldBullets,omitempty"`
	RemoveBullets        []int32           `protobuf:"varint,7,rep,packed,name=RemoveBullets,proto3" json:"RemoveBullets,omitempty"`
	NewHalos             []*HaloDatas      `protobuf:"bytes,8,rep,name=NewHalos,proto3" json:"NewHalos,omitempty"`
	OldHalos             []*HaloDatas      `protobuf:"bytes,9,rep,name=OldHalos,proto3" json:"OldHalos,omitempty"`
	RemoveHalos          []int32           `protobuf:"varint,10,rep,packed,name=RemoveHalos,proto3" json:"RemoveHalos,omitempty"`
	NewSceneItems        []*SceneItemDatas `protobuf:"bytes,11,rep,name=NewSceneItems,proto3" json:"NewSceneItems,omitempty"`
	RemoveSceneItems     []int32           `protobuf:"varint,12,rep,packed,name=RemoveSceneItems,proto3" json:"RemoveSceneItems,omitempty"`
	PlayerHurt           []*MsgPlayerHurt  `protobuf:"bytes,13,rep,name=PlayerHurt,proto3" json:"PlayerHurt,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SC_Update) Reset()         { *m = SC_Update{} }
func (m *SC_Update) String() string { return proto.CompactTextString(m) }
func (*SC_Update) ProtoMessage()    {}
func (*SC_Update) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{46}
}
func (m *SC_Update) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_Update) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_Update.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_Update) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_Update.Merge(m, src)
}
func (m *SC_Update) XXX_Size() int {
	return m.Size()
}
func (m *SC_Update) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_Update.DiscardUnknown(m)
}

var xxx_messageInfo_SC_Update proto.InternalMessageInfo

func (m *SC_Update) GetCurFrame() int32 {
	if m != nil {
		return m.CurFrame
	}
	return 0
}

func (m *SC_Update) GetNewUnits() []*UnitDatas {
	if m != nil {
		return m.NewUnits
	}
	return nil
}

func (m *SC_Update) GetOldUnits() []*UnitDatas {
	if m != nil {
		return m.OldUnits
	}
	return nil
}

func (m *SC_Update) GetRemoveUnits() []int32 {
	if m != nil {
		return m.RemoveUnits
	}
	return nil
}

func (m *SC_Update) GetNewBullets() []*BulletDatas {
	if m != nil {
		return m.NewBullets
	}
	return nil
}

func (m *SC_Update) GetOldBullets() []*BulletDatas {
	if m != nil {
		return m.OldBullets
	}
	return nil
}

func (m *SC_Update) GetRemoveBullets() []int32 {
	if m != nil {
		return m.RemoveBullets
	}
	return nil
}

func (m *SC_Update) GetNewHalos() []*HaloDatas {
	if m != nil {
		return m.NewHalos
	}
	return nil
}

func (m *SC_Update) GetOldHalos() []*HaloDatas {
	if m != nil {
		return m.OldHalos
	}
	return nil
}

func (m *SC_Update) GetRemoveHalos() []int32 {
	if m != nil {
		return m.RemoveHalos
	}
	return nil
}

func (m *SC_Update) GetNewSceneItems() []*SceneItemDatas {
	if m != nil {
		return m.NewSceneItems
	}
	return nil
}

func (m *SC_Update) GetRemoveSceneItems() []int32 {
	if m != nil {
		return m.RemoveSceneItems
	}
	return nil
}

func (m *SC_Update) GetPlayerHurt() []*MsgPlayerHurt {
	if m != nil {
		return m.PlayerHurt
	}
	return nil
}

//玩家进入新场景时的场景信息
type SC_NewScene struct {
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	LogicFps             int32    `protobuf:"varint,2,opt,name=LogicFps,proto3" json:"LogicFps,omitempty"`
	CurFrame             int32    `protobuf:"varint,3,opt,name=CurFrame,proto3" json:"CurFrame,omitempty"`
	ServerName           string   `protobuf:"bytes,4,opt,name=ServerName,proto3" json:"ServerName,omitempty"`
	SceneID              int32    `protobuf:"varint,5,opt,name=SceneID,proto3" json:"SceneID,omitempty"`
	TimeHour             int32    `protobuf:"varint,6,opt,name=TimeHour,proto3" json:"TimeHour,omitempty"`
	TimeMinute           int32    `protobuf:"varint,7,opt,name=TimeMinute,proto3" json:"TimeMinute,omitempty"`
	TimeSecond           int32    `protobuf:"varint,8,opt,name=TimeSecond,proto3" json:"TimeSecond,omitempty"`
	DataShowType         int32    `protobuf:"varint,9,opt,name=DataShowType,proto3" json:"DataShowType,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SC_NewScene) Reset()         { *m = SC_NewScene{} }
func (m *SC_NewScene) String() string { return proto.CompactTextString(m) }
func (*SC_NewScene) ProtoMessage()    {}
func (*SC_NewScene) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{47}
}
func (m *SC_NewScene) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_NewScene) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_NewScene.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_NewScene) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_NewScene.Merge(m, src)
}
func (m *SC_NewScene) XXX_Size() int {
	return m.Size()
}
func (m *SC_NewScene) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_NewScene.DiscardUnknown(m)
}

var xxx_messageInfo_SC_NewScene proto.InternalMessageInfo

func (m *SC_NewScene) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *SC_NewScene) GetLogicFps() int32 {
	if m != nil {
		return m.LogicFps
	}
	return 0
}

func (m *SC_NewScene) GetCurFrame() int32 {
	if m != nil {
		return m.CurFrame
	}
	return 0
}

func (m *SC_NewScene) GetServerName() string {
	if m != nil {
		return m.ServerName
	}
	return ""
}

func (m *SC_NewScene) GetSceneID() int32 {
	if m != nil {
		return m.SceneID
	}
	return 0
}

func (m *SC_NewScene) GetTimeHour() int32 {
	if m != nil {
		return m.TimeHour
	}
	return 0
}

func (m *SC_NewScene) GetTimeMinute() int32 {
	if m != nil {
		return m.TimeMinute
	}
	return 0
}

func (m *SC_NewScene) GetTimeSecond() int32 {
	if m != nil {
		return m.TimeSecond
	}
	return 0
}

func (m *SC_NewScene) GetDataShowType() int32 {
	if m != nil {
		return m.DataShowType
	}
	return 0
}

//单位数据
type CharacterBaseDatas struct {
	Characterid          int32    `protobuf:"varint,1,opt,name=Characterid,proto3" json:"Characterid,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Typeid               int32    `protobuf:"varint,3,opt,name=Typeid,proto3" json:"Typeid,omitempty"`
	Level                int32    `protobuf:"varint,4,opt,name=Level,proto3" json:"Level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CharacterBaseDatas) Reset()         { *m = CharacterBaseDatas{} }
func (m *CharacterBaseDatas) String() string { return proto.CompactTextString(m) }
func (*CharacterBaseDatas) ProtoMessage()    {}
func (*CharacterBaseDatas) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{48}
}
func (m *CharacterBaseDatas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CharacterBaseDatas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CharacterBaseDatas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CharacterBaseDatas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CharacterBaseDatas.Merge(m, src)
}
func (m *CharacterBaseDatas) XXX_Size() int {
	return m.Size()
}
func (m *CharacterBaseDatas) XXX_DiscardUnknown() {
	xxx_messageInfo_CharacterBaseDatas.DiscardUnknown(m)
}

var xxx_messageInfo_CharacterBaseDatas proto.InternalMessageInfo

func (m *CharacterBaseDatas) GetCharacterid() int32 {
	if m != nil {
		return m.Characterid
	}
	return 0
}

func (m *CharacterBaseDatas) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CharacterBaseDatas) GetTypeid() int32 {
	if m != nil {
		return m.Typeid
	}
	return 0
}

func (m *CharacterBaseDatas) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

type SC_Logined struct {
	Code                 int32                 `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Uid                  int32                 `protobuf:"varint,2,opt,name=Uid,proto3" json:"Uid,omitempty"`
	Error                string                `protobuf:"bytes,3,opt,name=Error,proto3" json:"Error,omitempty"`
	Characters           []*CharacterBaseDatas `protobuf:"bytes,4,rep,name=Characters,proto3" json:"Characters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *SC_Logined) Reset()         { *m = SC_Logined{} }
func (m *SC_Logined) String() string { return proto.CompactTextString(m) }
func (*SC_Logined) ProtoMessage()    {}
func (*SC_Logined) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{49}
}
func (m *SC_Logined) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_Logined) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_Logined.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_Logined) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_Logined.Merge(m, src)
}
func (m *SC_Logined) XXX_Size() int {
	return m.Size()
}
func (m *SC_Logined) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_Logined.DiscardUnknown(m)
}

var xxx_messageInfo_SC_Logined proto.InternalMessageInfo

func (m *SC_Logined) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SC_Logined) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *SC_Logined) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *SC_Logined) GetCharacters() []*CharacterBaseDatas {
	if m != nil {
		return m.Characters
	}
	return nil
}

//选择角色结果()
type SC_SelectCharacterResult struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	Characterid          int32    `protobuf:"varint,2,opt,name=Characterid,proto3" json:"Characterid,omitempty"`
	Error                int32    `protobuf:"varint,3,opt,name=Error,proto3" json:"Error,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SC_SelectCharacterResult) Reset()         { *m = SC_SelectCharacterResult{} }
func (m *SC_SelectCharacterResult) String() string { return proto.CompactTextString(m) }
func (*SC_SelectCharacterResult) ProtoMessage()    {}
func (*SC_SelectCharacterResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{50}
}
func (m *SC_SelectCharacterResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_SelectCharacterResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_SelectCharacterResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_SelectCharacterResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_SelectCharacterResult.Merge(m, src)
}
func (m *SC_SelectCharacterResult) XXX_Size() int {
	return m.Size()
}
func (m *SC_SelectCharacterResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_SelectCharacterResult.DiscardUnknown(m)
}

var xxx_messageInfo_SC_SelectCharacterResult proto.InternalMessageInfo

func (m *SC_SelectCharacterResult) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

func (m *SC_SelectCharacterResult) GetCharacterid() int32 {
	if m != nil {
		return m.Characterid
	}
	return 0
}

func (m *SC_SelectCharacterResult) GetError() int32 {
	if m != nil {
		return m.Error
	}
	return 0
}

//商品数据
type CommodityDataProto struct {
	TypeID               int32    `protobuf:"varint,1,opt,name=TypeID,proto3" json:"TypeID,omitempty"`
	ItemID               int32    `protobuf:"varint,2,opt,name=ItemID,proto3" json:"ItemID,omitempty"`
	PriceType            int32    `protobuf:"varint,3,opt,name=PriceType,proto3" json:"PriceType,omitempty"`
	Price                int32    `protobuf:"varint,4,opt,name=Price,proto3" json:"Price,omitempty"`
	Level                int32    `protobuf:"varint,5,opt,name=Level,proto3" json:"Level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommodityDataProto) Reset()         { *m = CommodityDataProto{} }
func (m *CommodityDataProto) String() string { return proto.CompactTextString(m) }
func (*CommodityDataProto) ProtoMessage()    {}
func (*CommodityDataProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{51}
}
func (m *CommodityDataProto) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommodityDataProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommodityDataProto.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommodityDataProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommodityDataProto.Merge(m, src)
}
func (m *CommodityDataProto) XXX_Size() int {
	return m.Size()
}
func (m *CommodityDataProto) XXX_DiscardUnknown() {
	xxx_messageInfo_CommodityDataProto.DiscardUnknown(m)
}

var xxx_messageInfo_CommodityDataProto proto.InternalMessageInfo

func (m *CommodityDataProto) GetTypeID() int32 {
	if m != nil {
		return m.TypeID
	}
	return 0
}

func (m *CommodityDataProto) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

func (m *CommodityDataProto) GetPriceType() int32 {
	if m != nil {
		return m.PriceType
	}
	return 0
}

func (m *CommodityDataProto) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *CommodityDataProto) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

//获取商店数据
type CS_GetStoreData struct {
	Test                 int32    `protobuf:"varint,1,opt,name=Test,proto3" json:"Test,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetStoreData) Reset()         { *m = CS_GetStoreData{} }
func (m *CS_GetStoreData) String() string { return proto.CompactTextString(m) }
func (*CS_GetStoreData) ProtoMessage()    {}
func (*CS_GetStoreData) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{52}
}
func (m *CS_GetStoreData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetStoreData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetStoreData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetStoreData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetStoreData.Merge(m, src)
}
func (m *CS_GetStoreData) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetStoreData) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetStoreData.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetStoreData proto.InternalMessageInfo

func (m *CS_GetStoreData) GetTest() int32 {
	if m != nil {
		return m.Test
	}
	return 0
}

//返回商品数据
type SC_StoreData struct {
	Commoditys           []*CommodityDataProto `protobuf:"bytes,1,rep,name=Commoditys,proto3" json:"Commoditys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *SC_StoreData) Reset()         { *m = SC_StoreData{} }
func (m *SC_StoreData) String() string { return proto.CompactTextString(m) }
func (*SC_StoreData) ProtoMessage()    {}
func (*SC_StoreData) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{53}
}
func (m *SC_StoreData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_StoreData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_StoreData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_StoreData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_StoreData.Merge(m, src)
}
func (m *SC_StoreData) XXX_Size() int {
	return m.Size()
}
func (m *SC_StoreData) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_StoreData.DiscardUnknown(m)
}

var xxx_messageInfo_SC_StoreData proto.InternalMessageInfo

func (m *SC_StoreData) GetCommoditys() []*CommodityDataProto {
	if m != nil {
		return m.Commoditys
	}
	return nil
}

//购买商品
type CS_BuyCommodity struct {
	TypeID               int32    `protobuf:"varint,1,opt,name=TypeID,proto3" json:"TypeID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_BuyCommodity) Reset()         { *m = CS_BuyCommodity{} }
func (m *CS_BuyCommodity) String() string { return proto.CompactTextString(m) }
func (*CS_BuyCommodity) ProtoMessage()    {}
func (*CS_BuyCommodity) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{54}
}
func (m *CS_BuyCommodity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_BuyCommodity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_BuyCommodity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_BuyCommodity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_BuyCommodity.Merge(m, src)
}
func (m *CS_BuyCommodity) XXX_Size() int {
	return m.Size()
}
func (m *CS_BuyCommodity) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_BuyCommodity.DiscardUnknown(m)
}

var xxx_messageInfo_CS_BuyCommodity proto.InternalMessageInfo

func (m *CS_BuyCommodity) GetTypeID() int32 {
	if m != nil {
		return m.TypeID
	}
	return 0
}

//立即复活
type CS_QuickRevive struct {
	ReviveType           int32    `protobuf:"varint,1,opt,name=ReviveType,proto3" json:"ReviveType,omitempty"`
	LookVideoState       int32    `protobuf:"varint,2,opt,name=LookVideoState,proto3" json:"LookVideoState,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_QuickRevive) Reset()         { *m = CS_QuickRevive{} }
func (m *CS_QuickRevive) String() string { return proto.CompactTextString(m) }
func (*CS_QuickRevive) ProtoMessage()    {}
func (*CS_QuickRevive) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{55}
}
func (m *CS_QuickRevive) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_QuickRevive) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_QuickRevive.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_QuickRevive) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_QuickRevive.Merge(m, src)
}
func (m *CS_QuickRevive) XXX_Size() int {
	return m.Size()
}
func (m *CS_QuickRevive) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_QuickRevive.DiscardUnknown(m)
}

var xxx_messageInfo_CS_QuickRevive proto.InternalMessageInfo

func (m *CS_QuickRevive) GetReviveType() int32 {
	if m != nil {
		return m.ReviveType
	}
	return 0
}

func (m *CS_QuickRevive) GetLookVideoState() int32 {
	if m != nil {
		return m.LookVideoState
	}
	return 0
}

//掉线 客户端自己发给自己的消息
type CC_Disconnect struct {
	Err                  string   `protobuf:"bytes,1,opt,name=Err,proto3" json:"Err,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CC_Disconnect) Reset()         { *m = CC_Disconnect{} }
func (m *CC_Disconnect) String() string { return proto.CompactTextString(m) }
func (*CC_Disconnect) ProtoMessage()    {}
func (*CC_Disconnect) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{56}
}
func (m *CC_Disconnect) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CC_Disconnect) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CC_Disconnect.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CC_Disconnect) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CC_Disconnect.Merge(m, src)
}
func (m *CC_Disconnect) XXX_Size() int {
	return m.Size()
}
func (m *CC_Disconnect) XXX_DiscardUnknown() {
	xxx_messageInfo_CC_Disconnect.DiscardUnknown(m)
}

var xxx_messageInfo_CC_Disconnect proto.InternalMessageInfo

func (m *CC_Disconnect) GetErr() string {
	if m != nil {
		return m.Err
	}
	return ""
}

//聊天信息
type SC_ChatInfo struct {
	Channel              int32    `protobuf:"varint,1,opt,name=Channel,proto3" json:"Channel,omitempty"`
	Time                 string   `protobuf:"bytes,2,opt,name=Time,proto3" json:"Time,omitempty"`
	SrcName              string   `protobuf:"bytes,3,opt,name=SrcName,proto3" json:"SrcName,omitempty"`
	SrcPlayerUID         int32    `protobuf:"varint,4,opt,name=SrcPlayerUID,proto3" json:"SrcPlayerUID,omitempty"`
	SrcCharacterID       int32    `protobuf:"varint,5,opt,name=SrcCharacterID,proto3" json:"SrcCharacterID,omitempty"`
	DestPlayerUID        int32    `protobuf:"varint,6,opt,name=DestPlayerUID,proto3" json:"DestPlayerUID,omitempty"`
	Content              string   `protobuf:"bytes,7,opt,name=Content,proto3" json:"Content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SC_ChatInfo) Reset()         { *m = SC_ChatInfo{} }
func (m *SC_ChatInfo) String() string { return proto.CompactTextString(m) }
func (*SC_ChatInfo) ProtoMessage()    {}
func (*SC_ChatInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{57}
}
func (m *SC_ChatInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_ChatInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_ChatInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_ChatInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_ChatInfo.Merge(m, src)
}
func (m *SC_ChatInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_ChatInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_ChatInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_ChatInfo proto.InternalMessageInfo

func (m *SC_ChatInfo) GetChannel() int32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

func (m *SC_ChatInfo) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *SC_ChatInfo) GetSrcName() string {
	if m != nil {
		return m.SrcName
	}
	return ""
}

func (m *SC_ChatInfo) GetSrcPlayerUID() int32 {
	if m != nil {
		return m.SrcPlayerUID
	}
	return 0
}

func (m *SC_ChatInfo) GetSrcCharacterID() int32 {
	if m != nil {
		return m.SrcCharacterID
	}
	return 0
}

func (m *SC_ChatInfo) GetDestPlayerUID() int32 {
	if m != nil {
		return m.DestPlayerUID
	}
	return 0
}

func (m *SC_ChatInfo) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

//发送聊天信息
type CS_ChatInfo struct {
	Channel              int32    `protobuf:"varint,1,opt,name=Channel,proto3" json:"Channel,omitempty"`
	DestPlayerUID        int32    `protobuf:"varint,5,opt,name=DestPlayerUID,proto3" json:"DestPlayerUID,omitempty"`
	Content              string   `protobuf:"bytes,6,opt,name=Content,proto3" json:"Content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_ChatInfo) Reset()         { *m = CS_ChatInfo{} }
func (m *CS_ChatInfo) String() string { return proto.CompactTextString(m) }
func (*CS_ChatInfo) ProtoMessage()    {}
func (*CS_ChatInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{58}
}
func (m *CS_ChatInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_ChatInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_ChatInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_ChatInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_ChatInfo.Merge(m, src)
}
func (m *CS_ChatInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_ChatInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_ChatInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_ChatInfo proto.InternalMessageInfo

func (m *CS_ChatInfo) GetChannel() int32 {
	if m != nil {
		return m.Channel
	}
	return 0
}

func (m *CS_ChatInfo) GetDestPlayerUID() int32 {
	if m != nil {
		return m.DestPlayerUID
	}
	return 0
}

func (m *CS_ChatInfo) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

//添加好友
type CS_AddFriendRequest struct {
	Uid                  int32    `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	Characterid          int32    `protobuf:"varint,2,opt,name=Characterid,proto3" json:"Characterid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_AddFriendRequest) Reset()         { *m = CS_AddFriendRequest{} }
func (m *CS_AddFriendRequest) String() string { return proto.CompactTextString(m) }
func (*CS_AddFriendRequest) ProtoMessage()    {}
func (*CS_AddFriendRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{59}
}
func (m *CS_AddFriendRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_AddFriendRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_AddFriendRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_AddFriendRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_AddFriendRequest.Merge(m, src)
}
func (m *CS_AddFriendRequest) XXX_Size() int {
	return m.Size()
}
func (m *CS_AddFriendRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_AddFriendRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CS_AddFriendRequest proto.InternalMessageInfo

func (m *CS_AddFriendRequest) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *CS_AddFriendRequest) GetCharacterid() int32 {
	if m != nil {
		return m.Characterid
	}
	return 0
}

//删除好友
type CS_RemoveFriend struct {
	Uid                  int32    `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	Characterid          int32    `protobuf:"varint,2,opt,name=Characterid,proto3" json:"Characterid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_RemoveFriend) Reset()         { *m = CS_RemoveFriend{} }
func (m *CS_RemoveFriend) String() string { return proto.CompactTextString(m) }
func (*CS_RemoveFriend) ProtoMessage()    {}
func (*CS_RemoveFriend) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{60}
}
func (m *CS_RemoveFriend) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_RemoveFriend) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_RemoveFriend.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_RemoveFriend) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_RemoveFriend.Merge(m, src)
}
func (m *CS_RemoveFriend) XXX_Size() int {
	return m.Size()
}
func (m *CS_RemoveFriend) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_RemoveFriend.DiscardUnknown(m)
}

var xxx_messageInfo_CS_RemoveFriend proto.InternalMessageInfo

func (m *CS_RemoveFriend) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *CS_RemoveFriend) GetCharacterid() int32 {
	if m != nil {
		return m.Characterid
	}
	return 0
}

//回复好友请求
type CS_AddFriendResponse struct {
	FriendInfo           *FriendInfoMsg `protobuf:"bytes,1,opt,name=FriendInfo,proto3" json:"FriendInfo,omitempty"`
	Result               int32          `protobuf:"varint,2,opt,name=Result,proto3" json:"Result,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CS_AddFriendResponse) Reset()         { *m = CS_AddFriendResponse{} }
func (m *CS_AddFriendResponse) String() string { return proto.CompactTextString(m) }
func (*CS_AddFriendResponse) ProtoMessage()    {}
func (*CS_AddFriendResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{61}
}
func (m *CS_AddFriendResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_AddFriendResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_AddFriendResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_AddFriendResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_AddFriendResponse.Merge(m, src)
}
func (m *CS_AddFriendResponse) XXX_Size() int {
	return m.Size()
}
func (m *CS_AddFriendResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_AddFriendResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CS_AddFriendResponse proto.InternalMessageInfo

func (m *CS_AddFriendResponse) GetFriendInfo() *FriendInfoMsg {
	if m != nil {
		return m.FriendInfo
	}
	return nil
}

func (m *CS_AddFriendResponse) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

//好友信息
type FriendInfoMsg struct {
	Uid                  int32    `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	Characterid          int32    `protobuf:"varint,2,opt,name=Characterid,proto3" json:"Characterid,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Level                int32    `protobuf:"varint,4,opt,name=Level,proto3" json:"Level,omitempty"`
	Typeid               int32    `protobuf:"varint,5,opt,name=Typeid,proto3" json:"Typeid,omitempty"`
	State                int32    `protobuf:"varint,6,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FriendInfoMsg) Reset()         { *m = FriendInfoMsg{} }
func (m *FriendInfoMsg) String() string { return proto.CompactTextString(m) }
func (*FriendInfoMsg) ProtoMessage()    {}
func (*FriendInfoMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{62}
}
func (m *FriendInfoMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FriendInfoMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FriendInfoMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FriendInfoMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FriendInfoMsg.Merge(m, src)
}
func (m *FriendInfoMsg) XXX_Size() int {
	return m.Size()
}
func (m *FriendInfoMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_FriendInfoMsg.DiscardUnknown(m)
}

var xxx_messageInfo_FriendInfoMsg proto.InternalMessageInfo

func (m *FriendInfoMsg) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *FriendInfoMsg) GetCharacterid() int32 {
	if m != nil {
		return m.Characterid
	}
	return 0
}

func (m *FriendInfoMsg) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FriendInfoMsg) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *FriendInfoMsg) GetTypeid() int32 {
	if m != nil {
		return m.Typeid
	}
	return 0
}

func (m *FriendInfoMsg) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

//获取好友列表
type CS_GetFriendsList struct {
	Uid                  int32    `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetFriendsList) Reset()         { *m = CS_GetFriendsList{} }
func (m *CS_GetFriendsList) String() string { return proto.CompactTextString(m) }
func (*CS_GetFriendsList) ProtoMessage()    {}
func (*CS_GetFriendsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{63}
}
func (m *CS_GetFriendsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetFriendsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetFriendsList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetFriendsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetFriendsList.Merge(m, src)
}
func (m *CS_GetFriendsList) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetFriendsList) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetFriendsList.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetFriendsList proto.InternalMessageInfo

func (m *CS_GetFriendsList) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

//获取好友列表
type SC_GetFriendsList struct {
	Friends              []*FriendInfoMsg `protobuf:"bytes,1,rep,name=Friends,proto3" json:"Friends,omitempty"`
	FriendsRequest       []*FriendInfoMsg `protobuf:"bytes,2,rep,name=FriendsRequest,proto3" json:"FriendsRequest,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SC_GetFriendsList) Reset()         { *m = SC_GetFriendsList{} }
func (m *SC_GetFriendsList) String() string { return proto.CompactTextString(m) }
func (*SC_GetFriendsList) ProtoMessage()    {}
func (*SC_GetFriendsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{64}
}
func (m *SC_GetFriendsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetFriendsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetFriendsList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetFriendsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetFriendsList.Merge(m, src)
}
func (m *SC_GetFriendsList) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetFriendsList) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetFriendsList.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetFriendsList proto.InternalMessageInfo

func (m *SC_GetFriendsList) GetFriends() []*FriendInfoMsg {
	if m != nil {
		return m.Friends
	}
	return nil
}

func (m *SC_GetFriendsList) GetFriendsRequest() []*FriendInfoMsg {
	if m != nil {
		return m.FriendsRequest
	}
	return nil
}

//邮件系统相关
//邮件简短信息
type MailShortInfoMsg struct {
	Id                   int32    `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	SendName             string   `protobuf:"bytes,2,opt,name=SendName,proto3" json:"SendName,omitempty"`
	Title                string   `protobuf:"bytes,3,opt,name=Title,proto3" json:"Title,omitempty"`
	Date                 string   `protobuf:"bytes,4,opt,name=Date,proto3" json:"Date,omitempty"`
	State                int32    `protobuf:"varint,5,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MailShortInfoMsg) Reset()         { *m = MailShortInfoMsg{} }
func (m *MailShortInfoMsg) String() string { return proto.CompactTextString(m) }
func (*MailShortInfoMsg) ProtoMessage()    {}
func (*MailShortInfoMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{65}
}
func (m *MailShortInfoMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MailShortInfoMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MailShortInfoMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MailShortInfoMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MailShortInfoMsg.Merge(m, src)
}
func (m *MailShortInfoMsg) XXX_Size() int {
	return m.Size()
}
func (m *MailShortInfoMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_MailShortInfoMsg.DiscardUnknown(m)
}

var xxx_messageInfo_MailShortInfoMsg proto.InternalMessageInfo

func (m *MailShortInfoMsg) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *MailShortInfoMsg) GetSendName() string {
	if m != nil {
		return m.SendName
	}
	return ""
}

func (m *MailShortInfoMsg) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *MailShortInfoMsg) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

func (m *MailShortInfoMsg) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

//邮件奖励 ItemType:10000表示金币 10001表示砖石  其他表示道具ID
type MailRewards struct {
	ItemType             int32    `protobuf:"varint,1,opt,name=ItemType,proto3" json:"ItemType,omitempty"`
	Count                int32    `protobuf:"varint,2,opt,name=Count,proto3" json:"Count,omitempty"`
	Level                int32    `protobuf:"varint,3,opt,name=Level,proto3" json:"Level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MailRewards) Reset()         { *m = MailRewards{} }
func (m *MailRewards) String() string { return proto.CompactTextString(m) }
func (*MailRewards) ProtoMessage()    {}
func (*MailRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{66}
}
func (m *MailRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MailRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MailRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MailRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MailRewards.Merge(m, src)
}
func (m *MailRewards) XXX_Size() int {
	return m.Size()
}
func (m *MailRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_MailRewards.DiscardUnknown(m)
}

var xxx_messageInfo_MailRewards proto.InternalMessageInfo

func (m *MailRewards) GetItemType() int32 {
	if m != nil {
		return m.ItemType
	}
	return 0
}

func (m *MailRewards) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *MailRewards) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

//获取邮件列表
type CS_GetMailsList struct {
	Uid                  int32    `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetMailsList) Reset()         { *m = CS_GetMailsList{} }
func (m *CS_GetMailsList) String() string { return proto.CompactTextString(m) }
func (*CS_GetMailsList) ProtoMessage()    {}
func (*CS_GetMailsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{67}
}
func (m *CS_GetMailsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetMailsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetMailsList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetMailsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetMailsList.Merge(m, src)
}
func (m *CS_GetMailsList) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetMailsList) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetMailsList.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetMailsList proto.InternalMessageInfo

func (m *CS_GetMailsList) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

//获取邮件列表
type SC_GetMailsList struct {
	Mails                []*MailShortInfoMsg `protobuf:"bytes,1,rep,name=Mails,proto3" json:"Mails,omitempty"`
	MailUpperLimit       int32               `protobuf:"varint,2,opt,name=MailUpperLimit,proto3" json:"MailUpperLimit,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *SC_GetMailsList) Reset()         { *m = SC_GetMailsList{} }
func (m *SC_GetMailsList) String() string { return proto.CompactTextString(m) }
func (*SC_GetMailsList) ProtoMessage()    {}
func (*SC_GetMailsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{68}
}
func (m *SC_GetMailsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetMailsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetMailsList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetMailsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetMailsList.Merge(m, src)
}
func (m *SC_GetMailsList) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetMailsList) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetMailsList.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetMailsList proto.InternalMessageInfo

func (m *SC_GetMailsList) GetMails() []*MailShortInfoMsg {
	if m != nil {
		return m.Mails
	}
	return nil
}

func (m *SC_GetMailsList) GetMailUpperLimit() int32 {
	if m != nil {
		return m.MailUpperLimit
	}
	return 0
}

//获取具体邮件信息
type CS_GetMailInfo struct {
	Id                   int32    `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetMailInfo) Reset()         { *m = CS_GetMailInfo{} }
func (m *CS_GetMailInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetMailInfo) ProtoMessage()    {}
func (*CS_GetMailInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{69}
}
func (m *CS_GetMailInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetMailInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetMailInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetMailInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetMailInfo.Merge(m, src)
}
func (m *CS_GetMailInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetMailInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetMailInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetMailInfo proto.InternalMessageInfo

func (m *CS_GetMailInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

//获取邮件列表
type SC_GetMailInfo struct {
	Id                   int32          `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	SendName             string         `protobuf:"bytes,2,opt,name=SendName,proto3" json:"SendName,omitempty"`
	Title                string         `protobuf:"bytes,3,opt,name=Title,proto3" json:"Title,omitempty"`
	Content              string         `protobuf:"bytes,4,opt,name=Content,proto3" json:"Content,omitempty"`
	Date                 string         `protobuf:"bytes,5,opt,name=Date,proto3" json:"Date,omitempty"`
	Rewards              []*MailRewards `protobuf:"bytes,6,rep,name=Rewards,proto3" json:"Rewards,omitempty"`
	State                int32          `protobuf:"varint,7,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SC_GetMailInfo) Reset()         { *m = SC_GetMailInfo{} }
func (m *SC_GetMailInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetMailInfo) ProtoMessage()    {}
func (*SC_GetMailInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{70}
}
func (m *SC_GetMailInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetMailInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetMailInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetMailInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetMailInfo.Merge(m, src)
}
func (m *SC_GetMailInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetMailInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetMailInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetMailInfo proto.InternalMessageInfo

func (m *SC_GetMailInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SC_GetMailInfo) GetSendName() string {
	if m != nil {
		return m.SendName
	}
	return ""
}

func (m *SC_GetMailInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *SC_GetMailInfo) GetContent() string {
	if m != nil {
		return m.Content
	}
	return ""
}

func (m *SC_GetMailInfo) GetDate() string {
	if m != nil {
		return m.Date
	}
	return ""
}

func (m *SC_GetMailInfo) GetRewards() []*MailRewards {
	if m != nil {
		return m.Rewards
	}
	return nil
}

func (m *SC_GetMailInfo) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

//领取邮件奖励
type CS_GetMailRewards struct {
	Id                   int32    `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetMailRewards) Reset()         { *m = CS_GetMailRewards{} }
func (m *CS_GetMailRewards) String() string { return proto.CompactTextString(m) }
func (*CS_GetMailRewards) ProtoMessage()    {}
func (*CS_GetMailRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{71}
}
func (m *CS_GetMailRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetMailRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetMailRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetMailRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetMailRewards.Merge(m, src)
}
func (m *CS_GetMailRewards) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetMailRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetMailRewards.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetMailRewards proto.InternalMessageInfo

func (m *CS_GetMailRewards) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

//领取邮件奖励
type SC_GetMailRewards struct {
	Id                   int32    `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	Result               int32    `protobuf:"varint,2,opt,name=Result,proto3" json:"Result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SC_GetMailRewards) Reset()         { *m = SC_GetMailRewards{} }
func (m *SC_GetMailRewards) String() string { return proto.CompactTextString(m) }
func (*SC_GetMailRewards) ProtoMessage()    {}
func (*SC_GetMailRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{72}
}
func (m *SC_GetMailRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetMailRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetMailRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetMailRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetMailRewards.Merge(m, src)
}
func (m *SC_GetMailRewards) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetMailRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetMailRewards.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetMailRewards proto.InternalMessageInfo

func (m *SC_GetMailRewards) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *SC_GetMailRewards) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

//删除已经领取附件的邮件(没有附件)
type CS_DeleteNoRewardMails struct {
	Id                   int32    `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_DeleteNoRewardMails) Reset()         { *m = CS_DeleteNoRewardMails{} }
func (m *CS_DeleteNoRewardMails) String() string { return proto.CompactTextString(m) }
func (*CS_DeleteNoRewardMails) ProtoMessage()    {}
func (*CS_DeleteNoRewardMails) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{73}
}
func (m *CS_DeleteNoRewardMails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_DeleteNoRewardMails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_DeleteNoRewardMails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_DeleteNoRewardMails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_DeleteNoRewardMails.Merge(m, src)
}
func (m *CS_DeleteNoRewardMails) XXX_Size() int {
	return m.Size()
}
func (m *CS_DeleteNoRewardMails) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_DeleteNoRewardMails.DiscardUnknown(m)
}

var xxx_messageInfo_CS_DeleteNoRewardMails proto.InternalMessageInfo

func (m *CS_DeleteNoRewardMails) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

//交易所相关
//获取正在售卖的道具
type CS_GetExchangeShortCommoditys struct {
	Id                   int32    `protobuf:"varint,1,opt,name=Id,proto3" json:"Id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetExchangeShortCommoditys) Reset()         { *m = CS_GetExchangeShortCommoditys{} }
func (m *CS_GetExchangeShortCommoditys) String() string { return proto.CompactTextString(m) }
func (*CS_GetExchangeShortCommoditys) ProtoMessage()    {}
func (*CS_GetExchangeShortCommoditys) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{74}
}
func (m *CS_GetExchangeShortCommoditys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetExchangeShortCommoditys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetExchangeShortCommoditys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetExchangeShortCommoditys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetExchangeShortCommoditys.Merge(m, src)
}
func (m *CS_GetExchangeShortCommoditys) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetExchangeShortCommoditys) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetExchangeShortCommoditys.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetExchangeShortCommoditys proto.InternalMessageInfo

func (m *CS_GetExchangeShortCommoditys) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

//正在售卖的道具数据
type ExchangeShortCommodityData struct {
	ItemID               int32    `protobuf:"varint,1,opt,name=ItemID,proto3" json:"ItemID,omitempty"`
	SellCount            int32    `protobuf:"varint,2,opt,name=SellCount,proto3" json:"SellCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExchangeShortCommodityData) Reset()         { *m = ExchangeShortCommodityData{} }
func (m *ExchangeShortCommodityData) String() string { return proto.CompactTextString(m) }
func (*ExchangeShortCommodityData) ProtoMessage()    {}
func (*ExchangeShortCommodityData) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{75}
}
func (m *ExchangeShortCommodityData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeShortCommodityData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeShortCommodityData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeShortCommodityData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeShortCommodityData.Merge(m, src)
}
func (m *ExchangeShortCommodityData) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeShortCommodityData) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeShortCommodityData.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeShortCommodityData proto.InternalMessageInfo

func (m *ExchangeShortCommodityData) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

func (m *ExchangeShortCommodityData) GetSellCount() int32 {
	if m != nil {
		return m.SellCount
	}
	return 0
}

//返回正在售卖的相同种类道具数据
type SC_GetExchangeShortCommoditys struct {
	Commoditys           []*ExchangeShortCommodityData `protobuf:"bytes,1,rep,name=Commoditys,proto3" json:"Commoditys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *SC_GetExchangeShortCommoditys) Reset()         { *m = SC_GetExchangeShortCommoditys{} }
func (m *SC_GetExchangeShortCommoditys) String() string { return proto.CompactTextString(m) }
func (*SC_GetExchangeShortCommoditys) ProtoMessage()    {}
func (*SC_GetExchangeShortCommoditys) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{76}
}
func (m *SC_GetExchangeShortCommoditys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetExchangeShortCommoditys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetExchangeShortCommoditys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetExchangeShortCommoditys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetExchangeShortCommoditys.Merge(m, src)
}
func (m *SC_GetExchangeShortCommoditys) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetExchangeShortCommoditys) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetExchangeShortCommoditys.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetExchangeShortCommoditys proto.InternalMessageInfo

func (m *SC_GetExchangeShortCommoditys) GetCommoditys() []*ExchangeShortCommodityData {
	if m != nil {
		return m.Commoditys
	}
	return nil
}

//返回正在售卖的道具
type CS_GetExchangeDetailedCommoditys struct {
	ItemID               int32    `protobuf:"varint,1,opt,name=ItemID,proto3" json:"ItemID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetExchangeDetailedCommoditys) Reset()         { *m = CS_GetExchangeDetailedCommoditys{} }
func (m *CS_GetExchangeDetailedCommoditys) String() string { return proto.CompactTextString(m) }
func (*CS_GetExchangeDetailedCommoditys) ProtoMessage()    {}
func (*CS_GetExchangeDetailedCommoditys) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{77}
}
func (m *CS_GetExchangeDetailedCommoditys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetExchangeDetailedCommoditys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetExchangeDetailedCommoditys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetExchangeDetailedCommoditys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetExchangeDetailedCommoditys.Merge(m, src)
}
func (m *CS_GetExchangeDetailedCommoditys) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetExchangeDetailedCommoditys) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetExchangeDetailedCommoditys.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetExchangeDetailedCommoditys proto.InternalMessageInfo

func (m *CS_GetExchangeDetailedCommoditys) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

//商品数据
//message CommodityDataProto{
//    int32 TypeID = 1;    //商品ID
//    int32 ItemID = 2;    //道具ID
//    int32 PriceType = 3; //价格类型 1金币 2砖石
//    int32 Price = 4;    //价格
//    int32 Level = 5; //道具等级
//}
//正在售卖的道具数据
type ExchangeDetailedCommodityData struct {
	CommodityData        *CommodityDataProto `protobuf:"bytes,1,opt,name=CommodityData,proto3" json:"CommodityData,omitempty"`
	RemaindTime          int32               `protobuf:"varint,2,opt,name=RemaindTime,proto3" json:"RemaindTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ExchangeDetailedCommodityData) Reset()         { *m = ExchangeDetailedCommodityData{} }
func (m *ExchangeDetailedCommodityData) String() string { return proto.CompactTextString(m) }
func (*ExchangeDetailedCommodityData) ProtoMessage()    {}
func (*ExchangeDetailedCommodityData) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{78}
}
func (m *ExchangeDetailedCommodityData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeDetailedCommodityData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeDetailedCommodityData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeDetailedCommodityData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeDetailedCommodityData.Merge(m, src)
}
func (m *ExchangeDetailedCommodityData) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeDetailedCommodityData) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeDetailedCommodityData.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeDetailedCommodityData proto.InternalMessageInfo

func (m *ExchangeDetailedCommodityData) GetCommodityData() *CommodityDataProto {
	if m != nil {
		return m.CommodityData
	}
	return nil
}

func (m *ExchangeDetailedCommodityData) GetRemaindTime() int32 {
	if m != nil {
		return m.RemaindTime
	}
	return 0
}

//返回正在售卖的道具数据
type SC_GetExchangeDetailedCommoditys struct {
	Commoditys           []*ExchangeDetailedCommodityData `protobuf:"bytes,1,rep,name=Commoditys,proto3" json:"Commoditys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                         `json:"-"`
	XXX_unrecognized     []byte                           `json:"-"`
	XXX_sizecache        int32                            `json:"-"`
}

func (m *SC_GetExchangeDetailedCommoditys) Reset()         { *m = SC_GetExchangeDetailedCommoditys{} }
func (m *SC_GetExchangeDetailedCommoditys) String() string { return proto.CompactTextString(m) }
func (*SC_GetExchangeDetailedCommoditys) ProtoMessage()    {}
func (*SC_GetExchangeDetailedCommoditys) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{79}
}
func (m *SC_GetExchangeDetailedCommoditys) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetExchangeDetailedCommoditys) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetExchangeDetailedCommoditys.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetExchangeDetailedCommoditys) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetExchangeDetailedCommoditys.Merge(m, src)
}
func (m *SC_GetExchangeDetailedCommoditys) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetExchangeDetailedCommoditys) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetExchangeDetailedCommoditys.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetExchangeDetailedCommoditys proto.InternalMessageInfo

func (m *SC_GetExchangeDetailedCommoditys) GetCommoditys() []*ExchangeDetailedCommodityData {
	if m != nil {
		return m.Commoditys
	}
	return nil
}

//购买商品
type CS_BuyExchangeCommodity struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_BuyExchangeCommodity) Reset()         { *m = CS_BuyExchangeCommodity{} }
func (m *CS_BuyExchangeCommodity) String() string { return proto.CompactTextString(m) }
func (*CS_BuyExchangeCommodity) ProtoMessage()    {}
func (*CS_BuyExchangeCommodity) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{80}
}
func (m *CS_BuyExchangeCommodity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_BuyExchangeCommodity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_BuyExchangeCommodity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_BuyExchangeCommodity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_BuyExchangeCommodity.Merge(m, src)
}
func (m *CS_BuyExchangeCommodity) XXX_Size() int {
	return m.Size()
}
func (m *CS_BuyExchangeCommodity) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_BuyExchangeCommodity.DiscardUnknown(m)
}

var xxx_messageInfo_CS_BuyExchangeCommodity proto.InternalMessageInfo

func (m *CS_BuyExchangeCommodity) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

//上架商品(只能上架背包里面的道具)
type CS_ShelfExchangeCommodity struct {
	BagPos               int32    `protobuf:"varint,1,opt,name=BagPos,proto3" json:"BagPos,omitempty"`
	PriceType            int32    `protobuf:"varint,2,opt,name=PriceType,proto3" json:"PriceType,omitempty"`
	Price                int32    `protobuf:"varint,3,opt,name=Price,proto3" json:"Price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_ShelfExchangeCommodity) Reset()         { *m = CS_ShelfExchangeCommodity{} }
func (m *CS_ShelfExchangeCommodity) String() string { return proto.CompactTextString(m) }
func (*CS_ShelfExchangeCommodity) ProtoMessage()    {}
func (*CS_ShelfExchangeCommodity) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{81}
}
func (m *CS_ShelfExchangeCommodity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_ShelfExchangeCommodity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_ShelfExchangeCommodity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_ShelfExchangeCommodity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_ShelfExchangeCommodity.Merge(m, src)
}
func (m *CS_ShelfExchangeCommodity) XXX_Size() int {
	return m.Size()
}
func (m *CS_ShelfExchangeCommodity) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_ShelfExchangeCommodity.DiscardUnknown(m)
}

var xxx_messageInfo_CS_ShelfExchangeCommodity proto.InternalMessageInfo

func (m *CS_ShelfExchangeCommodity) GetBagPos() int32 {
	if m != nil {
		return m.BagPos
	}
	return 0
}

func (m *CS_ShelfExchangeCommodity) GetPriceType() int32 {
	if m != nil {
		return m.PriceType
	}
	return 0
}

func (m *CS_ShelfExchangeCommodity) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

//下架商品()
type CS_UnShelfExchangeCommodity struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_UnShelfExchangeCommodity) Reset()         { *m = CS_UnShelfExchangeCommodity{} }
func (m *CS_UnShelfExchangeCommodity) String() string { return proto.CompactTextString(m) }
func (*CS_UnShelfExchangeCommodity) ProtoMessage()    {}
func (*CS_UnShelfExchangeCommodity) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{82}
}
func (m *CS_UnShelfExchangeCommodity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_UnShelfExchangeCommodity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_UnShelfExchangeCommodity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_UnShelfExchangeCommodity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_UnShelfExchangeCommodity.Merge(m, src)
}
func (m *CS_UnShelfExchangeCommodity) XXX_Size() int {
	return m.Size()
}
func (m *CS_UnShelfExchangeCommodity) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_UnShelfExchangeCommodity.DiscardUnknown(m)
}

var xxx_messageInfo_CS_UnShelfExchangeCommodity proto.InternalMessageInfo

func (m *CS_UnShelfExchangeCommodity) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

//获取我要出售界面信息
type CS_GetSellUIInfo struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetSellUIInfo) Reset()         { *m = CS_GetSellUIInfo{} }
func (m *CS_GetSellUIInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetSellUIInfo) ProtoMessage()    {}
func (*CS_GetSellUIInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{83}
}
func (m *CS_GetSellUIInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetSellUIInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetSellUIInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetSellUIInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetSellUIInfo.Merge(m, src)
}
func (m *CS_GetSellUIInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetSellUIInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetSellUIInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetSellUIInfo proto.InternalMessageInfo

func (m *CS_GetSellUIInfo) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

//获取我要出售界面信息
type SC_GetSellUIInfo struct {
	ShelfExchangeLimit        int32                            `protobuf:"varint,1,opt,name=ShelfExchangeLimit,proto3" json:"ShelfExchangeLimit,omitempty"`
	SellExchangeTax           float32                          `protobuf:"fixed32,2,opt,name=SellExchangeTax,proto3" json:"SellExchangeTax,omitempty"`
	ShelfExchangeFeePriceType int32                            `protobuf:"varint,3,opt,name=ShelfExchangeFeePriceType,proto3" json:"ShelfExchangeFeePriceType,omitempty"`
	ShelfExchangeFeePrice     int32                            `protobuf:"varint,4,opt,name=ShelfExchangeFeePrice,proto3" json:"ShelfExchangeFeePrice,omitempty"`
	AutoUnShelfTime           int32                            `protobuf:"varint,5,opt,name=AutoUnShelfTime,proto3" json:"AutoUnShelfTime,omitempty"`
	Commoditys                []*ExchangeDetailedCommodityData `protobuf:"bytes,6,rep,name=Commoditys,proto3" json:"Commoditys,omitempty"`
	Equips                    []*UnitEquip                     `protobuf:"bytes,7,rep,name=Equips,proto3" json:"Equips,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}                         `json:"-"`
	XXX_unrecognized          []byte                           `json:"-"`
	XXX_sizecache             int32                            `json:"-"`
}

func (m *SC_GetSellUIInfo) Reset()         { *m = SC_GetSellUIInfo{} }
func (m *SC_GetSellUIInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetSellUIInfo) ProtoMessage()    {}
func (*SC_GetSellUIInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{84}
}
func (m *SC_GetSellUIInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetSellUIInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetSellUIInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetSellUIInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetSellUIInfo.Merge(m, src)
}
func (m *SC_GetSellUIInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetSellUIInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetSellUIInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetSellUIInfo proto.InternalMessageInfo

func (m *SC_GetSellUIInfo) GetShelfExchangeLimit() int32 {
	if m != nil {
		return m.ShelfExchangeLimit
	}
	return 0
}

func (m *SC_GetSellUIInfo) GetSellExchangeTax() float32 {
	if m != nil {
		return m.SellExchangeTax
	}
	return 0
}

func (m *SC_GetSellUIInfo) GetShelfExchangeFeePriceType() int32 {
	if m != nil {
		return m.ShelfExchangeFeePriceType
	}
	return 0
}

func (m *SC_GetSellUIInfo) GetShelfExchangeFeePrice() int32 {
	if m != nil {
		return m.ShelfExchangeFeePrice
	}
	return 0
}

func (m *SC_GetSellUIInfo) GetAutoUnShelfTime() int32 {
	if m != nil {
		return m.AutoUnShelfTime
	}
	return 0
}

func (m *SC_GetSellUIInfo) GetCommoditys() []*ExchangeDetailedCommodityData {
	if m != nil {
		return m.Commoditys
	}
	return nil
}

func (m *SC_GetSellUIInfo) GetEquips() []*UnitEquip {
	if m != nil {
		return m.Equips
	}
	return nil
}

//获取世界拍卖行信息
type CS_GetWorldAuctionItems struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetWorldAuctionItems) Reset()         { *m = CS_GetWorldAuctionItems{} }
func (m *CS_GetWorldAuctionItems) String() string { return proto.CompactTextString(m) }
func (*CS_GetWorldAuctionItems) ProtoMessage()    {}
func (*CS_GetWorldAuctionItems) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{85}
}
func (m *CS_GetWorldAuctionItems) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetWorldAuctionItems) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetWorldAuctionItems.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetWorldAuctionItems) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetWorldAuctionItems.Merge(m, src)
}
func (m *CS_GetWorldAuctionItems) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetWorldAuctionItems) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetWorldAuctionItems.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetWorldAuctionItems proto.InternalMessageInfo

func (m *CS_GetWorldAuctionItems) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

type SC_GetWorldAuctionItems struct {
	Items                []*AuctionItem `protobuf:"bytes,1,rep,name=Items,proto3" json:"Items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SC_GetWorldAuctionItems) Reset()         { *m = SC_GetWorldAuctionItems{} }
func (m *SC_GetWorldAuctionItems) String() string { return proto.CompactTextString(m) }
func (*SC_GetWorldAuctionItems) ProtoMessage()    {}
func (*SC_GetWorldAuctionItems) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{86}
}
func (m *SC_GetWorldAuctionItems) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetWorldAuctionItems) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetWorldAuctionItems.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetWorldAuctionItems) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetWorldAuctionItems.Merge(m, src)
}
func (m *SC_GetWorldAuctionItems) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetWorldAuctionItems) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetWorldAuctionItems.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetWorldAuctionItems proto.InternalMessageInfo

func (m *SC_GetWorldAuctionItems) GetItems() []*AuctionItem {
	if m != nil {
		return m.Items
	}
	return nil
}

//出价公会拍卖物品
type CS_NewPriceWorldAuctionItem struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Price                int32    `protobuf:"varint,2,opt,name=Price,proto3" json:"Price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_NewPriceWorldAuctionItem) Reset()         { *m = CS_NewPriceWorldAuctionItem{} }
func (m *CS_NewPriceWorldAuctionItem) String() string { return proto.CompactTextString(m) }
func (*CS_NewPriceWorldAuctionItem) ProtoMessage()    {}
func (*CS_NewPriceWorldAuctionItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{87}
}
func (m *CS_NewPriceWorldAuctionItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_NewPriceWorldAuctionItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_NewPriceWorldAuctionItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_NewPriceWorldAuctionItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_NewPriceWorldAuctionItem.Merge(m, src)
}
func (m *CS_NewPriceWorldAuctionItem) XXX_Size() int {
	return m.Size()
}
func (m *CS_NewPriceWorldAuctionItem) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_NewPriceWorldAuctionItem.DiscardUnknown(m)
}

var xxx_messageInfo_CS_NewPriceWorldAuctionItem proto.InternalMessageInfo

func (m *CS_NewPriceWorldAuctionItem) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CS_NewPriceWorldAuctionItem) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

//-------------公会相关------------
//查看所有公会简短信息
type CS_GetAllGuildsInfo struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetAllGuildsInfo) Reset()         { *m = CS_GetAllGuildsInfo{} }
func (m *CS_GetAllGuildsInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetAllGuildsInfo) ProtoMessage()    {}
func (*CS_GetAllGuildsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{88}
}
func (m *CS_GetAllGuildsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetAllGuildsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetAllGuildsInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetAllGuildsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetAllGuildsInfo.Merge(m, src)
}
func (m *CS_GetAllGuildsInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetAllGuildsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetAllGuildsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetAllGuildsInfo proto.InternalMessageInfo

func (m *CS_GetAllGuildsInfo) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

//公会简短信息
type GuildShortInfo struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Level                int32    `protobuf:"varint,3,opt,name=Level,proto3" json:"Level,omitempty"`
	Experience           int32    `protobuf:"varint,4,opt,name=Experience,proto3" json:"Experience,omitempty"`
	MaxExperience        int32    `protobuf:"varint,5,opt,name=MaxExperience,proto3" json:"MaxExperience,omitempty"`
	CharacterCount       int32    `protobuf:"varint,6,opt,name=CharacterCount,proto3" json:"CharacterCount,omitempty"`
	MaxCount             int32    `protobuf:"varint,7,opt,name=MaxCount,proto3" json:"MaxCount,omitempty"`
	PresidentName        string   `protobuf:"bytes,8,opt,name=PresidentName,proto3" json:"PresidentName,omitempty"`
	Joinaudit            int32    `protobuf:"varint,9,opt,name=Joinaudit,proto3" json:"Joinaudit,omitempty"`
	Joinlevellimit       int32    `protobuf:"varint,10,opt,name=Joinlevellimit,proto3" json:"Joinlevellimit,omitempty"`
	Notice               string   `protobuf:"bytes,11,opt,name=Notice,proto3" json:"Notice,omitempty"`
	Rank                 int32    `protobuf:"varint,12,opt,name=Rank,proto3" json:"Rank,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuildShortInfo) Reset()         { *m = GuildShortInfo{} }
func (m *GuildShortInfo) String() string { return proto.CompactTextString(m) }
func (*GuildShortInfo) ProtoMessage()    {}
func (*GuildShortInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{89}
}
func (m *GuildShortInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuildShortInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuildShortInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuildShortInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuildShortInfo.Merge(m, src)
}
func (m *GuildShortInfo) XXX_Size() int {
	return m.Size()
}
func (m *GuildShortInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GuildShortInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GuildShortInfo proto.InternalMessageInfo

func (m *GuildShortInfo) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GuildShortInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GuildShortInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *GuildShortInfo) GetExperience() int32 {
	if m != nil {
		return m.Experience
	}
	return 0
}

func (m *GuildShortInfo) GetMaxExperience() int32 {
	if m != nil {
		return m.MaxExperience
	}
	return 0
}

func (m *GuildShortInfo) GetCharacterCount() int32 {
	if m != nil {
		return m.CharacterCount
	}
	return 0
}

func (m *GuildShortInfo) GetMaxCount() int32 {
	if m != nil {
		return m.MaxCount
	}
	return 0
}

func (m *GuildShortInfo) GetPresidentName() string {
	if m != nil {
		return m.PresidentName
	}
	return ""
}

func (m *GuildShortInfo) GetJoinaudit() int32 {
	if m != nil {
		return m.Joinaudit
	}
	return 0
}

func (m *GuildShortInfo) GetJoinlevellimit() int32 {
	if m != nil {
		return m.Joinlevellimit
	}
	return 0
}

func (m *GuildShortInfo) GetNotice() string {
	if m != nil {
		return m.Notice
	}
	return ""
}

func (m *GuildShortInfo) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

//返回所有公会信息
type SC_GetAllGuildsInfo struct {
	Guilds               []*GuildShortInfo `protobuf:"bytes,1,rep,name=Guilds,proto3" json:"Guilds,omitempty"`
	CreatePriceType      int32             `protobuf:"varint,2,opt,name=CreatePriceType,proto3" json:"CreatePriceType,omitempty"`
	CreatePrice          int32             `protobuf:"varint,3,opt,name=CreatePrice,proto3" json:"CreatePrice,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SC_GetAllGuildsInfo) Reset()         { *m = SC_GetAllGuildsInfo{} }
func (m *SC_GetAllGuildsInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetAllGuildsInfo) ProtoMessage()    {}
func (*SC_GetAllGuildsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{90}
}
func (m *SC_GetAllGuildsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetAllGuildsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetAllGuildsInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetAllGuildsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetAllGuildsInfo.Merge(m, src)
}
func (m *SC_GetAllGuildsInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetAllGuildsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetAllGuildsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetAllGuildsInfo proto.InternalMessageInfo

func (m *SC_GetAllGuildsInfo) GetGuilds() []*GuildShortInfo {
	if m != nil {
		return m.Guilds
	}
	return nil
}

func (m *SC_GetAllGuildsInfo) GetCreatePriceType() int32 {
	if m != nil {
		return m.CreatePriceType
	}
	return 0
}

func (m *SC_GetAllGuildsInfo) GetCreatePrice() int32 {
	if m != nil {
		return m.CreatePrice
	}
	return 0
}

//创建公会
type CS_CreateGuild struct {
	Name                 string   `protobuf:"bytes,1,opt,name=Name,proto3" json:"Name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_CreateGuild) Reset()         { *m = CS_CreateGuild{} }
func (m *CS_CreateGuild) String() string { return proto.CompactTextString(m) }
func (*CS_CreateGuild) ProtoMessage()    {}
func (*CS_CreateGuild) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{91}
}
func (m *CS_CreateGuild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_CreateGuild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_CreateGuild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_CreateGuild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_CreateGuild.Merge(m, src)
}
func (m *CS_CreateGuild) XXX_Size() int {
	return m.Size()
}
func (m *CS_CreateGuild) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_CreateGuild.DiscardUnknown(m)
}

var xxx_messageInfo_CS_CreateGuild proto.InternalMessageInfo

func (m *CS_CreateGuild) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

//申请加入公会
type CS_JoinGuild struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_JoinGuild) Reset()         { *m = CS_JoinGuild{} }
func (m *CS_JoinGuild) String() string { return proto.CompactTextString(m) }
func (*CS_JoinGuild) ProtoMessage()    {}
func (*CS_JoinGuild) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{92}
}
func (m *CS_JoinGuild) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_JoinGuild) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_JoinGuild.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_JoinGuild) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_JoinGuild.Merge(m, src)
}
func (m *CS_JoinGuild) XXX_Size() int {
	return m.Size()
}
func (m *CS_JoinGuild) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_JoinGuild.DiscardUnknown(m)
}

var xxx_messageInfo_CS_JoinGuild proto.InternalMessageInfo

func (m *CS_JoinGuild) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

//查看公会详情
type CS_GetGuildInfo struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetGuildInfo) Reset()         { *m = CS_GetGuildInfo{} }
func (m *CS_GetGuildInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetGuildInfo) ProtoMessage()    {}
func (*CS_GetGuildInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{93}
}
func (m *CS_GetGuildInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetGuildInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetGuildInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetGuildInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetGuildInfo.Merge(m, src)
}
func (m *CS_GetGuildInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetGuildInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetGuildInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetGuildInfo proto.InternalMessageInfo

func (m *CS_GetGuildInfo) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

type SC_GetGuildInfo struct {
	GuildBaseInfo        *GuildShortInfo `protobuf:"bytes,1,opt,name=GuildBaseInfo,proto3" json:"GuildBaseInfo,omitempty"`
	Characters           []*GuildChaInfo `protobuf:"bytes,2,rep,name=Characters,proto3" json:"Characters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SC_GetGuildInfo) Reset()         { *m = SC_GetGuildInfo{} }
func (m *SC_GetGuildInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetGuildInfo) ProtoMessage()    {}
func (*SC_GetGuildInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{94}
}
func (m *SC_GetGuildInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetGuildInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetGuildInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetGuildInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetGuildInfo.Merge(m, src)
}
func (m *SC_GetGuildInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetGuildInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetGuildInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetGuildInfo proto.InternalMessageInfo

func (m *SC_GetGuildInfo) GetGuildBaseInfo() *GuildShortInfo {
	if m != nil {
		return m.GuildBaseInfo
	}
	return nil
}

func (m *SC_GetGuildInfo) GetCharacters() []*GuildChaInfo {
	if m != nil {
		return m.Characters
	}
	return nil
}

//公会成员信息
type GuildChaInfo struct {
	Uid                  int32    `protobuf:"varint,1,opt,name=Uid,proto3" json:"Uid,omitempty"`
	Characterid          int32    `protobuf:"varint,2,opt,name=Characterid,proto3" json:"Characterid,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=Name,proto3" json:"Name,omitempty"`
	Level                int32    `protobuf:"varint,4,opt,name=Level,proto3" json:"Level,omitempty"`
	Typeid               int32    `protobuf:"varint,5,opt,name=Typeid,proto3" json:"Typeid,omitempty"`
	PinLevel             int32    `protobuf:"varint,6,opt,name=PinLevel,proto3" json:"PinLevel,omitempty"`
	PinExperience        int32    `protobuf:"varint,7,opt,name=PinExperience,proto3" json:"PinExperience,omitempty"`
	Post                 int32    `protobuf:"varint,8,opt,name=Post,proto3" json:"Post,omitempty"`
	PinLevelName         string   `protobuf:"bytes,9,opt,name=PinLevelName,proto3" json:"PinLevelName,omitempty"`
	PostName             string   `protobuf:"bytes,10,opt,name=PostName,proto3" json:"PostName,omitempty"`
	PinMaxExperience     int32    `protobuf:"varint,11,opt,name=PinMaxExperience,proto3" json:"PinMaxExperience,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuildChaInfo) Reset()         { *m = GuildChaInfo{} }
func (m *GuildChaInfo) String() string { return proto.CompactTextString(m) }
func (*GuildChaInfo) ProtoMessage()    {}
func (*GuildChaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{95}
}
func (m *GuildChaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuildChaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuildChaInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuildChaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuildChaInfo.Merge(m, src)
}
func (m *GuildChaInfo) XXX_Size() int {
	return m.Size()
}
func (m *GuildChaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GuildChaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GuildChaInfo proto.InternalMessageInfo

func (m *GuildChaInfo) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *GuildChaInfo) GetCharacterid() int32 {
	if m != nil {
		return m.Characterid
	}
	return 0
}

func (m *GuildChaInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GuildChaInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *GuildChaInfo) GetTypeid() int32 {
	if m != nil {
		return m.Typeid
	}
	return 0
}

func (m *GuildChaInfo) GetPinLevel() int32 {
	if m != nil {
		return m.PinLevel
	}
	return 0
}

func (m *GuildChaInfo) GetPinExperience() int32 {
	if m != nil {
		return m.PinExperience
	}
	return 0
}

func (m *GuildChaInfo) GetPost() int32 {
	if m != nil {
		return m.Post
	}
	return 0
}

func (m *GuildChaInfo) GetPinLevelName() string {
	if m != nil {
		return m.PinLevelName
	}
	return ""
}

func (m *GuildChaInfo) GetPostName() string {
	if m != nil {
		return m.PostName
	}
	return ""
}

func (m *GuildChaInfo) GetPinMaxExperience() int32 {
	if m != nil {
		return m.PinMaxExperience
	}
	return 0
}

//获取公会申请列表
type CS_GetJoinGuildPlayer struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetJoinGuildPlayer) Reset()         { *m = CS_GetJoinGuildPlayer{} }
func (m *CS_GetJoinGuildPlayer) String() string { return proto.CompactTextString(m) }
func (*CS_GetJoinGuildPlayer) ProtoMessage()    {}
func (*CS_GetJoinGuildPlayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{96}
}
func (m *CS_GetJoinGuildPlayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetJoinGuildPlayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetJoinGuildPlayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetJoinGuildPlayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetJoinGuildPlayer.Merge(m, src)
}
func (m *CS_GetJoinGuildPlayer) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetJoinGuildPlayer) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetJoinGuildPlayer.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetJoinGuildPlayer proto.InternalMessageInfo

func (m *CS_GetJoinGuildPlayer) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

type SC_GetJoinGuildPlayer struct {
	RequestCharacters    []*GuildChaInfo `protobuf:"bytes,1,rep,name=RequestCharacters,proto3" json:"RequestCharacters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SC_GetJoinGuildPlayer) Reset()         { *m = SC_GetJoinGuildPlayer{} }
func (m *SC_GetJoinGuildPlayer) String() string { return proto.CompactTextString(m) }
func (*SC_GetJoinGuildPlayer) ProtoMessage()    {}
func (*SC_GetJoinGuildPlayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{97}
}
func (m *SC_GetJoinGuildPlayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetJoinGuildPlayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetJoinGuildPlayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetJoinGuildPlayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetJoinGuildPlayer.Merge(m, src)
}
func (m *SC_GetJoinGuildPlayer) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetJoinGuildPlayer) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetJoinGuildPlayer.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetJoinGuildPlayer proto.InternalMessageInfo

func (m *SC_GetJoinGuildPlayer) GetRequestCharacters() []*GuildChaInfo {
	if m != nil {
		return m.RequestCharacters
	}
	return nil
}

//回复玩家加入公会
type CS_ResponseJoinGuildPlayer struct {
	Characterid          int32    `protobuf:"varint,1,opt,name=Characterid,proto3" json:"Characterid,omitempty"`
	Result               int32    `protobuf:"varint,2,opt,name=Result,proto3" json:"Result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_ResponseJoinGuildPlayer) Reset()         { *m = CS_ResponseJoinGuildPlayer{} }
func (m *CS_ResponseJoinGuildPlayer) String() string { return proto.CompactTextString(m) }
func (*CS_ResponseJoinGuildPlayer) ProtoMessage()    {}
func (*CS_ResponseJoinGuildPlayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{98}
}
func (m *CS_ResponseJoinGuildPlayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_ResponseJoinGuildPlayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_ResponseJoinGuildPlayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_ResponseJoinGuildPlayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_ResponseJoinGuildPlayer.Merge(m, src)
}
func (m *CS_ResponseJoinGuildPlayer) XXX_Size() int {
	return m.Size()
}
func (m *CS_ResponseJoinGuildPlayer) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_ResponseJoinGuildPlayer.DiscardUnknown(m)
}

var xxx_messageInfo_CS_ResponseJoinGuildPlayer proto.InternalMessageInfo

func (m *CS_ResponseJoinGuildPlayer) GetCharacterid() int32 {
	if m != nil {
		return m.Characterid
	}
	return 0
}

func (m *CS_ResponseJoinGuildPlayer) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

//把玩家踢出公会
type CS_DeleteGuildPlayer struct {
	Characterid          int32    `protobuf:"varint,1,opt,name=Characterid,proto3" json:"Characterid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_DeleteGuildPlayer) Reset()         { *m = CS_DeleteGuildPlayer{} }
func (m *CS_DeleteGuildPlayer) String() string { return proto.CompactTextString(m) }
func (*CS_DeleteGuildPlayer) ProtoMessage()    {}
func (*CS_DeleteGuildPlayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{99}
}
func (m *CS_DeleteGuildPlayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_DeleteGuildPlayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_DeleteGuildPlayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_DeleteGuildPlayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_DeleteGuildPlayer.Merge(m, src)
}
func (m *CS_DeleteGuildPlayer) XXX_Size() int {
	return m.Size()
}
func (m *CS_DeleteGuildPlayer) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_DeleteGuildPlayer.DiscardUnknown(m)
}

var xxx_messageInfo_CS_DeleteGuildPlayer proto.InternalMessageInfo

func (m *CS_DeleteGuildPlayer) GetCharacterid() int32 {
	if m != nil {
		return m.Characterid
	}
	return 0
}

//公会操作
type CS_GuildOperate struct {
	Code                 int32    `protobuf:"varint,1,opt,name=Code,proto3" json:"Code,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GuildOperate) Reset()         { *m = CS_GuildOperate{} }
func (m *CS_GuildOperate) String() string { return proto.CompactTextString(m) }
func (*CS_GuildOperate) ProtoMessage()    {}
func (*CS_GuildOperate) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{100}
}
func (m *CS_GuildOperate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GuildOperate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GuildOperate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GuildOperate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GuildOperate.Merge(m, src)
}
func (m *CS_GuildOperate) XXX_Size() int {
	return m.Size()
}
func (m *CS_GuildOperate) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GuildOperate.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GuildOperate proto.InternalMessageInfo

func (m *CS_GuildOperate) GetCode() int32 {
	if m != nil {
		return m.Code
	}
	return 0
}

//设置公会成员职位
type CS_ChangePost struct {
	Characterid          int32    `protobuf:"varint,1,opt,name=Characterid,proto3" json:"Characterid,omitempty"`
	Post                 int32    `protobuf:"varint,2,opt,name=Post,proto3" json:"Post,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_ChangePost) Reset()         { *m = CS_ChangePost{} }
func (m *CS_ChangePost) String() string { return proto.CompactTextString(m) }
func (*CS_ChangePost) ProtoMessage()    {}
func (*CS_ChangePost) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{101}
}
func (m *CS_ChangePost) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_ChangePost) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_ChangePost.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_ChangePost) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_ChangePost.Merge(m, src)
}
func (m *CS_ChangePost) XXX_Size() int {
	return m.Size()
}
func (m *CS_ChangePost) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_ChangePost.DiscardUnknown(m)
}

var xxx_messageInfo_CS_ChangePost proto.InternalMessageInfo

func (m *CS_ChangePost) GetCharacterid() int32 {
	if m != nil {
		return m.Characterid
	}
	return 0
}

func (m *CS_ChangePost) GetPost() int32 {
	if m != nil {
		return m.Post
	}
	return 0
}

//修改公告
type CS_EditorGuildNotice struct {
	Notice               string   `protobuf:"bytes,1,opt,name=Notice,proto3" json:"Notice,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_EditorGuildNotice) Reset()         { *m = CS_EditorGuildNotice{} }
func (m *CS_EditorGuildNotice) String() string { return proto.CompactTextString(m) }
func (*CS_EditorGuildNotice) ProtoMessage()    {}
func (*CS_EditorGuildNotice) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{102}
}
func (m *CS_EditorGuildNotice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_EditorGuildNotice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_EditorGuildNotice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_EditorGuildNotice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_EditorGuildNotice.Merge(m, src)
}
func (m *CS_EditorGuildNotice) XXX_Size() int {
	return m.Size()
}
func (m *CS_EditorGuildNotice) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_EditorGuildNotice.DiscardUnknown(m)
}

var xxx_messageInfo_CS_EditorGuildNotice proto.InternalMessageInfo

func (m *CS_EditorGuildNotice) GetNotice() string {
	if m != nil {
		return m.Notice
	}
	return ""
}

//获取公会拍卖物品
type CS_GetAuctionItems struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetAuctionItems) Reset()         { *m = CS_GetAuctionItems{} }
func (m *CS_GetAuctionItems) String() string { return proto.CompactTextString(m) }
func (*CS_GetAuctionItems) ProtoMessage()    {}
func (*CS_GetAuctionItems) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{103}
}
func (m *CS_GetAuctionItems) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetAuctionItems) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetAuctionItems.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetAuctionItems) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetAuctionItems.Merge(m, src)
}
func (m *CS_GetAuctionItems) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetAuctionItems) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetAuctionItems.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetAuctionItems proto.InternalMessageInfo

func (m *CS_GetAuctionItems) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

type SC_GetAuctionItems struct {
	Items                []*AuctionItem `protobuf:"bytes,1,rep,name=Items,proto3" json:"Items,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SC_GetAuctionItems) Reset()         { *m = SC_GetAuctionItems{} }
func (m *SC_GetAuctionItems) String() string { return proto.CompactTextString(m) }
func (*SC_GetAuctionItems) ProtoMessage()    {}
func (*SC_GetAuctionItems) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{104}
}
func (m *SC_GetAuctionItems) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetAuctionItems) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetAuctionItems.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetAuctionItems) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetAuctionItems.Merge(m, src)
}
func (m *SC_GetAuctionItems) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetAuctionItems) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetAuctionItems.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetAuctionItems proto.InternalMessageInfo

func (m *SC_GetAuctionItems) GetItems() []*AuctionItem {
	if m != nil {
		return m.Items
	}
	return nil
}

//公会拍卖物品数据
type AuctionItem struct {
	ID                    int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	ItemID                int32    `protobuf:"varint,2,opt,name=ItemID,proto3" json:"ItemID,omitempty"`
	PriceType             int32    `protobuf:"varint,3,opt,name=PriceType,proto3" json:"PriceType,omitempty"`
	Price                 int32    `protobuf:"varint,4,opt,name=Price,proto3" json:"Price,omitempty"`
	Level                 int32    `protobuf:"varint,5,opt,name=Level,proto3" json:"Level,omitempty"`
	BidderCharacterName   string   `protobuf:"bytes,6,opt,name=BidderCharacterName,proto3" json:"BidderCharacterName,omitempty"`
	ReceivecharactersName []string `protobuf:"bytes,7,rep,name=ReceivecharactersName,proto3" json:"ReceivecharactersName,omitempty"`
	RemainTime            int32    `protobuf:"varint,8,opt,name=RemainTime,proto3" json:"RemainTime,omitempty"`
	BidderType            int32    `protobuf:"varint,9,opt,name=BidderType,proto3" json:"BidderType,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *AuctionItem) Reset()         { *m = AuctionItem{} }
func (m *AuctionItem) String() string { return proto.CompactTextString(m) }
func (*AuctionItem) ProtoMessage()    {}
func (*AuctionItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{105}
}
func (m *AuctionItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuctionItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuctionItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuctionItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuctionItem.Merge(m, src)
}
func (m *AuctionItem) XXX_Size() int {
	return m.Size()
}
func (m *AuctionItem) XXX_DiscardUnknown() {
	xxx_messageInfo_AuctionItem.DiscardUnknown(m)
}

var xxx_messageInfo_AuctionItem proto.InternalMessageInfo

func (m *AuctionItem) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *AuctionItem) GetItemID() int32 {
	if m != nil {
		return m.ItemID
	}
	return 0
}

func (m *AuctionItem) GetPriceType() int32 {
	if m != nil {
		return m.PriceType
	}
	return 0
}

func (m *AuctionItem) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *AuctionItem) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *AuctionItem) GetBidderCharacterName() string {
	if m != nil {
		return m.BidderCharacterName
	}
	return ""
}

func (m *AuctionItem) GetReceivecharactersName() []string {
	if m != nil {
		return m.ReceivecharactersName
	}
	return nil
}

func (m *AuctionItem) GetRemainTime() int32 {
	if m != nil {
		return m.RemainTime
	}
	return 0
}

func (m *AuctionItem) GetBidderType() int32 {
	if m != nil {
		return m.BidderType
	}
	return 0
}

//出价公会拍卖物品
type CS_NewPriceAuctionItem struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	Price                int32    `protobuf:"varint,2,opt,name=Price,proto3" json:"Price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_NewPriceAuctionItem) Reset()         { *m = CS_NewPriceAuctionItem{} }
func (m *CS_NewPriceAuctionItem) String() string { return proto.CompactTextString(m) }
func (*CS_NewPriceAuctionItem) ProtoMessage()    {}
func (*CS_NewPriceAuctionItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{106}
}
func (m *CS_NewPriceAuctionItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_NewPriceAuctionItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_NewPriceAuctionItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_NewPriceAuctionItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_NewPriceAuctionItem.Merge(m, src)
}
func (m *CS_NewPriceAuctionItem) XXX_Size() int {
	return m.Size()
}
func (m *CS_NewPriceAuctionItem) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_NewPriceAuctionItem.DiscardUnknown(m)
}

var xxx_messageInfo_CS_NewPriceAuctionItem proto.InternalMessageInfo

func (m *CS_NewPriceAuctionItem) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CS_NewPriceAuctionItem) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

//获取公会排名界面信息
type CS_GetGuildRankInfo struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetGuildRankInfo) Reset()         { *m = CS_GetGuildRankInfo{} }
func (m *CS_GetGuildRankInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetGuildRankInfo) ProtoMessage()    {}
func (*CS_GetGuildRankInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{107}
}
func (m *CS_GetGuildRankInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetGuildRankInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetGuildRankInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetGuildRankInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetGuildRankInfo.Merge(m, src)
}
func (m *CS_GetGuildRankInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetGuildRankInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetGuildRankInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetGuildRankInfo proto.InternalMessageInfo

func (m *CS_GetGuildRankInfo) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

//返回公会排名界面信息
type SC_GetGuildRankInfo struct {
	Guilds               []*GuildShortInfo `protobuf:"bytes,1,rep,name=Guilds,proto3" json:"Guilds,omitempty"`
	MapInfo              *GuildMapInfo     `protobuf:"bytes,2,opt,name=MapInfo,proto3" json:"MapInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *SC_GetGuildRankInfo) Reset()         { *m = SC_GetGuildRankInfo{} }
func (m *SC_GetGuildRankInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetGuildRankInfo) ProtoMessage()    {}
func (*SC_GetGuildRankInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{108}
}
func (m *SC_GetGuildRankInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetGuildRankInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetGuildRankInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetGuildRankInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetGuildRankInfo.Merge(m, src)
}
func (m *SC_GetGuildRankInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetGuildRankInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetGuildRankInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetGuildRankInfo proto.InternalMessageInfo

func (m *SC_GetGuildRankInfo) GetGuilds() []*GuildShortInfo {
	if m != nil {
		return m.Guilds
	}
	return nil
}

func (m *SC_GetGuildRankInfo) GetMapInfo() *GuildMapInfo {
	if m != nil {
		return m.MapInfo
	}
	return nil
}

//获取公会排名战击杀信息
type CS_GetGuildRankBattleInfo struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetGuildRankBattleInfo) Reset()         { *m = CS_GetGuildRankBattleInfo{} }
func (m *CS_GetGuildRankBattleInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetGuildRankBattleInfo) ProtoMessage()    {}
func (*CS_GetGuildRankBattleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{109}
}
func (m *CS_GetGuildRankBattleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetGuildRankBattleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetGuildRankBattleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetGuildRankBattleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetGuildRankBattleInfo.Merge(m, src)
}
func (m *CS_GetGuildRankBattleInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetGuildRankBattleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetGuildRankBattleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetGuildRankBattleInfo proto.InternalMessageInfo

func (m *CS_GetGuildRankBattleInfo) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

//公会排名战击杀信息
type GuildRankBattleChaInfo struct {
	Characterid          int32    `protobuf:"varint,1,opt,name=Characterid,proto3" json:"Characterid,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Level                int32    `protobuf:"varint,3,opt,name=Level,proto3" json:"Level,omitempty"`
	KillCount            int32    `protobuf:"varint,4,opt,name=KillCount,proto3" json:"KillCount,omitempty"`
	DeathCount           int32    `protobuf:"varint,5,opt,name=DeathCount,proto3" json:"DeathCount,omitempty"`
	GuildId              int32    `protobuf:"varint,6,opt,name=GuildId,proto3" json:"GuildId,omitempty"`
	GuildName            string   `protobuf:"bytes,7,opt,name=GuildName,proto3" json:"GuildName,omitempty"`
	Typeid               int32    `protobuf:"varint,8,opt,name=Typeid,proto3" json:"Typeid,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuildRankBattleChaInfo) Reset()         { *m = GuildRankBattleChaInfo{} }
func (m *GuildRankBattleChaInfo) String() string { return proto.CompactTextString(m) }
func (*GuildRankBattleChaInfo) ProtoMessage()    {}
func (*GuildRankBattleChaInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{110}
}
func (m *GuildRankBattleChaInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuildRankBattleChaInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuildRankBattleChaInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuildRankBattleChaInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuildRankBattleChaInfo.Merge(m, src)
}
func (m *GuildRankBattleChaInfo) XXX_Size() int {
	return m.Size()
}
func (m *GuildRankBattleChaInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GuildRankBattleChaInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GuildRankBattleChaInfo proto.InternalMessageInfo

func (m *GuildRankBattleChaInfo) GetCharacterid() int32 {
	if m != nil {
		return m.Characterid
	}
	return 0
}

func (m *GuildRankBattleChaInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GuildRankBattleChaInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *GuildRankBattleChaInfo) GetKillCount() int32 {
	if m != nil {
		return m.KillCount
	}
	return 0
}

func (m *GuildRankBattleChaInfo) GetDeathCount() int32 {
	if m != nil {
		return m.DeathCount
	}
	return 0
}

func (m *GuildRankBattleChaInfo) GetGuildId() int32 {
	if m != nil {
		return m.GuildId
	}
	return 0
}

func (m *GuildRankBattleChaInfo) GetGuildName() string {
	if m != nil {
		return m.GuildName
	}
	return ""
}

func (m *GuildRankBattleChaInfo) GetTypeid() int32 {
	if m != nil {
		return m.Typeid
	}
	return 0
}

//返回公会排名战击杀信息
type SC_GetGuildRankBattleInfo struct {
	AllCha               []*GuildRankBattleChaInfo `protobuf:"bytes,1,rep,name=AllCha,proto3" json:"AllCha,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *SC_GetGuildRankBattleInfo) Reset()         { *m = SC_GetGuildRankBattleInfo{} }
func (m *SC_GetGuildRankBattleInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetGuildRankBattleInfo) ProtoMessage()    {}
func (*SC_GetGuildRankBattleInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{111}
}
func (m *SC_GetGuildRankBattleInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetGuildRankBattleInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetGuildRankBattleInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetGuildRankBattleInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetGuildRankBattleInfo.Merge(m, src)
}
func (m *SC_GetGuildRankBattleInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetGuildRankBattleInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetGuildRankBattleInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetGuildRankBattleInfo proto.InternalMessageInfo

func (m *SC_GetGuildRankBattleInfo) GetAllCha() []*GuildRankBattleChaInfo {
	if m != nil {
		return m.AllCha
	}
	return nil
}

//获取公会地图信息
type CS_GetGuildMapsInfo struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetGuildMapsInfo) Reset()         { *m = CS_GetGuildMapsInfo{} }
func (m *CS_GetGuildMapsInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetGuildMapsInfo) ProtoMessage()    {}
func (*CS_GetGuildMapsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{112}
}
func (m *CS_GetGuildMapsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetGuildMapsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetGuildMapsInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetGuildMapsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetGuildMapsInfo.Merge(m, src)
}
func (m *CS_GetGuildMapsInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetGuildMapsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetGuildMapsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetGuildMapsInfo proto.InternalMessageInfo

func (m *CS_GetGuildMapsInfo) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

//返回公会地图信息
type SC_GetGuildMapsInfo struct {
	Maps                 []*GuildMapInfo `protobuf:"bytes,1,rep,name=Maps,proto3" json:"Maps,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *SC_GetGuildMapsInfo) Reset()         { *m = SC_GetGuildMapsInfo{} }
func (m *SC_GetGuildMapsInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetGuildMapsInfo) ProtoMessage()    {}
func (*SC_GetGuildMapsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{113}
}
func (m *SC_GetGuildMapsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetGuildMapsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetGuildMapsInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetGuildMapsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetGuildMapsInfo.Merge(m, src)
}
func (m *SC_GetGuildMapsInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetGuildMapsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetGuildMapsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetGuildMapsInfo proto.InternalMessageInfo

func (m *SC_GetGuildMapsInfo) GetMaps() []*GuildMapInfo {
	if m != nil {
		return m.Maps
	}
	return nil
}

//公会地图信息
type GuildMapInfo struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	OpenMonthDay         int32    `protobuf:"varint,2,opt,name=OpenMonthDay,proto3" json:"OpenMonthDay,omitempty"`
	OpenWeekDay          string   `protobuf:"bytes,3,opt,name=OpenWeekDay,proto3" json:"OpenWeekDay,omitempty"`
	OpenStartTime        string   `protobuf:"bytes,4,opt,name=OpenStartTime,proto3" json:"OpenStartTime,omitempty"`
	OpenEndTime          string   `protobuf:"bytes,5,opt,name=OpenEndTime,proto3" json:"OpenEndTime,omitempty"`
	NeedGuildLevel       int32    `protobuf:"varint,6,opt,name=NeedGuildLevel,proto3" json:"NeedGuildLevel,omitempty"`
	NextSceneID          int32    `protobuf:"varint,7,opt,name=NextSceneID,proto3" json:"NextSceneID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GuildMapInfo) Reset()         { *m = GuildMapInfo{} }
func (m *GuildMapInfo) String() string { return proto.CompactTextString(m) }
func (*GuildMapInfo) ProtoMessage()    {}
func (*GuildMapInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{114}
}
func (m *GuildMapInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GuildMapInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GuildMapInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GuildMapInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GuildMapInfo.Merge(m, src)
}
func (m *GuildMapInfo) XXX_Size() int {
	return m.Size()
}
func (m *GuildMapInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GuildMapInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GuildMapInfo proto.InternalMessageInfo

func (m *GuildMapInfo) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *GuildMapInfo) GetOpenMonthDay() int32 {
	if m != nil {
		return m.OpenMonthDay
	}
	return 0
}

func (m *GuildMapInfo) GetOpenWeekDay() string {
	if m != nil {
		return m.OpenWeekDay
	}
	return ""
}

func (m *GuildMapInfo) GetOpenStartTime() string {
	if m != nil {
		return m.OpenStartTime
	}
	return ""
}

func (m *GuildMapInfo) GetOpenEndTime() string {
	if m != nil {
		return m.OpenEndTime
	}
	return ""
}

func (m *GuildMapInfo) GetNeedGuildLevel() int32 {
	if m != nil {
		return m.NeedGuildLevel
	}
	return 0
}

func (m *GuildMapInfo) GetNextSceneID() int32 {
	if m != nil {
		return m.NextSceneID
	}
	return 0
}

//进入公会地图
type CS_GotoGuildMap struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GotoGuildMap) Reset()         { *m = CS_GotoGuildMap{} }
func (m *CS_GotoGuildMap) String() string { return proto.CompactTextString(m) }
func (*CS_GotoGuildMap) ProtoMessage()    {}
func (*CS_GotoGuildMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{115}
}
func (m *CS_GotoGuildMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GotoGuildMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GotoGuildMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GotoGuildMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GotoGuildMap.Merge(m, src)
}
func (m *CS_GotoGuildMap) XXX_Size() int {
	return m.Size()
}
func (m *CS_GotoGuildMap) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GotoGuildMap.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GotoGuildMap proto.InternalMessageInfo

func (m *CS_GotoGuildMap) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

type SC_GotoGuildMap struct {
	Result               int32    `protobuf:"varint,1,opt,name=Result,proto3" json:"Result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SC_GotoGuildMap) Reset()         { *m = SC_GotoGuildMap{} }
func (m *SC_GotoGuildMap) String() string { return proto.CompactTextString(m) }
func (*SC_GotoGuildMap) ProtoMessage()    {}
func (*SC_GotoGuildMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{116}
}
func (m *SC_GotoGuildMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GotoGuildMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GotoGuildMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GotoGuildMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GotoGuildMap.Merge(m, src)
}
func (m *SC_GotoGuildMap) XXX_Size() int {
	return m.Size()
}
func (m *SC_GotoGuildMap) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GotoGuildMap.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GotoGuildMap proto.InternalMessageInfo

func (m *SC_GotoGuildMap) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

//获取活动地图
type CS_GetActivityMapsInfo struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetActivityMapsInfo) Reset()         { *m = CS_GetActivityMapsInfo{} }
func (m *CS_GetActivityMapsInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetActivityMapsInfo) ProtoMessage()    {}
func (*CS_GetActivityMapsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{117}
}
func (m *CS_GetActivityMapsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetActivityMapsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetActivityMapsInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetActivityMapsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetActivityMapsInfo.Merge(m, src)
}
func (m *CS_GetActivityMapsInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetActivityMapsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetActivityMapsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetActivityMapsInfo proto.InternalMessageInfo

func (m *CS_GetActivityMapsInfo) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

//返回活动地图信息
type SC_GetActivityMapsInfo struct {
	Maps                 []*ActivityMapInfo `protobuf:"bytes,1,rep,name=Maps,proto3" json:"Maps,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SC_GetActivityMapsInfo) Reset()         { *m = SC_GetActivityMapsInfo{} }
func (m *SC_GetActivityMapsInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetActivityMapsInfo) ProtoMessage()    {}
func (*SC_GetActivityMapsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{118}
}
func (m *SC_GetActivityMapsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetActivityMapsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetActivityMapsInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetActivityMapsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetActivityMapsInfo.Merge(m, src)
}
func (m *SC_GetActivityMapsInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetActivityMapsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetActivityMapsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetActivityMapsInfo proto.InternalMessageInfo

func (m *SC_GetActivityMapsInfo) GetMaps() []*ActivityMapInfo {
	if m != nil {
		return m.Maps
	}
	return nil
}

//活动地图信息
type ActivityMapInfo struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	OpenMonthDay         int32    `protobuf:"varint,2,opt,name=OpenMonthDay,proto3" json:"OpenMonthDay,omitempty"`
	OpenWeekDay          string   `protobuf:"bytes,3,opt,name=OpenWeekDay,proto3" json:"OpenWeekDay,omitempty"`
	OpenStartTime        string   `protobuf:"bytes,4,opt,name=OpenStartTime,proto3" json:"OpenStartTime,omitempty"`
	OpenEndTime          string   `protobuf:"bytes,5,opt,name=OpenEndTime,proto3" json:"OpenEndTime,omitempty"`
	NeedLevel            int32    `protobuf:"varint,6,opt,name=NeedLevel,proto3" json:"NeedLevel,omitempty"`
	NextSceneID          int32    `protobuf:"varint,7,opt,name=NextSceneID,proto3" json:"NextSceneID,omitempty"`
	PriceType            int32    `protobuf:"varint,8,opt,name=PriceType,proto3" json:"PriceType,omitempty"`
	Price                int32    `protobuf:"varint,9,opt,name=Price,proto3" json:"Price,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ActivityMapInfo) Reset()         { *m = ActivityMapInfo{} }
func (m *ActivityMapInfo) String() string { return proto.CompactTextString(m) }
func (*ActivityMapInfo) ProtoMessage()    {}
func (*ActivityMapInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{119}
}
func (m *ActivityMapInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ActivityMapInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ActivityMapInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ActivityMapInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ActivityMapInfo.Merge(m, src)
}
func (m *ActivityMapInfo) XXX_Size() int {
	return m.Size()
}
func (m *ActivityMapInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ActivityMapInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ActivityMapInfo proto.InternalMessageInfo

func (m *ActivityMapInfo) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ActivityMapInfo) GetOpenMonthDay() int32 {
	if m != nil {
		return m.OpenMonthDay
	}
	return 0
}

func (m *ActivityMapInfo) GetOpenWeekDay() string {
	if m != nil {
		return m.OpenWeekDay
	}
	return ""
}

func (m *ActivityMapInfo) GetOpenStartTime() string {
	if m != nil {
		return m.OpenStartTime
	}
	return ""
}

func (m *ActivityMapInfo) GetOpenEndTime() string {
	if m != nil {
		return m.OpenEndTime
	}
	return ""
}

func (m *ActivityMapInfo) GetNeedLevel() int32 {
	if m != nil {
		return m.NeedLevel
	}
	return 0
}

func (m *ActivityMapInfo) GetNextSceneID() int32 {
	if m != nil {
		return m.NextSceneID
	}
	return 0
}

func (m *ActivityMapInfo) GetPriceType() int32 {
	if m != nil {
		return m.PriceType
	}
	return 0
}

func (m *ActivityMapInfo) GetPrice() int32 {
	if m != nil {
		return m.Price
	}
	return 0
}

//获取地图信息包括boss刷新时间和掉落道具
type CS_GetMapInfo struct {
	SceneID              int32    `protobuf:"varint,1,opt,name=SceneID,proto3" json:"SceneID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetMapInfo) Reset()         { *m = CS_GetMapInfo{} }
func (m *CS_GetMapInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetMapInfo) ProtoMessage()    {}
func (*CS_GetMapInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{120}
}
func (m *CS_GetMapInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetMapInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetMapInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetMapInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetMapInfo.Merge(m, src)
}
func (m *CS_GetMapInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetMapInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetMapInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetMapInfo proto.InternalMessageInfo

func (m *CS_GetMapInfo) GetSceneID() int32 {
	if m != nil {
		return m.SceneID
	}
	return 0
}

//返回地图信息
type SC_GetMapInfo struct {
	SceneID              int32    `protobuf:"varint,1,opt,name=SceneID,proto3" json:"SceneID,omitempty"`
	BossFreshTime        int32    `protobuf:"varint,2,opt,name=BossFreshTime,proto3" json:"BossFreshTime,omitempty"`
	DropItems            []int32  `protobuf:"varint,3,rep,packed,name=DropItems,proto3" json:"DropItems,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SC_GetMapInfo) Reset()         { *m = SC_GetMapInfo{} }
func (m *SC_GetMapInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetMapInfo) ProtoMessage()    {}
func (*SC_GetMapInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{121}
}
func (m *SC_GetMapInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetMapInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetMapInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetMapInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetMapInfo.Merge(m, src)
}
func (m *SC_GetMapInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetMapInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetMapInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetMapInfo proto.InternalMessageInfo

func (m *SC_GetMapInfo) GetSceneID() int32 {
	if m != nil {
		return m.SceneID
	}
	return 0
}

func (m *SC_GetMapInfo) GetBossFreshTime() int32 {
	if m != nil {
		return m.BossFreshTime
	}
	return 0
}

func (m *SC_GetMapInfo) GetDropItems() []int32 {
	if m != nil {
		return m.DropItems
	}
	return nil
}

//进入活动地图
type CS_GotoActivityMap struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GotoActivityMap) Reset()         { *m = CS_GotoActivityMap{} }
func (m *CS_GotoActivityMap) String() string { return proto.CompactTextString(m) }
func (*CS_GotoActivityMap) ProtoMessage()    {}
func (*CS_GotoActivityMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{122}
}
func (m *CS_GotoActivityMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GotoActivityMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GotoActivityMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GotoActivityMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GotoActivityMap.Merge(m, src)
}
func (m *CS_GotoActivityMap) XXX_Size() int {
	return m.Size()
}
func (m *CS_GotoActivityMap) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GotoActivityMap.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GotoActivityMap proto.InternalMessageInfo

func (m *CS_GotoActivityMap) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

type SC_GotoActivityMap struct {
	Result               int32    `protobuf:"varint,1,opt,name=Result,proto3" json:"Result,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SC_GotoActivityMap) Reset()         { *m = SC_GotoActivityMap{} }
func (m *SC_GotoActivityMap) String() string { return proto.CompactTextString(m) }
func (*SC_GotoActivityMap) ProtoMessage()    {}
func (*SC_GotoActivityMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{123}
}
func (m *SC_GotoActivityMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GotoActivityMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GotoActivityMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GotoActivityMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GotoActivityMap.Merge(m, src)
}
func (m *SC_GotoActivityMap) XXX_Size() int {
	return m.Size()
}
func (m *SC_GotoActivityMap) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GotoActivityMap.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GotoActivityMap proto.InternalMessageInfo

func (m *SC_GotoActivityMap) GetResult() int32 {
	if m != nil {
		return m.Result
	}
	return 0
}

//获取夺宝奇兵活动信息
type CS_GetDuoBaoInfo struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetDuoBaoInfo) Reset()         { *m = CS_GetDuoBaoInfo{} }
func (m *CS_GetDuoBaoInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetDuoBaoInfo) ProtoMessage()    {}
func (*CS_GetDuoBaoInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{124}
}
func (m *CS_GetDuoBaoInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetDuoBaoInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetDuoBaoInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetDuoBaoInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetDuoBaoInfo.Merge(m, src)
}
func (m *CS_GetDuoBaoInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetDuoBaoInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetDuoBaoInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetDuoBaoInfo proto.InternalMessageInfo

func (m *CS_GetDuoBaoInfo) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

//获取夺宝奇兵活动信息
type SC_GetDuoBaoInfo struct {
	MapGoInInfo          *ActivityMapInfo `protobuf:"bytes,1,opt,name=MapGoInInfo,proto3" json:"MapGoInInfo,omitempty"`
	MapInfo              *SC_GetMapInfo   `protobuf:"bytes,2,opt,name=MapInfo,proto3" json:"MapInfo,omitempty"`
	Minute               int32            `protobuf:"varint,3,opt,name=Minute,proto3" json:"Minute,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SC_GetDuoBaoInfo) Reset()         { *m = SC_GetDuoBaoInfo{} }
func (m *SC_GetDuoBaoInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetDuoBaoInfo) ProtoMessage()    {}
func (*SC_GetDuoBaoInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{125}
}
func (m *SC_GetDuoBaoInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetDuoBaoInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetDuoBaoInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetDuoBaoInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetDuoBaoInfo.Merge(m, src)
}
func (m *SC_GetDuoBaoInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetDuoBaoInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetDuoBaoInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetDuoBaoInfo proto.InternalMessageInfo

func (m *SC_GetDuoBaoInfo) GetMapGoInInfo() *ActivityMapInfo {
	if m != nil {
		return m.MapGoInInfo
	}
	return nil
}

func (m *SC_GetDuoBaoInfo) GetMapInfo() *SC_GetMapInfo {
	if m != nil {
		return m.MapInfo
	}
	return nil
}

func (m *SC_GetDuoBaoInfo) GetMinute() int32 {
	if m != nil {
		return m.Minute
	}
	return 0
}

//获取所有副本地图信息
type CS_GetCopyMapsInfo struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetCopyMapsInfo) Reset()         { *m = CS_GetCopyMapsInfo{} }
func (m *CS_GetCopyMapsInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetCopyMapsInfo) ProtoMessage()    {}
func (*CS_GetCopyMapsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{126}
}
func (m *CS_GetCopyMapsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetCopyMapsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetCopyMapsInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetCopyMapsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetCopyMapsInfo.Merge(m, src)
}
func (m *CS_GetCopyMapsInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetCopyMapsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetCopyMapsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetCopyMapsInfo proto.InternalMessageInfo

func (m *CS_GetCopyMapsInfo) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

//返回副本地图信息
type SC_GetCopyMapsInfo struct {
	Maps                 []*CopyMapInfo `protobuf:"bytes,1,rep,name=Maps,proto3" json:"Maps,omitempty"`
	RemainPlayTimes      int32          `protobuf:"varint,2,opt,name=RemainPlayTimes,proto3" json:"RemainPlayTimes,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *SC_GetCopyMapsInfo) Reset()         { *m = SC_GetCopyMapsInfo{} }
func (m *SC_GetCopyMapsInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetCopyMapsInfo) ProtoMessage()    {}
func (*SC_GetCopyMapsInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{127}
}
func (m *SC_GetCopyMapsInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetCopyMapsInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetCopyMapsInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetCopyMapsInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetCopyMapsInfo.Merge(m, src)
}
func (m *SC_GetCopyMapsInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetCopyMapsInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetCopyMapsInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetCopyMapsInfo proto.InternalMessageInfo

func (m *SC_GetCopyMapsInfo) GetMaps() []*CopyMapInfo {
	if m != nil {
		return m.Maps
	}
	return nil
}

func (m *SC_GetCopyMapsInfo) GetRemainPlayTimes() int32 {
	if m != nil {
		return m.RemainPlayTimes
	}
	return 0
}

//副本地图信息
type CopyMapInfo struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	NeedLevel            int32    `protobuf:"varint,2,opt,name=NeedLevel,proto3" json:"NeedLevel,omitempty"`
	NextSceneID          int32    `protobuf:"varint,3,opt,name=NextSceneID,proto3" json:"NextSceneID,omitempty"`
	PlayerCount          int32    `protobuf:"varint,4,opt,name=PlayerCount,proto3" json:"PlayerCount,omitempty"`
	State                int32    `protobuf:"varint,5,opt,name=State,proto3" json:"State,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CopyMapInfo) Reset()         { *m = CopyMapInfo{} }
func (m *CopyMapInfo) String() string { return proto.CompactTextString(m) }
func (*CopyMapInfo) ProtoMessage()    {}
func (*CopyMapInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{128}
}
func (m *CopyMapInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CopyMapInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CopyMapInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CopyMapInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CopyMapInfo.Merge(m, src)
}
func (m *CopyMapInfo) XXX_Size() int {
	return m.Size()
}
func (m *CopyMapInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CopyMapInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CopyMapInfo proto.InternalMessageInfo

func (m *CopyMapInfo) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CopyMapInfo) GetNeedLevel() int32 {
	if m != nil {
		return m.NeedLevel
	}
	return 0
}

func (m *CopyMapInfo) GetNextSceneID() int32 {
	if m != nil {
		return m.NextSceneID
	}
	return 0
}

func (m *CopyMapInfo) GetPlayerCount() int32 {
	if m != nil {
		return m.PlayerCount
	}
	return 0
}

func (m *CopyMapInfo) GetState() int32 {
	if m != nil {
		return m.State
	}
	return 0
}

//匹配副本
type CS_CopyMapPiPei struct {
	CopyMapID            int32    `protobuf:"varint,1,opt,name=CopyMapID,proto3" json:"CopyMapID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_CopyMapPiPei) Reset()         { *m = CS_CopyMapPiPei{} }
func (m *CS_CopyMapPiPei) String() string { return proto.CompactTextString(m) }
func (*CS_CopyMapPiPei) ProtoMessage()    {}
func (*CS_CopyMapPiPei) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{129}
}
func (m *CS_CopyMapPiPei) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_CopyMapPiPei) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_CopyMapPiPei.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_CopyMapPiPei) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_CopyMapPiPei.Merge(m, src)
}
func (m *CS_CopyMapPiPei) XXX_Size() int {
	return m.Size()
}
func (m *CS_CopyMapPiPei) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_CopyMapPiPei.DiscardUnknown(m)
}

var xxx_messageInfo_CS_CopyMapPiPei proto.InternalMessageInfo

func (m *CS_CopyMapPiPei) GetCopyMapID() int32 {
	if m != nil {
		return m.CopyMapID
	}
	return 0
}

//取消匹配
type CS_CopyMapCancel struct {
	CopyMapID            int32    `protobuf:"varint,1,opt,name=CopyMapID,proto3" json:"CopyMapID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_CopyMapCancel) Reset()         { *m = CS_CopyMapCancel{} }
func (m *CS_CopyMapCancel) String() string { return proto.CompactTextString(m) }
func (*CS_CopyMapCancel) ProtoMessage()    {}
func (*CS_CopyMapCancel) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{130}
}
func (m *CS_CopyMapCancel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_CopyMapCancel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_CopyMapCancel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_CopyMapCancel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_CopyMapCancel.Merge(m, src)
}
func (m *CS_CopyMapCancel) XXX_Size() int {
	return m.Size()
}
func (m *CS_CopyMapCancel) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_CopyMapCancel.DiscardUnknown(m)
}

var xxx_messageInfo_CS_CopyMapCancel proto.InternalMessageInfo

func (m *CS_CopyMapCancel) GetCopyMapID() int32 {
	if m != nil {
		return m.CopyMapID
	}
	return 0
}

//匹配信息(gameui上的显示)
type SC_ShowPiPeiInfo struct {
	PiPeiState           int32    `protobuf:"varint,1,opt,name=PiPeiState,proto3" json:"PiPeiState,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SC_ShowPiPeiInfo) Reset()         { *m = SC_ShowPiPeiInfo{} }
func (m *SC_ShowPiPeiInfo) String() string { return proto.CompactTextString(m) }
func (*SC_ShowPiPeiInfo) ProtoMessage()    {}
func (*SC_ShowPiPeiInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{131}
}
func (m *SC_ShowPiPeiInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_ShowPiPeiInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_ShowPiPeiInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_ShowPiPeiInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_ShowPiPeiInfo.Merge(m, src)
}
func (m *SC_ShowPiPeiInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_ShowPiPeiInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_ShowPiPeiInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_ShowPiPeiInfo proto.InternalMessageInfo

func (m *SC_ShowPiPeiInfo) GetPiPeiState() int32 {
	if m != nil {
		return m.PiPeiState
	}
	return 0
}

//获取竞技场排行信息
type CS_GetBattleRankInfo struct {
	RankStart            int32    `protobuf:"varint,1,opt,name=RankStart,proto3" json:"RankStart,omitempty"`
	RankCount            int32    `protobuf:"varint,2,opt,name=RankCount,proto3" json:"RankCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetBattleRankInfo) Reset()         { *m = CS_GetBattleRankInfo{} }
func (m *CS_GetBattleRankInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetBattleRankInfo) ProtoMessage()    {}
func (*CS_GetBattleRankInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{132}
}
func (m *CS_GetBattleRankInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetBattleRankInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetBattleRankInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetBattleRankInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetBattleRankInfo.Merge(m, src)
}
func (m *CS_GetBattleRankInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetBattleRankInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetBattleRankInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetBattleRankInfo proto.InternalMessageInfo

func (m *CS_GetBattleRankInfo) GetRankStart() int32 {
	if m != nil {
		return m.RankStart
	}
	return 0
}

func (m *CS_GetBattleRankInfo) GetRankCount() int32 {
	if m != nil {
		return m.RankCount
	}
	return 0
}

//获取竞技场地图信息
type CS_GetBattleMapInfo struct {
	ID                   int32    `protobuf:"varint,1,opt,name=ID,proto3" json:"ID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetBattleMapInfo) Reset()         { *m = CS_GetBattleMapInfo{} }
func (m *CS_GetBattleMapInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetBattleMapInfo) ProtoMessage()    {}
func (*CS_GetBattleMapInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{133}
}
func (m *CS_GetBattleMapInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetBattleMapInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetBattleMapInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetBattleMapInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetBattleMapInfo.Merge(m, src)
}
func (m *CS_GetBattleMapInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetBattleMapInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetBattleMapInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetBattleMapInfo proto.InternalMessageInfo

func (m *CS_GetBattleMapInfo) GetID() int32 {
	if m != nil {
		return m.ID
	}
	return 0
}

//返回竞技场排名
type SC_GetBattleRankInfo struct {
	RankInfo             []*BattleRankOneInfo `protobuf:"bytes,1,rep,name=RankInfo,proto3" json:"RankInfo,omitempty"`
	MyRankInfo           *BattleRankOneInfo   `protobuf:"bytes,2,opt,name=MyRankInfo,proto3" json:"MyRankInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *SC_GetBattleRankInfo) Reset()         { *m = SC_GetBattleRankInfo{} }
func (m *SC_GetBattleRankInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetBattleRankInfo) ProtoMessage()    {}
func (*SC_GetBattleRankInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{134}
}
func (m *SC_GetBattleRankInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetBattleRankInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetBattleRankInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetBattleRankInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetBattleRankInfo.Merge(m, src)
}
func (m *SC_GetBattleRankInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetBattleRankInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetBattleRankInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetBattleRankInfo proto.InternalMessageInfo

func (m *SC_GetBattleRankInfo) GetRankInfo() []*BattleRankOneInfo {
	if m != nil {
		return m.RankInfo
	}
	return nil
}

func (m *SC_GetBattleRankInfo) GetMyRankInfo() *BattleRankOneInfo {
	if m != nil {
		return m.MyRankInfo
	}
	return nil
}

//获取竞技场地图信息
type SC_GetBattleMapInfo struct {
	BattleMapInfo        *CopyMapInfo `protobuf:"bytes,1,opt,name=BattleMapInfo,proto3" json:"BattleMapInfo,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *SC_GetBattleMapInfo) Reset()         { *m = SC_GetBattleMapInfo{} }
func (m *SC_GetBattleMapInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetBattleMapInfo) ProtoMessage()    {}
func (*SC_GetBattleMapInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{135}
}
func (m *SC_GetBattleMapInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetBattleMapInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetBattleMapInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetBattleMapInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetBattleMapInfo.Merge(m, src)
}
func (m *SC_GetBattleMapInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetBattleMapInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetBattleMapInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetBattleMapInfo proto.InternalMessageInfo

func (m *SC_GetBattleMapInfo) GetBattleMapInfo() *CopyMapInfo {
	if m != nil {
		return m.BattleMapInfo
	}
	return nil
}

//竞技场排名单个信息
type BattleRankOneInfo struct {
	Characterid          int32    `protobuf:"varint,1,opt,name=Characterid,proto3" json:"Characterid,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Typeid               int32    `protobuf:"varint,3,opt,name=Typeid,proto3" json:"Typeid,omitempty"`
	Rank                 int32    `protobuf:"varint,4,opt,name=Rank,proto3" json:"Rank,omitempty"`
	Score                int32    `protobuf:"varint,5,opt,name=Score,proto3" json:"Score,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BattleRankOneInfo) Reset()         { *m = BattleRankOneInfo{} }
func (m *BattleRankOneInfo) String() string { return proto.CompactTextString(m) }
func (*BattleRankOneInfo) ProtoMessage()    {}
func (*BattleRankOneInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{136}
}
func (m *BattleRankOneInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BattleRankOneInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BattleRankOneInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BattleRankOneInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BattleRankOneInfo.Merge(m, src)
}
func (m *BattleRankOneInfo) XXX_Size() int {
	return m.Size()
}
func (m *BattleRankOneInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BattleRankOneInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BattleRankOneInfo proto.InternalMessageInfo

func (m *BattleRankOneInfo) GetCharacterid() int32 {
	if m != nil {
		return m.Characterid
	}
	return 0
}

func (m *BattleRankOneInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BattleRankOneInfo) GetTypeid() int32 {
	if m != nil {
		return m.Typeid
	}
	return 0
}

func (m *BattleRankOneInfo) GetRank() int32 {
	if m != nil {
		return m.Rank
	}
	return 0
}

func (m *BattleRankOneInfo) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

//匹配竞技场
type CS_BattlePiPei struct {
	CopyMapID            int32    `protobuf:"varint,1,opt,name=CopyMapID,proto3" json:"CopyMapID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_BattlePiPei) Reset()         { *m = CS_BattlePiPei{} }
func (m *CS_BattlePiPei) String() string { return proto.CompactTextString(m) }
func (*CS_BattlePiPei) ProtoMessage()    {}
func (*CS_BattlePiPei) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{137}
}
func (m *CS_BattlePiPei) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_BattlePiPei) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_BattlePiPei.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_BattlePiPei) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_BattlePiPei.Merge(m, src)
}
func (m *CS_BattlePiPei) XXX_Size() int {
	return m.Size()
}
func (m *CS_BattlePiPei) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_BattlePiPei.DiscardUnknown(m)
}

var xxx_messageInfo_CS_BattlePiPei proto.InternalMessageInfo

func (m *CS_BattlePiPei) GetCopyMapID() int32 {
	if m != nil {
		return m.CopyMapID
	}
	return 0
}

//取消匹配竞技场
type CS_BattleCancel struct {
	CopyMapID            int32    `protobuf:"varint,1,opt,name=CopyMapID,proto3" json:"CopyMapID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_BattleCancel) Reset()         { *m = CS_BattleCancel{} }
func (m *CS_BattleCancel) String() string { return proto.CompactTextString(m) }
func (*CS_BattleCancel) ProtoMessage()    {}
func (*CS_BattleCancel) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{138}
}
func (m *CS_BattleCancel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_BattleCancel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_BattleCancel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_BattleCancel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_BattleCancel.Merge(m, src)
}
func (m *CS_BattleCancel) XXX_Size() int {
	return m.Size()
}
func (m *CS_BattleCancel) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_BattleCancel.DiscardUnknown(m)
}

var xxx_messageInfo_CS_BattleCancel proto.InternalMessageInfo

func (m *CS_BattleCancel) GetCopyMapID() int32 {
	if m != nil {
		return m.CopyMapID
	}
	return 0
}

//查看竞技场面板
type CS_GetBattleHeroInfo struct {
	SceneID              int32    `protobuf:"varint,1,opt,name=SceneID,proto3" json:"SceneID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CS_GetBattleHeroInfo) Reset()         { *m = CS_GetBattleHeroInfo{} }
func (m *CS_GetBattleHeroInfo) String() string { return proto.CompactTextString(m) }
func (*CS_GetBattleHeroInfo) ProtoMessage()    {}
func (*CS_GetBattleHeroInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{139}
}
func (m *CS_GetBattleHeroInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CS_GetBattleHeroInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CS_GetBattleHeroInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CS_GetBattleHeroInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CS_GetBattleHeroInfo.Merge(m, src)
}
func (m *CS_GetBattleHeroInfo) XXX_Size() int {
	return m.Size()
}
func (m *CS_GetBattleHeroInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CS_GetBattleHeroInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CS_GetBattleHeroInfo proto.InternalMessageInfo

func (m *CS_GetBattleHeroInfo) GetSceneID() int32 {
	if m != nil {
		return m.SceneID
	}
	return 0
}

//竞技场面板
type SC_GetBattleHeroInfo struct {
	Group1               []*BattleOverPlayerOneInfo `protobuf:"bytes,1,rep,name=Group1,proto3" json:"Group1,omitempty"`
	Group2               []*BattleOverPlayerOneInfo `protobuf:"bytes,2,rep,name=Group2,proto3" json:"Group2,omitempty"`
	WinnerGroup          int32                      `protobuf:"varint,3,opt,name=WinnerGroup,proto3" json:"WinnerGroup,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *SC_GetBattleHeroInfo) Reset()         { *m = SC_GetBattleHeroInfo{} }
func (m *SC_GetBattleHeroInfo) String() string { return proto.CompactTextString(m) }
func (*SC_GetBattleHeroInfo) ProtoMessage()    {}
func (*SC_GetBattleHeroInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{140}
}
func (m *SC_GetBattleHeroInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SC_GetBattleHeroInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SC_GetBattleHeroInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SC_GetBattleHeroInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SC_GetBattleHeroInfo.Merge(m, src)
}
func (m *SC_GetBattleHeroInfo) XXX_Size() int {
	return m.Size()
}
func (m *SC_GetBattleHeroInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SC_GetBattleHeroInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SC_GetBattleHeroInfo proto.InternalMessageInfo

func (m *SC_GetBattleHeroInfo) GetGroup1() []*BattleOverPlayerOneInfo {
	if m != nil {
		return m.Group1
	}
	return nil
}

func (m *SC_GetBattleHeroInfo) GetGroup2() []*BattleOverPlayerOneInfo {
	if m != nil {
		return m.Group2
	}
	return nil
}

func (m *SC_GetBattleHeroInfo) GetWinnerGroup() int32 {
	if m != nil {
		return m.WinnerGroup
	}
	return 0
}

//竞技场面板查看的单个玩家信息
type BattleOverPlayerOneInfo struct {
	Characterid          int32    `protobuf:"varint,1,opt,name=Characterid,proto3" json:"Characterid,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	Typeid               int32    `protobuf:"varint,3,opt,name=Typeid,proto3" json:"Typeid,omitempty"`
	Score                int32    `protobuf:"varint,4,opt,name=Score,proto3" json:"Score,omitempty"`
	KillCount            int32    `protobuf:"varint,5,opt,name=KillCount,proto3" json:"KillCount,omitempty"`
	DeathCount           int32    `protobuf:"varint,6,opt,name=DeathCount,proto3" json:"DeathCount,omitempty"`
	Level                int32    `protobuf:"varint,7,opt,name=Level,proto3" json:"Level,omitempty"`
	EquipItems           []string `protobuf:"bytes,8,rep,name=EquipItems,proto3" json:"EquipItems,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BattleOverPlayerOneInfo) Reset()         { *m = BattleOverPlayerOneInfo{} }
func (m *BattleOverPlayerOneInfo) String() string { return proto.CompactTextString(m) }
func (*BattleOverPlayerOneInfo) ProtoMessage()    {}
func (*BattleOverPlayerOneInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_617aaba9bf0c07c7, []int{141}
}
func (m *BattleOverPlayerOneInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BattleOverPlayerOneInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BattleOverPlayerOneInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BattleOverPlayerOneInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BattleOverPlayerOneInfo.Merge(m, src)
}
func (m *BattleOverPlayerOneInfo) XXX_Size() int {
	return m.Size()
}
func (m *BattleOverPlayerOneInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BattleOverPlayerOneInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BattleOverPlayerOneInfo proto.InternalMessageInfo

func (m *BattleOverPlayerOneInfo) GetCharacterid() int32 {
	if m != nil {
		return m.Characterid
	}
	return 0
}

func (m *BattleOverPlayerOneInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *BattleOverPlayerOneInfo) GetTypeid() int32 {
	if m != nil {
		return m.Typeid
	}
	return 0
}

func (m *BattleOverPlayerOneInfo) GetScore() int32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *BattleOverPlayerOneInfo) GetKillCount() int32 {
	if m != nil {
		return m.KillCount
	}
	return 0
}

func (m *BattleOverPlayerOneInfo) GetDeathCount() int32 {
	if m != nil {
		return m.DeathCount
	}
	return 0
}

func (m *BattleOverPlayerOneInfo) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *BattleOverPlayerOneInfo) GetEquipItems() []string {
	if m != nil {
		return m.EquipItems
	}
	return nil
}

func init() {
	proto.RegisterType((*MsgBase)(nil), "protomsg.MsgBase")
	proto.RegisterType((*MsgRegisterToGate)(nil), "protomsg.MsgRegisterToGate")
	proto.RegisterType((*CS_MsgQuickLogin)(nil), "protomsg.CS_MsgQuickLogin")
	proto.RegisterType((*CS_Login)(nil), "protomsg.CS_Login")
	proto.RegisterType((*CS_SelectCharacter)(nil), "protomsg.CS_SelectCharacter")
	proto.RegisterType((*CS_LodingScene)(nil), "protomsg.CS_LodingScene")
	proto.RegisterType((*CS_LookVedioSucc)(nil), "protomsg.CS_LookVedioSucc")
	proto.RegisterType((*CS_UseAI)(nil), "protomsg.CS_UseAI")
	proto.RegisterType((*SC_NeedLineUp)(nil), "protomsg.SC_NeedLineUp")
	proto.RegisterType((*CS_GetLineUpFrontCount)(nil), "protomsg.CS_GetLineUpFrontCount")
	proto.RegisterType((*SC_GetLineUpFrontCount)(nil), "protomsg.SC_GetLineUpFrontCount")
	proto.RegisterType((*CS_CancelLineUp)(nil), "protomsg.CS_CancelLineUp")
	proto.RegisterType((*UnitEquip)(nil), "protomsg.UnitEquip")
	proto.RegisterType((*UnitBoardDatas)(nil), "protomsg.UnitBoardDatas")
	proto.RegisterType((*SimpleSkillDatas)(nil), "protomsg.SimpleSkillDatas")
	proto.RegisterType((*CS_GetUnitInfo)(nil), "protomsg.CS_GetUnitInfo")
	proto.RegisterType((*CS_GetCharacterSimpleInfo)(nil), "protomsg.CS_GetCharacterSimpleInfo")
	proto.RegisterType((*SC_GetCharacterSimpleInfo)(nil), "protomsg.SC_GetCharacterSimpleInfo")
	proto.RegisterType((*CS_GetItemExtraInfo)(nil), "protomsg.CS_GetItemExtraInfo")
	proto.RegisterType((*SC_GetItemExtraInfo)(nil), "protomsg.SC_GetItemExtraInfo")
	proto.RegisterType((*CS_GetBagInfo)(nil), "protomsg.CS_GetBagInfo")
	proto.RegisterType((*CS_ChangeItemPos)(nil), "protomsg.CS_ChangeItemPos")
	proto.RegisterType((*CS_DestroyItem)(nil), "protomsg.CS_DestroyItem")
	proto.RegisterType((*CS_SystemHuiShouItem)(nil), "protomsg.CS_SystemHuiShouItem")
	proto.RegisterType((*SC_UnitInfo)(nil), "protomsg.SC_UnitInfo")
	proto.RegisterType((*SC_BagInfo)(nil), "protomsg.SC_BagInfo")
	proto.RegisterType((*CS_PlayerUpgradeSkill)(nil), "protomsg.CS_PlayerUpgradeSkill")
	proto.RegisterType((*CS_PlayerMove)(nil), "protomsg.CS_PlayerMove")
	proto.RegisterType((*CS_PlayerAttack)(nil), "protomsg.CS_PlayerAttack")
	proto.RegisterType((*CS_PlayerSkill)(nil), "protomsg.CS_PlayerSkill")
	proto.RegisterType((*CS_ChangeAttackMode)(nil), "protomsg.CS_ChangeAttackMode")
	proto.RegisterType((*CS_OrganizeTeam)(nil), "protomsg.CS_OrganizeTeam")
	proto.RegisterType((*SC_RequestTeam)(nil), "protomsg.SC_RequestTeam")
	proto.RegisterType((*CS_ResponseOrgTeam)(nil), "protomsg.CS_ResponseOrgTeam")
	proto.RegisterType((*CS_OutTeam)(nil), "protomsg.CS_OutTeam")
	proto.RegisterType((*TeamPlayerInfo)(nil), "protomsg.TeamPlayerInfo")
	proto.RegisterType((*SC_UpdateTeamInfo)(nil), "protomsg.SC_UpdateTeamInfo")
	proto.RegisterType((*SC_NoticeWords)(nil), "protomsg.SC_NoticeWords")
	proto.RegisterType((*SkillDatas)(nil), "protomsg.SkillDatas")
	proto.RegisterType((*BuffDatas)(nil), "protomsg.BuffDatas")
	proto.RegisterType((*UnitDatas)(nil), "protomsg.UnitDatas")
	proto.RegisterType((*BulletDatas)(nil), "protomsg.BulletDatas")
	proto.RegisterType((*SceneItemDatas)(nil), "protomsg.SceneItemDatas")
	proto.RegisterType((*HaloDatas)(nil), "protomsg.HaloDatas")
	proto.RegisterType((*MsgUserEnterScene)(nil), "protomsg.MsgUserEnterScene")
	proto.RegisterType((*MsgPlayerHurt)(nil), "protomsg.MsgPlayerHurt")
	proto.RegisterType((*SC_Update)(nil), "protomsg.SC_Update")
	proto.RegisterType((*SC_NewScene)(nil), "protomsg.SC_NewScene")
	proto.RegisterType((*CharacterBaseDatas)(nil), "protomsg.CharacterBaseDatas")
	proto.RegisterType((*SC_Logined)(nil), "protomsg.SC_Logined")
	proto.RegisterType((*SC_SelectCharacterResult)(nil), "protomsg.SC_SelectCharacterResult")
	proto.RegisterType((*CommodityDataProto)(nil), "protomsg.CommodityDataProto")
	proto.RegisterType((*CS_GetStoreData)(nil), "protomsg.CS_GetStoreData")
	proto.RegisterType((*SC_StoreData)(nil), "protomsg.SC_StoreData")
	proto.RegisterType((*CS_BuyCommodity)(nil), "protomsg.CS_BuyCommodity")
	proto.RegisterType((*CS_QuickRevive)(nil), "protomsg.CS_QuickRevive")
	proto.RegisterType((*CC_Disconnect)(nil), "protomsg.CC_Disconnect")
	proto.RegisterType((*SC_ChatInfo)(nil), "protomsg.SC_ChatInfo")
	proto.RegisterType((*CS_ChatInfo)(nil), "protomsg.CS_ChatInfo")
	proto.RegisterType((*CS_AddFriendRequest)(nil), "protomsg.CS_AddFriendRequest")
	proto.RegisterType((*CS_RemoveFriend)(nil), "protomsg.CS_RemoveFriend")
	proto.RegisterType((*CS_AddFriendResponse)(nil), "protomsg.CS_AddFriendResponse")
	proto.RegisterType((*FriendInfoMsg)(nil), "protomsg.FriendInfoMsg")
	proto.RegisterType((*CS_GetFriendsList)(nil), "protomsg.CS_GetFriendsList")
	proto.RegisterType((*SC_GetFriendsList)(nil), "protomsg.SC_GetFriendsList")
	proto.RegisterType((*MailShortInfoMsg)(nil), "protomsg.MailShortInfoMsg")
	proto.RegisterType((*MailRewards)(nil), "protomsg.MailRewards")
	proto.RegisterType((*CS_GetMailsList)(nil), "protomsg.CS_GetMailsList")
	proto.RegisterType((*SC_GetMailsList)(nil), "protomsg.SC_GetMailsList")
	proto.RegisterType((*CS_GetMailInfo)(nil), "protomsg.CS_GetMailInfo")
	proto.RegisterType((*SC_GetMailInfo)(nil), "protomsg.SC_GetMailInfo")
	proto.RegisterType((*CS_GetMailRewards)(nil), "protomsg.CS_GetMailRewards")
	proto.RegisterType((*SC_GetMailRewards)(nil), "protomsg.SC_GetMailRewards")
	proto.RegisterType((*CS_DeleteNoRewardMails)(nil), "protomsg.CS_DeleteNoRewardMails")
	proto.RegisterType((*CS_GetExchangeShortCommoditys)(nil), "protomsg.CS_GetExchangeShortCommoditys")
	proto.RegisterType((*ExchangeShortCommodityData)(nil), "protomsg.ExchangeShortCommodityData")
	proto.RegisterType((*SC_GetExchangeShortCommoditys)(nil), "protomsg.SC_GetExchangeShortCommoditys")
	proto.RegisterType((*CS_GetExchangeDetailedCommoditys)(nil), "protomsg.CS_GetExchangeDetailedCommoditys")
	proto.RegisterType((*ExchangeDetailedCommodityData)(nil), "protomsg.ExchangeDetailedCommodityData")
	proto.RegisterType((*SC_GetExchangeDetailedCommoditys)(nil), "protomsg.SC_GetExchangeDetailedCommoditys")
	proto.RegisterType((*CS_BuyExchangeCommodity)(nil), "protomsg.CS_BuyExchangeCommodity")
	proto.RegisterType((*CS_ShelfExchangeCommodity)(nil), "protomsg.CS_ShelfExchangeCommodity")
	proto.RegisterType((*CS_UnShelfExchangeCommodity)(nil), "protomsg.CS_UnShelfExchangeCommodity")
	proto.RegisterType((*CS_GetSellUIInfo)(nil), "protomsg.CS_GetSellUIInfo")
	proto.RegisterType((*SC_GetSellUIInfo)(nil), "protomsg.SC_GetSellUIInfo")
	proto.RegisterType((*CS_GetWorldAuctionItems)(nil), "protomsg.CS_GetWorldAuctionItems")
	proto.RegisterType((*SC_GetWorldAuctionItems)(nil), "protomsg.SC_GetWorldAuctionItems")
	proto.RegisterType((*CS_NewPriceWorldAuctionItem)(nil), "protomsg.CS_NewPriceWorldAuctionItem")
	proto.RegisterType((*CS_GetAllGuildsInfo)(nil), "protomsg.CS_GetAllGuildsInfo")
	proto.RegisterType((*GuildShortInfo)(nil), "protomsg.GuildShortInfo")
	proto.RegisterType((*SC_GetAllGuildsInfo)(nil), "protomsg.SC_GetAllGuildsInfo")
	proto.RegisterType((*CS_CreateGuild)(nil), "protomsg.CS_CreateGuild")
	proto.RegisterType((*CS_JoinGuild)(nil), "protomsg.CS_JoinGuild")
	proto.RegisterType((*CS_GetGuildInfo)(nil), "protomsg.CS_GetGuildInfo")
	proto.RegisterType((*SC_GetGuildInfo)(nil), "protomsg.SC_GetGuildInfo")
	proto.RegisterType((*GuildChaInfo)(nil), "protomsg.GuildChaInfo")
	proto.RegisterType((*CS_GetJoinGuildPlayer)(nil), "protomsg.CS_GetJoinGuildPlayer")
	proto.RegisterType((*SC_GetJoinGuildPlayer)(nil), "protomsg.SC_GetJoinGuildPlayer")
	proto.RegisterType((*CS_ResponseJoinGuildPlayer)(nil), "protomsg.CS_ResponseJoinGuildPlayer")
	proto.RegisterType((*CS_DeleteGuildPlayer)(nil), "protomsg.CS_DeleteGuildPlayer")
	proto.RegisterType((*CS_GuildOperate)(nil), "protomsg.CS_GuildOperate")
	proto.RegisterType((*CS_ChangePost)(nil), "protomsg.CS_ChangePost")
	proto.RegisterType((*CS_EditorGuildNotice)(nil), "protomsg.CS_EditorGuildNotice")
	proto.RegisterType((*CS_GetAuctionItems)(nil), "protomsg.CS_GetAuctionItems")
	proto.RegisterType((*SC_GetAuctionItems)(nil), "protomsg.SC_GetAuctionItems")
	proto.RegisterType((*AuctionItem)(nil), "protomsg.AuctionItem")
	proto.RegisterType((*CS_NewPriceAuctionItem)(nil), "protomsg.CS_NewPriceAuctionItem")
	proto.RegisterType((*CS_GetGuildRankInfo)(nil), "protomsg.CS_GetGuildRankInfo")
	proto.RegisterType((*SC_GetGuildRankInfo)(nil), "protomsg.SC_GetGuildRankInfo")
	proto.RegisterType((*CS_GetGuildRankBattleInfo)(nil), "protomsg.CS_GetGuildRankBattleInfo")
	proto.RegisterType((*GuildRankBattleChaInfo)(nil), "protomsg.GuildRankBattleChaInfo")
	proto.RegisterType((*SC_GetGuildRankBattleInfo)(nil), "protomsg.SC_GetGuildRankBattleInfo")
	proto.RegisterType((*CS_GetGuildMapsInfo)(nil), "protomsg.CS_GetGuildMapsInfo")
	proto.RegisterType((*SC_GetGuildMapsInfo)(nil), "protomsg.SC_GetGuildMapsInfo")
	proto.RegisterType((*GuildMapInfo)(nil), "protomsg.GuildMapInfo")
	proto.RegisterType((*CS_GotoGuildMap)(nil), "protomsg.CS_GotoGuildMap")
	proto.RegisterType((*SC_GotoGuildMap)(nil), "protomsg.SC_GotoGuildMap")
	proto.RegisterType((*CS_GetActivityMapsInfo)(nil), "protomsg.CS_GetActivityMapsInfo")
	proto.RegisterType((*SC_GetActivityMapsInfo)(nil), "protomsg.SC_GetActivityMapsInfo")
	proto.RegisterType((*ActivityMapInfo)(nil), "protomsg.ActivityMapInfo")
	proto.RegisterType((*CS_GetMapInfo)(nil), "protomsg.CS_GetMapInfo")
	proto.RegisterType((*SC_GetMapInfo)(nil), "protomsg.SC_GetMapInfo")
	proto.RegisterType((*CS_GotoActivityMap)(nil), "protomsg.CS_GotoActivityMap")
	proto.RegisterType((*SC_GotoActivityMap)(nil), "protomsg.SC_GotoActivityMap")
	proto.RegisterType((*CS_GetDuoBaoInfo)(nil), "protomsg.CS_GetDuoBaoInfo")
	proto.RegisterType((*SC_GetDuoBaoInfo)(nil), "protomsg.SC_GetDuoBaoInfo")
	proto.RegisterType((*CS_GetCopyMapsInfo)(nil), "protomsg.CS_GetCopyMapsInfo")
	proto.RegisterType((*SC_GetCopyMapsInfo)(nil), "protomsg.SC_GetCopyMapsInfo")
	proto.RegisterType((*CopyMapInfo)(nil), "protomsg.CopyMapInfo")
	proto.RegisterType((*CS_CopyMapPiPei)(nil), "protomsg.CS_CopyMapPiPei")
	proto.RegisterType((*CS_CopyMapCancel)(nil), "protomsg.CS_CopyMapCancel")
	proto.RegisterType((*SC_ShowPiPeiInfo)(nil), "protomsg.SC_ShowPiPeiInfo")
	proto.RegisterType((*CS_GetBattleRankInfo)(nil), "protomsg.CS_GetBattleRankInfo")
	proto.RegisterType((*CS_GetBattleMapInfo)(nil), "protomsg.CS_GetBattleMapInfo")
	proto.RegisterType((*SC_GetBattleRankInfo)(nil), "protomsg.SC_GetBattleRankInfo")
	proto.RegisterType((*SC_GetBattleMapInfo)(nil), "protomsg.SC_GetBattleMapInfo")
	proto.RegisterType((*BattleRankOneInfo)(nil), "protomsg.BattleRankOneInfo")
	proto.RegisterType((*CS_BattlePiPei)(nil), "protomsg.CS_BattlePiPei")
	proto.RegisterType((*CS_BattleCancel)(nil), "protomsg.CS_BattleCancel")
	proto.RegisterType((*CS_GetBattleHeroInfo)(nil), "protomsg.CS_GetBattleHeroInfo")
	proto.RegisterType((*SC_GetBattleHeroInfo)(nil), "protomsg.SC_GetBattleHeroInfo")
	proto.RegisterType((*BattleOverPlayerOneInfo)(nil), "protomsg.BattleOverPlayerOneInfo")
}

func init() { proto.RegisterFile("protobuf/msg.proto", fileDescriptor_617aaba9bf0c07c7) }

var fileDescriptor_617aaba9bf0c07c7 = []byte{
	// 5366 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5b, 0xcd, 0x93, 0x1c, 0x47,
	0x56, 0xa7, 0x7a, 0xa6, 0xe7, 0xe3, 0xcd, 0x87, 0xa5, 0xd2, 0x57, 0x5b, 0xb6, 0x67, 0xc7, 0x65,
	0xd9, 0x96, 0xed, 0xb5, 0x24, 0x0b, 0xef, 0xa7, 0x17, 0x13, 0x33, 0xdd, 0xa3, 0x51, 0x83, 0x66,
	0xd4, 0xae, 0xd6, 0x58, 0x92, 0x03, 0x62, 0x28, 0x75, 0xa5, 0xba, 0x2b, 0xd4, 0x5d, 0xd5, 0x5b,
	0x55, 0x3d, 0xa3, 0xf1, 0x01, 0xb8, 0x2c, 0x04, 0x01, 0xc1, 0x81, 0x0d, 0x22, 0x36, 0xd8, 0x23,
	0x07, 0x6e, 0x1c, 0xf8, 0x0f, 0xf6, 0x02, 0x5c, 0x88, 0x20, 0xf8, 0x0b, 0x58, 0x73, 0xe1, 0xc0,
	0x01, 0x38, 0x70, 0x23, 0x82, 0x78, 0xef, 0x65, 0x66, 0x65, 0x56, 0x57, 0xcf, 0xc8, 0x62, 0x37,
	0xe0, 0xd4, 0xf5, 0x7e, 0xf9, 0xf2, 0xeb, 0xe5, 0xcb, 0xf7, 0x5e, 0xbe, 0xcc, 0x06, 0x77, 0x9c,
	0x26, 0x79, 0xf2, 0x64, 0xf2, 0xf4, 0xe6, 0x28, 0xeb, 0xdf, 0x20, 0xc2, 0x5d, 0xa2, 0x9f, 0x51,
	0xd6, 0xf7, 0x7e, 0xe4, 0xc0, 0xe2, 0x5e, 0xd6, 0xdf, 0x0e, 0x32, 0xe1, 0x5e, 0x85, 0xa5, 0xbd,
	0x24, 0x14, 0x0f, 0x4e, 0xc6, 0xa2, 0xe1, 0x6c, 0x3a, 0xd7, 0x97, 0x7d, 0x4d, 0xbb, 0xe7, 0x60,
	0xee, 0x20, 0x0a, 0x1b, 0xb5, 0x4d, 0xe7, 0x7a, 0xdd, 0xc7, 0x4f, 0xb7, 0x41, 0x15, 0x89, 0x79,
	0x8e, 0x98, 0x15, 0xe9, 0xbe, 0x0e, 0xcb, 0xcd, 0x24, 0x8e, 0x45, 0x2f, 0x6f, 0x87, 0x8d, 0x79,
	0xaa, 0x51, 0x00, 0xee, 0x45, 0xa8, 0xb7, 0x82, 0x3c, 0xc8, 0x1a, 0xf5, 0x4d, 0xe7, 0xfa, 0xaa,
	0xcf, 0x84, 0x77, 0x13, 0xce, 0xef, 0x65, 0x7d, 0x5f, 0xf4, 0xa3, 0x2c, 0x17, 0xe9, 0x83, 0x64,
	0x37, 0xc8, 0x4f, 0x1d, 0x90, 0xf7, 0x3b, 0x70, 0xae, 0xd9, 0x3d, 0xdc, 0xcb, 0xfa, 0x9f, 0x4d,
	0xa2, 0xde, 0xb3, 0x7b, 0x49, 0x3f, 0x8a, 0x91, 0xbf, 0x33, 0x0c, 0xf2, 0xa7, 0x49, 0x3a, 0x52,
	0xfc, 0x8a, 0xc6, 0x41, 0xed, 0x05, 0xbd, 0x41, 0x14, 0x0b, 0x39, 0x8d, 0x65, 0xbf, 0x00, 0x5c,
	0x17, 0xe6, 0xf7, 0x83, 0x91, 0x9a, 0x09, 0x7d, 0x7b, 0x3f, 0x71, 0x60, 0xa9, 0xd9, 0x3d, 0xe4,
	0xa6, 0x37, 0x61, 0xa5, 0x33, 0x48, 0x62, 0x11, 0x4f, 0x46, 0x4f, 0x44, 0x2a, 0x5b, 0x37, 0x21,
	0xab, 0xf3, 0xda, 0x69, 0x9d, 0xcf, 0x95, 0x3b, 0x7f, 0x0d, 0x96, 0x1f, 0x8a, 0xde, 0x20, 0xc8,
	0x0f, 0x23, 0x96, 0xd7, 0xb2, 0xbf, 0xc4, 0x40, 0x3b, 0x74, 0x2f, 0x40, 0xfd, 0xb3, 0xcf, 0xb0,
	0xa0, 0xce, 0x43, 0xfb, 0xec, 0xb3, 0x76, 0xe8, 0xfd, 0x16, 0xb8, 0xcd, 0xee, 0x61, 0x57, 0x0c,
	0x45, 0x2f, 0x6f, 0x0e, 0x82, 0x34, 0xe8, 0xe5, 0x22, 0x75, 0xef, 0xc0, 0x2b, 0x25, 0x88, 0xc6,
	0xb9, 0x72, 0xfb, 0xf5, 0x1b, 0x6a, 0xbd, 0x6f, 0xe8, 0x22, 0x5c, 0x71, 0x12, 0xbd, 0x5f, 0xae,
	0xe4, 0xbd, 0x0f, 0xeb, 0x34, 0xef, 0x30, 0x8a, 0xfb, 0xdd, 0x9e, 0x88, 0x05, 0xae, 0x35, 0x7d,
	0xb4, 0x5b, 0xd4, 0x62, 0xdd, 0x57, 0xa4, 0xe7, 0xd1, 0x32, 0xdc, 0x4b, 0x92, 0x67, 0x9f, 0x8b,
	0x30, 0x4a, 0xba, 0x93, 0x5e, 0xcf, 0x5d, 0x87, 0x9a, 0x66, 0xac, 0xb5, 0x5b, 0xde, 0x06, 0xc9,
	0xf1, 0x20, 0x13, 0x5b, 0x6d, 0x14, 0xf4, 0x56, 0x3b, 0x0a, 0x65, 0x29, 0x7d, 0x7b, 0x37, 0x61,
	0xad, 0xdb, 0x3c, 0xdc, 0x17, 0x22, 0xbc, 0x17, 0xc5, 0xe2, 0x60, 0xec, 0x6e, 0x00, 0xdc, 0x49,
	0x93, 0x38, 0x6f, 0x26, 0x93, 0x38, 0x97, 0xac, 0x06, 0xe2, 0x7d, 0x0c, 0x97, 0x9b, 0xdd, 0xc3,
	0x5d, 0x91, 0x33, 0x7f, 0x51, 0x82, 0x8b, 0xb0, 0x9f, 0xe4, 0x83, 0x28, 0xee, 0x7f, 0x24, 0xeb,
	0x69, 0xda, 0xfb, 0x2e, 0x5c, 0xee, 0x36, 0x2b, 0x6b, 0x9d, 0xd5, 0xdf, 0x07, 0xf0, 0x4a, 0xb3,
	0x7b, 0xd8, 0x0c, 0xe2, 0x9e, 0x18, 0xca, 0x21, 0x36, 0x60, 0x51, 0x36, 0xac, 0x24, 0x22, 0x49,
	0xef, 0xf7, 0x60, 0xf9, 0x20, 0x8e, 0xf2, 0x9d, 0x1f, 0x4e, 0xa2, 0x31, 0x6e, 0x9b, 0x4e, 0x92,
	0x49, 0x16, 0xfc, 0x74, 0x2f, 0xc3, 0xc2, 0x83, 0x93, 0x71, 0xd8, 0x6e, 0xc9, 0xbd, 0x24, 0x29,
	0xdc, 0x16, 0xf7, 0xc4, 0x91, 0x18, 0x92, 0x7a, 0xd4, 0x7d, 0x26, 0x50, 0x71, 0x3a, 0x69, 0xd4,
	0xe3, 0x2d, 0x20, 0xb7, 0x92, 0x06, 0xb0, 0x0e, 0x11, 0xa4, 0x1b, 0x75, 0x9f, 0x09, 0xef, 0x67,
	0x00, 0xeb, 0x38, 0x82, 0xed, 0x24, 0x48, 0x43, 0x5a, 0xe2, 0xf2, 0x8a, 0x68, 0x75, 0xaf, 0x15,
	0xea, 0xee, 0x7e, 0x13, 0xce, 0x6f, 0xe5, 0x79, 0x1a, 0x3d, 0x99, 0xe4, 0xa2, 0x9b, 0xa7, 0x22,
	0xee, 0xe7, 0x03, 0x1a, 0x4c, 0xcd, 0x9f, 0x2e, 0x70, 0xdf, 0x87, 0x73, 0x1a, 0xdc, 0xea, 0x47,
	0xc3, 0x28, 0x3f, 0xa1, 0xf1, 0xd5, 0xfc, 0x29, 0xdc, 0xfd, 0x18, 0x2e, 0x69, 0xac, 0x1d, 0xe7,
	0x62, 0x38, 0x8c, 0xfa, 0x22, 0x96, 0xc3, 0xae, 0xf9, 0xd5, 0x85, 0x28, 0xa8, 0xad, 0x3c, 0x0f,
	0x7a, 0xcf, 0x1a, 0x0b, 0x2c, 0x28, 0xa6, 0x70, 0x27, 0xf2, 0x57, 0x77, 0x2c, 0x44, 0xd8, 0x58,
	0xa4, 0x36, 0x4c, 0xa8, 0xe0, 0xf0, 0x83, 0xb8, 0x2f, 0x1a, 0x4b, 0x26, 0x07, 0x41, 0xb4, 0x1f,
	0x93, 0x23, 0xc1, 0x2d, 0x2c, 0x53, 0x79, 0x01, 0xa0, 0x3a, 0xec, 0x05, 0xfd, 0xa8, 0xd7, 0xed,
	0x05, 0x43, 0xd1, 0x00, 0x2a, 0x36, 0x10, 0x32, 0x4b, 0x1d, 0x5f, 0xf4, 0x83, 0x28, 0x6e, 0xac,
	0x50, 0xa9, 0xa6, 0xdd, 0x6b, 0xb0, 0xd6, 0x19, 0x9c, 0x64, 0x51, 0x2f, 0x18, 0x6e, 0x8d, 0x82,
	0x24, 0x6d, 0xac, 0x12, 0x83, 0x0d, 0xba, 0xef, 0xc0, 0xba, 0x02, 0x7c, 0x91, 0x45, 0x59, 0xde,
	0x58, 0x23, 0xb6, 0x12, 0xaa, 0x47, 0xc2, 0x4d, 0xad, 0x1b, 0x23, 0xe1, 0x76, 0x36, 0x61, 0xa5,
	0x9b, 0x07, 0xf9, 0x24, 0x63, 0x86, 0x57, 0x78, 0xa6, 0x06, 0x44, 0xd6, 0x36, 0x09, 0xfb, 0xa2,
	0x71, 0x8e, 0xca, 0x98, 0xc0, 0x19, 0xdc, 0x55, 0x33, 0x38, 0xcf, 0x33, 0x50, 0xb4, 0x7b, 0x1b,
	0x2e, 0xfa, 0xc1, 0xf1, 0xb4, 0x2a, 0xb8, 0xc4, 0x57, 0x59, 0xe6, 0xde, 0x82, 0x0b, 0x26, 0xae,
	0x14, 0xe2, 0x02, 0x55, 0xa9, 0x2a, 0x72, 0xbf, 0x0f, 0x0d, 0x13, 0xb6, 0xd4, 0xe2, 0x22, 0x55,
	0x9b, 0x59, 0x8e, 0xab, 0xc7, 0x65, 0xa8, 0x1c, 0x97, 0x78, 0x53, 0x68, 0x00, 0x65, 0xab, 0x09,
	0x5e, 0xe0, 0xcb, 0x2c, 0x5b, 0x1b, 0xb5, 0xf8, 0x58, 0x51, 0xae, 0x94, 0xf8, 0x58, 0x57, 0x3c,
	0x58, 0xf5, 0x83, 0xe3, 0x42, 0x5d, 0x1a, 0xc4, 0x65, 0x61, 0xb8, 0xea, 0x48, 0x17, 0x4a, 0xf3,
	0x2a, 0xaf, 0xba, 0x05, 0xe2, 0x6a, 0x21, 0xa0, 0x04, 0x7f, 0x95, 0x57, 0xcb, 0x80, 0x70, 0x57,
	0xf9, 0xc1, 0xb1, 0xad, 0x40, 0xaf, 0xf1, 0xae, 0x2a, 0xe3, 0xb8, 0x5f, 0x0d, 0x4c, 0xaa, 0xd1,
	0xeb, 0xbc, 0x5f, 0xa7, 0x0a, 0xcc, 0x11, 0x72, 0xb3, 0x6f, 0xd8, 0x23, 0xd4, 0x7a, 0xe9, 0x07,
	0xc7, 0xa6, 0x4a, 0x6d, 0x68, 0x99, 0x98, 0x5a, 0x75, 0x15, 0x96, 0xfc, 0xe0, 0x98, 0x15, 0xeb,
	0x1b, 0xac, 0x3f, 0x8a, 0x96, 0xb3, 0xd4, 0xea, 0xb5, 0xa9, 0x67, 0x79, 0xd7, 0x98, 0xa5, 0x5e,
	0xd8, 0x4e, 0x1a, 0x8d, 0x82, 0xf4, 0xa4, 0xf1, 0x26, 0x2d, 0xe3, 0x14, 0x8e, 0x6b, 0xdd, 0x4a,
	0x93, 0x71, 0x3b, 0x17, 0xa3, 0xac, 0xe1, 0xb1, 0xe7, 0xd4, 0x00, 0xc9, 0x4b, 0x8c, 0x82, 0x28,
	0xde, 0x79, 0x3e, 0x16, 0x69, 0x44, 0xda, 0xf3, 0x16, 0xb7, 0x54, 0xc6, 0xdd, 0x0f, 0x60, 0x81,
	0x6c, 0x72, 0xd6, 0xb8, 0xb6, 0x39, 0x77, 0x7d, 0xe5, 0xf6, 0x85, 0xc2, 0x29, 0x6a, 0x7b, 0xed,
	0x4b, 0x16, 0xef, 0x73, 0x38, 0xd7, 0x8d, 0x46, 0xe3, 0xa1, 0xe8, 0x3e, 0x8b, 0x86, 0x43, 0x36,
	0xa2, 0x6c, 0xb9, 0x0b, 0x1f, 0x28, 0xa9, 0xc2, 0x72, 0xd7, 0x4c, 0xcb, 0x7d, 0x11, 0xea, 0xed,
	0x38, 0x14, 0xcf, 0x95, 0x6d, 0x26, 0xc2, 0xbb, 0x4e, 0xae, 0x75, 0x57, 0xe4, 0xd8, 0x65, 0x3b,
	0x7e, 0x9a, 0x60, 0xab, 0xf4, 0xad, 0x5b, 0x65, 0xca, 0xfb, 0x35, 0x78, 0x95, 0x39, 0xb5, 0x5f,
	0xe6, 0x01, 0x51, 0xa5, 0x4d, 0x58, 0xd1, 0xb0, 0xae, 0x69, 0x42, 0xde, 0xcf, 0x1d, 0x78, 0x95,
	0xbd, 0xdd, 0x4b, 0xd5, 0xaf, 0xf4, 0x10, 0xd5, 0x2e, 0xca, 0x0c, 0xd2, 0xe6, 0x4b, 0x51, 0xe3,
	0x06, 0x00, 0x09, 0x94, 0x97, 0xaf, 0xbe, 0x39, 0x77, 0x7d, 0xd9, 0x37, 0x10, 0x9c, 0x3c, 0x09,
	0x38, 0x23, 0x1b, 0xbf, 0xec, 0x4b, 0x0a, 0xb5, 0xf5, 0x5e, 0x90, 0xe5, 0x14, 0x7a, 0xb5, 0x82,
	0x5c, 0x90, 0x95, 0x5f, 0xf6, 0x6d, 0xd0, 0xfb, 0x10, 0x2e, 0xb0, 0x88, 0xb0, 0xb1, 0x9d, 0xe7,
	0x79, 0x1a, 0x28, 0x89, 0xd2, 0xca, 0x84, 0xd6, 0x3a, 0x85, 0xde, 0x4f, 0x1d, 0xb8, 0xc0, 0x22,
	0x79, 0x21, 0x7e, 0x54, 0xbd, 0x9d, 0xe7, 0x3d, 0x31, 0xce, 0xa3, 0x24, 0x96, 0x6b, 0x5b, 0x00,
	0xb8, 0x55, 0x34, 0xd1, 0x09, 0xd2, 0x60, 0x24, 0xe3, 0xba, 0x12, 0x4a, 0x7c, 0x38, 0x61, 0x0a,
	0x6f, 0x48, 0x7a, 0xec, 0xc6, 0x4b, 0xa8, 0xf7, 0x2e, 0xac, 0xf1, 0x64, 0xb6, 0x83, 0xfe, 0xa9,
	0x8a, 0xf1, 0x25, 0x45, 0x5c, 0xcd, 0x01, 0x1a, 0x27, 0x9c, 0x88, 0x0c, 0x2a, 0xba, 0x69, 0xaf,
	0x88, 0x34, 0x24, 0x85, 0x51, 0x4a, 0x4b, 0x64, 0x39, 0x16, 0xf0, 0x04, 0x14, 0x49, 0x11, 0x5d,
	0xda, 0xd3, 0xd1, 0x3b, 0x46, 0x74, 0x4c, 0xe2, 0x7a, 0x22, 0x93, 0x11, 0x71, 0x68, 0x5a, 0xaa,
	0x2f, 0x92, 0x69, 0x72, 0x82, 0x9d, 0xcf, 0xea, 0xd9, 0xbb, 0x01, 0x17, 0x31, 0x42, 0x3d, 0xc9,
	0x72, 0x31, 0xba, 0x3b, 0x89, 0xba, 0x83, 0x64, 0x72, 0x2a, 0x7f, 0x13, 0x56, 0xba, 0xcd, 0x43,
	0xbd, 0x2b, 0x3e, 0x86, 0x25, 0xfc, 0xc6, 0x8d, 0x27, 0x63, 0xd8, 0x86, 0xbd, 0x5d, 0x8b, 0xe0,
	0xc6, 0xd7, 0x9c, 0xde, 0xf7, 0x00, 0xba, 0xcd, 0x43, 0x25, 0xc0, 0x62, 0xc3, 0x3b, 0x67, 0x6f,
	0xf8, 0x9b, 0x70, 0xa9, 0xd9, 0x3d, 0xec, 0x0c, 0x83, 0x13, 0x91, 0x1e, 0x8c, 0xfb, 0x69, 0x10,
	0xf2, 0xd6, 0x9f, 0xb5, 0xeb, 0xbd, 0x87, 0xb4, 0x5e, 0x5c, 0x01, 0x1d, 0x01, 0x86, 0x7a, 0xed,
	0x16, 0xf7, 0x55, 0xf7, 0xf1, 0xd3, 0x5d, 0x05, 0xe7, 0x11, 0xc9, 0xbd, 0xe6, 0x3b, 0x8f, 0x90,
	0x7a, 0x2c, 0xe3, 0x29, 0xe7, 0x31, 0xca, 0xbf, 0x9d, 0x75, 0xf3, 0x20, 0xcd, 0x49, 0xc8, 0x4b,
	0xbe, 0x22, 0xbd, 0x5d, 0x0a, 0x36, 0xb9, 0x61, 0xe9, 0xd2, 0xa6, 0x9b, 0xf6, 0x60, 0xf5, 0x41,
	0x90, 0xf6, 0xa5, 0x1d, 0x51, 0xb1, 0xa4, 0x85, 0x79, 0x5f, 0xd2, 0x62, 0x71, 0x43, 0x3c, 0x97,
	0x72, 0x18, 0x88, 0x4a, 0x80, 0x05, 0xba, 0x01, 0x45, 0xf2, 0xd0, 0xe7, 0xac, 0xa1, 0xcf, 0xab,
	0xa1, 0x97, 0xfb, 0xae, 0x57, 0xf4, 0xfd, 0x2d, 0xda, 0x9a, 0xac, 0xa4, 0x3c, 0x09, 0xb4, 0x09,
	0x68, 0x0f, 0x0a, 0x4a, 0x05, 0xda, 0x05, 0xe2, 0xed, 0xd0, 0xdc, 0xef, 0xa7, 0xfd, 0x20, 0x8e,
	0xbe, 0x14, 0x0f, 0x44, 0x30, 0xc2, 0x31, 0xf2, 0x14, 0x54, 0x40, 0xaf, 0xc8, 0xa2, 0xe4, 0xb6,
	0x1a, 0xbd, 0x24, 0xbd, 0xbf, 0x71, 0x60, 0xbd, 0xdb, 0x3c, 0xf4, 0xc5, 0x0f, 0x27, 0xa8, 0xb9,
	0xd8, 0x8c, 0x07, 0xab, 0xa8, 0x69, 0xbc, 0xbe, 0x5a, 0x08, 0x16, 0x26, 0xf7, 0x84, 0x61, 0xf6,
	0x14, 0x89, 0xf6, 0xa8, 0x9b, 0xf6, 0x70, 0x6e, 0x52, 0x17, 0x78, 0xcf, 0xd8, 0x20, 0xee, 0x9c,
	0x6e, 0xda, 0x33, 0x37, 0xb9, 0xa6, 0xc9, 0x2b, 0xca, 0xe1, 0xe0, 0xc6, 0x62, 0x99, 0x99, 0x90,
	0x97, 0xd3, 0x99, 0xce, 0x17, 0xd9, 0x38, 0x89, 0x33, 0x71, 0x3f, 0xed, 0x7f, 0x9d, 0x71, 0xb7,
	0xb3, 0xad, 0x7e, 0x2a, 0x84, 0x12, 0x84, 0x24, 0xcb, 0xbd, 0xce, 0x4d, 0xf7, 0x7a, 0x0b, 0x00,
	0x25, 0x3e, 0xd1, 0x52, 0xba, 0x3f, 0xc9, 0xa7, 0x7a, 0x33, 0x31, 0xef, 0xcf, 0x1c, 0x58, 0x47,
	0x66, 0x46, 0x68, 0xa7, 0x9d, 0x83, 0xb9, 0x82, 0x1b, 0x3f, 0x2b, 0xdd, 0xc7, 0x3a, 0xd4, 0xee,
	0x76, 0xe4, 0x18, 0x6a, 0x77, 0x3b, 0x48, 0xef, 0x75, 0xa4, 0xa0, 0x6a, 0x7b, 0x1d, 0x74, 0x2f,
	0x7b, 0xc1, 0xf3, 0xbb, 0x1d, 0xe5, 0x31, 0x89, 0x90, 0xe8, 0x5e, 0x47, 0x9e, 0x02, 0x98, 0x90,
	0x9a, 0xbc, 0xa8, 0x8f, 0x98, 0xc7, 0x70, 0x1e, 0xcd, 0xc7, 0x38, 0x0c, 0x72, 0x52, 0x1b, 0x6d,
	0xd8, 0xf1, 0xbb, 0xd8, 0xba, 0x44, 0x51, 0xe6, 0x22, 0x88, 0xe2, 0x83, 0x42, 0xed, 0x25, 0xe9,
	0xde, 0x82, 0x85, 0x07, 0x1d, 0xac, 0xdb, 0x98, 0x23, 0x93, 0x61, 0x18, 0x1d, 0x7b, 0xca, 0xbe,
	0xe4, 0xf3, 0xbe, 0x4d, 0x9a, 0xb6, 0x9f, 0xe4, 0x51, 0x4f, 0x3c, 0x4c, 0xd2, 0x70, 0x76, 0x98,
	0xb0, 0x0a, 0x4e, 0xa7, 0x51, 0x23, 0x17, 0xe8, 0x74, 0xbc, 0x7f, 0xaa, 0x03, 0xbc, 0x74, 0x6c,
	0x81, 0x21, 0x29, 0x85, 0x37, 0xcd, 0xd6, 0x83, 0x48, 0x66, 0x2d, 0x30, 0x24, 0x35, 0x30, 0xdc,
	0x6a, 0xcd, 0x20, 0x96, 0xa6, 0x4c, 0x4a, 0xd9, 0x40, 0xaa, 0xe3, 0x13, 0x54, 0xe1, 0x66, 0x20,
	0xb5, 0x85, 0x05, 0xae, 0x69, 0xf4, 0x64, 0xf4, 0x4d, 0xfb, 0x9c, 0x38, 0x58, 0xfe, 0x25, 0x14,
	0xf9, 0x68, 0x53, 0x30, 0x22, 0x82, 0x11, 0x9d, 0xc0, 0xea, 0x7e, 0x09, 0xb5, 0xf9, 0x9a, 0xc1,
	0x68, 0x4c, 0x27, 0x31, 0x8b, 0x0f, 0x51, 0x0c, 0x74, 0xf7, 0x93, 0x66, 0x90, 0x0a, 0x0a, 0x54,
	0xdb, 0xa3, 0xd1, 0x24, 0xe6, 0x53, 0x59, 0xdd, 0x9f, 0x2e, 0xa0, 0xe4, 0x53, 0x90, 0xe5, 0x1c,
	0xd1, 0xf3, 0xe9, 0xac, 0x00, 0x68, 0x7e, 0x49, 0x32, 0x0c, 0x93, 0xe3, 0x58, 0x9e, 0xcc, 0x34,
	0x8d, 0x35, 0xef, 0x4e, 0x52, 0x59, 0x93, 0xcf, 0x63, 0x05, 0x40, 0x61, 0x4e, 0x10, 0x07, 0xcd,
	0x24, 0xcb, 0xe9, 0x20, 0x56, 0xf7, 0x35, 0x2d, 0x03, 0xda, 0xa0, 0xf7, 0x6c, 0x6b, 0x92, 0x27,
	0x5b, 0xbd, 0x3c, 0x3a, 0x12, 0x74, 0x16, 0xe3, 0x80, 0xd6, 0xc2, 0x51, 0xf9, 0x3e, 0x8f, 0xb2,
	0xe8, 0xc9, 0x90, 0x8f, 0x64, 0x75, 0x5f, 0x91, 0x45, 0x30, 0x4b, 0x7a, 0xc1, 0xb9, 0x88, 0xf3,
	0x66, 0x30, 0x5b, 0xe0, 0x3c, 0x9a, 0xe7, 0xac, 0x1a, 0xae, 0x1a, 0x0d, 0xd3, 0x14, 0xea, 0x8b,
	0x1f, 0x4e, 0xa2, 0x54, 0x05, 0x1c, 0x17, 0xd8, 0x58, 0x59, 0x20, 0x1e, 0xca, 0xe9, 0x23, 0xdb,
	0x16, 0xf9, 0xb1, 0x10, 0x4a, 0x2f, 0x32, 0x3a, 0x7d, 0xd5, 0xfd, 0xea, 0x42, 0x94, 0x51, 0x3b,
	0x8e, 0x72, 0x6e, 0x57, 0x1e, 0xbd, 0x34, 0xe0, 0xfd, 0xb7, 0x03, 0xcb, 0xdb, 0x93, 0xa7, 0x4f,
	0x4f, 0xd7, 0xe9, 0x0d, 0x00, 0x9e, 0x0f, 0xe9, 0x2e, 0xfb, 0x47, 0x03, 0x41, 0xdb, 0x61, 0x68,
	0x35, 0x7d, 0x53, 0x5b, 0x41, 0x7f, 0x7f, 0x32, 0x92, 0x9a, 0x2c, 0x29, 0xd2, 0x49, 0xce, 0x2c,
	0x46, 0x49, 0x6c, 0x58, 0xd6, 0x12, 0x4a, 0x01, 0xaf, 0x46, 0x1e, 0x91, 0x6a, 0xd7, 0x7c, 0x13,
	0xb2, 0x39, 0x1e, 0xab, 0xb4, 0x82, 0x01, 0xd9, 0x1c, 0x5f, 0xa8, 0xb4, 0x82, 0x01, 0x79, 0xff,
	0xbe, 0xc2, 0xb9, 0x1f, 0x9e, 0xbf, 0xb2, 0x81, 0x4e, 0x55, 0x08, 0x6d, 0xed, 0xe7, 0xb3, 0x2c,
	0x23, 0x79, 0xe3, 0xba, 0xe5, 0x8d, 0x17, 0x94, 0x37, 0x2e, 0x59, 0x42, 0x2b, 0x1c, 0x5f, 0x2a,
	0x85, 0xe3, 0xda, 0xc2, 0x2e, 0x57, 0x5a, 0x58, 0x30, 0x2d, 0x2c, 0x86, 0xee, 0xc5, 0xa1, 0x6a,
	0x85, 0xed, 0x87, 0x71, 0x9c, 0xba, 0x06, 0x6b, 0x7b, 0xc1, 0x73, 0x83, 0x65, 0x95, 0xb5, 0xcc,
	0x02, 0x65, 0x2a, 0x38, 0x4f, 0x13, 0x8c, 0x31, 0xd6, 0x74, 0x2a, 0x98, 0x01, 0x6c, 0x63, 0x2b,
	0x8e, 0x46, 0x49, 0x9e, 0xa4, 0x78, 0xba, 0x14, 0x72, 0x63, 0xd9, 0x60, 0x11, 0x34, 0x90, 0x56,
	0x70, 0x8e, 0xc3, 0x40, 0xb0, 0xbc, 0x15, 0xa5, 0x6a, 0x69, 0x39, 0xcf, 0x61, 0x20, 0x56, 0xf9,
	0x63, 0x99, 0xee, 0x30, 0x10, 0x94, 0x98, 0x72, 0xe2, 0x6a, 0x2f, 0x29, 0xda, 0xbd, 0x01, 0xae,
	0xdc, 0xc1, 0xbd, 0x71, 0xf0, 0x24, 0x1a, 0x46, 0x79, 0x24, 0x32, 0xb9, 0xa1, 0x2a, 0x4a, 0x4a,
	0x01, 0xce, 0xc5, 0x72, 0x80, 0x83, 0x7a, 0xdc, 0xce, 0xd0, 0xdb, 0xc8, 0xcd, 0x23, 0x29, 0x76,
	0xe1, 0x2d, 0x11, 0xe4, 0x03, 0xca, 0x56, 0x90, 0x0b, 0x27, 0x92, 0x77, 0xdc, 0x91, 0xb4, 0x18,
	0x57, 0xd4, 0x8e, 0x93, 0x00, 0xea, 0x18, 0x59, 0xce, 0x06, 0xa7, 0x53, 0xc9, 0x5e, 0x72, 0x1f,
	0x51, 0x96, 0x51, 0x16, 0x62, 0xc9, 0x97, 0x94, 0x29, 0xed, 0x4e, 0x30, 0xc9, 0x04, 0x25, 0x20,
	0x0c, 0x69, 0x13, 0x48, 0x29, 0x25, 0xb4, 0x33, 0x3b, 0x71, 0x80, 0x3d, 0xbe, 0xc6, 0x21, 0x83,
	0x01, 0xe1, 0x1c, 0xe9, 0x00, 0xc5, 0x0c, 0xaf, 0xf3, 0x1c, 0x0b, 0x04, 0xf5, 0xf3, 0x0b, 0x99,
	0x5e, 0x70, 0xbe, 0xc0, 0x5e, 0xb1, 0xff, 0x34, 0x4d, 0xd2, 0xf6, 0x28, 0xe8, 0x0b, 0xca, 0x28,
	0xd4, 0x7d, 0x1b, 0x2c, 0xa7, 0xec, 0xbe, 0x31, 0x9d, 0xb2, 0xd3, 0x92, 0xc5, 0xe1, 0x52, 0x56,
	0x41, 0x4b, 0x16, 0x11, 0xc3, 0xda, 0xbc, 0x69, 0x59, 0x1b, 0x6d, 0x55, 0x7d, 0x71, 0x14, 0x1d,
	0x09, 0xd2, 0x21, 0x4f, 0xa6, 0x54, 0x4a, 0xb8, 0x11, 0x30, 0xbc, 0x65, 0x05, 0x0c, 0x2e, 0xcc,
	0xef, 0x26, 0xc3, 0xb0, 0x71, 0x8d, 0xa5, 0x8c, 0xdf, 0x74, 0xb4, 0x8a, 0x82, 0x51, 0x12, 0x87,
	0x8d, 0xb7, 0xe5, 0xd1, 0x8a, 0x49, 0xb6, 0x6f, 0xd8, 0x26, 0xd5, 0x79, 0x87, 0x47, 0x5a, 0x20,
	0x6c, 0x9f, 0x91, 0x52, 0xf5, 0xdf, 0x55, 0xf6, 0xd9, 0x00, 0xad, 0x23, 0x7a, 0x14, 0x36, 0xae,
	0x97, 0x8e, 0xe8, 0x51, 0xe8, 0x7e, 0x0a, 0x57, 0x79, 0x06, 0x0f, 0x83, 0xbc, 0x37, 0xa0, 0xf4,
	0x3b, 0x39, 0x87, 0x07, 0x49, 0x18, 0x9c, 0x34, 0xde, 0xa3, 0x0a, 0xa7, 0x70, 0xb8, 0xb7, 0xe1,
	0x62, 0x81, 0x6f, 0x85, 0xa1, 0x1a, 0xce, 0xfb, 0x54, 0xb3, 0xb2, 0x0c, 0x67, 0xbd, 0x3b, 0x89,
	0x86, 0x61, 0xbb, 0xd5, 0xf8, 0x80, 0x67, 0x2d, 0x49, 0xd4, 0x53, 0xfa, 0x24, 0x93, 0xf7, 0x4d,
	0x4e, 0xd4, 0x68, 0x80, 0xea, 0xa5, 0xc9, 0x64, 0xdc, 0x6e, 0x35, 0x3e, 0x94, 0xf5, 0x98, 0xac,
	0x4c, 0xe1, 0xdc, 0x98, 0x91, 0xc2, 0xd9, 0x00, 0xd8, 0x0e, 0xf2, 0x7c, 0x28, 0xfc, 0x20, 0x7e,
	0xd6, 0xb8, 0xc9, 0x92, 0x2d, 0x10, 0xf7, 0x1a, 0xd4, 0xba, 0xad, 0xc6, 0x2d, 0x0a, 0xdd, 0x2e,
	0x16, 0xa1, 0x5b, 0x11, 0x67, 0xf9, 0xb5, 0x6e, 0xcb, 0x7d, 0x0b, 0x6a, 0xdb, 0xad, 0xc6, 0x47,
	0xe5, 0x33, 0xa1, 0x76, 0x5c, 0x7e, 0x6d, 0xbb, 0xe5, 0xbe, 0x03, 0x73, 0xed, 0x6e, 0xab, 0x71,
	0xfb, 0x94, 0xb6, 0x90, 0x01, 0x5d, 0xde, 0xca, 0xf6, 0x64, 0x38, 0x14, 0x79, 0x75, 0xa6, 0xdd,
	0x34, 0xc7, 0xb5, 0x92, 0x39, 0x3e, 0xed, 0x90, 0x45, 0x9b, 0xa8, 0xae, 0x36, 0xd1, 0x45, 0xa8,
	0xb3, 0x81, 0x94, 0x41, 0x30, 0x1b, 0x46, 0x3c, 0x4b, 0xe3, 0x91, 0xf1, 0x91, 0xf4, 0x56, 0x92,
	0xd2, 0xf8, 0x63, 0xe9, 0xa3, 0x24, 0xa5, 0xf1, 0x2f, 0x64, 0xca, 0x5b, 0x52, 0xa8, 0xde, 0x3b,
	0x71, 0xf8, 0x48, 0x66, 0xba, 0xe9, 0x5b, 0x62, 0x8f, 0x65, 0x04, 0x45, 0xdf, 0x12, 0xfb, 0x42,
	0x06, 0x4e, 0xf4, 0xed, 0x3d, 0x80, 0x75, 0xbe, 0x0a, 0xca, 0xc5, 0xa8, 0x5a, 0x02, 0xc5, 0xc6,
	0xac, 0x95, 0xe3, 0xe1, 0x59, 0xb3, 0xf7, 0x02, 0x58, 0xbe, 0x1b, 0x0c, 0x93, 0x5f, 0xa2, 0x48,
	0xbd, 0x9f, 0x39, 0x74, 0xe3, 0x78, 0x90, 0x89, 0x74, 0x27, 0xce, 0x45, 0xca, 0x17, 0x5d, 0xf2,
	0x9a, 0xd3, 0x29, 0xae, 0x39, 0xad, 0xcb, 0xcc, 0x5a, 0xf9, 0x32, 0x93, 0x0f, 0x86, 0x5d, 0x91,
	0x1e, 0x89, 0xd4, 0xb8, 0x40, 0xb4, 0x41, 0x8c, 0x52, 0x5a, 0x22, 0xcb, 0x0d, 0x36, 0x4e, 0x94,
	0x95, 0x50, 0xf3, 0x9a, 0xad, 0x6e, 0x5d, 0xb3, 0x15, 0x97, 0xa6, 0x0b, 0xe6, 0xa5, 0xe9, 0x3f,
	0x38, 0xb0, 0xb6, 0x97, 0xf5, 0xf9, 0x58, 0x82, 0xa1, 0x2a, 0xee, 0x10, 0xfc, 0xb5, 0x12, 0x47,
	0x06, 0x82, 0x27, 0x07, 0xa4, 0xb6, 0x86, 0xc3, 0xcf, 0x83, 0xe1, 0x44, 0x9d, 0x17, 0x2d, 0x0c,
	0x47, 0x8b, 0x34, 0x05, 0xd5, 0xcc, 0xc5, 0x91, 0x49, 0x09, 0x65, 0x3f, 0xd3, 0x4c, 0xa3, 0x5c,
	0xc5, 0x64, 0x4c, 0xd1, 0x5e, 0x17, 0x39, 0x19, 0x3f, 0x39, 0x0b, 0x49, 0xe2, 0xe8, 0x76, 0x45,
	0xae, 0xec, 0x0c, 0xeb, 0xb2, 0x81, 0x78, 0xff, 0x3a, 0x0f, 0xcb, 0xfa, 0x18, 0x47, 0xb1, 0xfa,
	0x24, 0xbd, 0x93, 0xaa, 0x18, 0x0a, 0xcf, 0x22, 0x92, 0x76, 0x6f, 0xc2, 0xd2, 0xbe, 0x38, 0xc6,
	0x49, 0x65, 0x74, 0xa6, 0x9a, 0xca, 0xee, 0xc8, 0xd4, 0x90, 0x62, 0xc2, 0x0a, 0xf7, 0x87, 0x21,
	0x57, 0x98, 0x3b, 0xa5, 0x82, 0x62, 0xe2, 0xa3, 0xf3, 0x28, 0x39, 0x12, 0x5c, 0x67, 0x9e, 0x72,
	0x2f, 0x26, 0xe4, 0x7e, 0x0b, 0x60, 0x5f, 0x1c, 0xf3, 0xe6, 0xe7, 0xe4, 0xe6, 0xca, 0xed, 0x4b,
	0xa6, 0x3d, 0xd1, 0x56, 0xc1, 0x37, 0x18, 0xb1, 0xda, 0xfd, 0x61, 0xa8, 0xaa, 0x2d, 0x9c, 0x5a,
	0xad, 0x60, 0x64, 0xaf, 0x81, 0x9d, 0xab, 0x9a, 0x8b, 0x34, 0x22, 0x1b, 0x94, 0x72, 0xc1, 0xbd,
	0x93, 0x35, 0x96, 0xca, 0xd3, 0xd4, 0x5b, 0xca, 0xd7, 0x4c, 0x52, 0x2e, 0x5c, 0x61, 0xf9, 0x94,
	0x0a, 0x8a, 0xa9, 0x90, 0x0b, 0xd7, 0x01, 0x53, 0x2e, 0xcc, 0xf1, 0x29, 0xac, 0xed, 0x8b, 0x63,
	0x6d, 0x15, 0xb2, 0xc6, 0x4a, 0xf9, 0x2c, 0x6d, 0x5b, 0x0c, 0xdf, 0x66, 0x97, 0x1e, 0x21, 0x39,
	0x12, 0x46, 0x13, 0xab, 0xd4, 0xcd, 0x14, 0xee, 0x7e, 0x07, 0xa0, 0xd0, 0xfe, 0xc6, 0x1a, 0x75,
	0x74, 0xa5, 0xe8, 0xc8, 0xda, 0x1c, 0xbe, 0xc1, 0xea, 0xfd, 0xb8, 0x46, 0x09, 0x47, 0xd5, 0x73,
	0x65, 0xb0, 0x7e, 0x15, 0x96, 0xee, 0x25, 0xfd, 0xa8, 0x77, 0x67, 0xac, 0xd2, 0xa7, 0x9a, 0xb6,
	0x94, 0x73, 0xae, 0xa4, 0x9c, 0x1b, 0x00, 0x53, 0x5b, 0x1d, 0x5e, 0x68, 0x9b, 0x5f, 0x85, 0x25,
	0x0c, 0x44, 0xee, 0x26, 0x93, 0x54, 0x1d, 0xbf, 0x15, 0x8d, 0xad, 0xe2, 0xf7, 0x5e, 0x14, 0x4f,
	0x72, 0x75, 0xf4, 0x36, 0x10, 0x55, 0xde, 0x15, 0x3d, 0xdc, 0x5c, 0x4b, 0x45, 0x39, 0x23, 0xb8,
	0xf5, 0x51, 0xdc, 0xdd, 0x41, 0x72, 0x4c, 0xa6, 0x93, 0xcf, 0x00, 0x16, 0xe6, 0x3d, 0x07, 0x77,
	0xfa, 0x81, 0x40, 0x39, 0x14, 0x71, 0xa6, 0x43, 0x91, 0xaa, 0x74, 0x8f, 0xb4, 0xfb, 0xf2, 0xc1,
	0x83, 0xb4, 0xfb, 0x51, 0x58, 0x1c, 0x81, 0xe6, 0x8d, 0x23, 0x90, 0xf7, 0x07, 0x0e, 0xe5, 0x6e,
	0x29, 0xb9, 0x2f, 0xa8, 0xc1, 0x66, 0x91, 0x22, 0xa4, 0xef, 0x8a, 0x27, 0x28, 0x17, 0xa1, 0xbe,
	0x83, 0x31, 0xa4, 0xb4, 0xba, 0x4c, 0xb8, 0x3f, 0x00, 0xd0, 0x63, 0xe3, 0x8d, 0x7b, 0xd6, 0x0b,
	0x08, 0x83, 0xdf, 0x7b, 0x0a, 0x8d, 0x6e, 0xb3, 0xfc, 0xb4, 0xc2, 0x17, 0xd9, 0x64, 0x98, 0x57,
	0x8e, 0xaa, 0x24, 0x9c, 0xda, 0xb4, 0x70, 0xac, 0x51, 0xd6, 0xe5, 0x28, 0xbd, 0x3f, 0x75, 0xc0,
	0x6d, 0x26, 0xa3, 0x51, 0x12, 0x46, 0xf9, 0x09, 0x0e, 0xa3, 0x43, 0x2f, 0x73, 0x66, 0x1d, 0x9a,
	0xd1, 0xd8, 0xe6, 0x62, 0x54, 0x78, 0x51, 0xa6, 0xec, 0x07, 0x02, 0x73, 0x33, 0x1f, 0x08, 0xcc,
	0x1b, 0x0f, 0x04, 0x8a, 0x15, 0xa8, 0x9b, 0x2b, 0xf0, 0x36, 0xe5, 0x5e, 0x77, 0x45, 0xde, 0xcd,
	0x93, 0x94, 0x04, 0x43, 0x27, 0x71, 0x91, 0xa9, 0x17, 0x11, 0xf4, 0xed, 0xdd, 0x83, 0x55, 0x94,
	0x8f, 0xe6, 0x41, 0x69, 0xab, 0x69, 0xa8, 0x4c, 0xbb, 0x29, 0xed, 0xa9, 0x29, 0xfa, 0x06, 0xbf,
	0xf7, 0x1e, 0x75, 0xba, 0x3d, 0x39, 0xd1, 0xd8, 0xcc, 0x84, 0xfb, 0x23, 0x4a, 0x67, 0xd3, 0x6b,
	0x1f, 0x8e, 0x94, 0x8b, 0x40, 0x5b, 0x3f, 0x10, 0xd2, 0x81, 0xb6, 0x4a, 0x44, 0xd1, 0xc3, 0x94,
	0x28, 0x14, 0x09, 0x87, 0x4f, 0x2c, 0xbb, 0x12, 0xea, 0xbd, 0x09, 0x6b, 0xcd, 0xe6, 0x61, 0x2b,
	0xca, 0x7a, 0xec, 0xd7, 0x51, 0xd3, 0x76, 0x52, 0xf5, 0xc8, 0x07, 0x3f, 0xbd, 0x9f, 0x3b, 0x64,
	0x2e, 0x9a, 0x83, 0x80, 0xef, 0x27, 0x1a, 0xb0, 0xd8, 0x1c, 0x04, 0x71, 0x2c, 0x86, 0x2a, 0x2b,
	0x2d, 0x49, 0x9d, 0xbd, 0x90, 0x5b, 0x81, 0xce, 0x15, 0x46, 0x62, 0x79, 0xce, 0x4e, 0x2c, 0x97,
	0xd3, 0xbb, 0xf3, 0x15, 0xe9, 0xdd, 0x77, 0x60, 0xbd, 0x9b, 0xf6, 0xcc, 0xfb, 0x3a, 0x99, 0xe3,
	0xb0, 0x51, 0xf4, 0x10, 0x74, 0xbb, 0xa3, 0x1b, 0x63, 0x0b, 0x62, 0x83, 0x34, 0xf2, 0x24, 0xce,
	0x45, 0x9c, 0xcb, 0x4b, 0x35, 0x45, 0x7a, 0x7d, 0x58, 0xe1, 0x9c, 0xfd, 0x59, 0x53, 0x9c, 0xea,
	0xa8, 0x7e, 0x46, 0x47, 0x0b, 0x76, 0x47, 0x6d, 0xba, 0x1c, 0xd8, 0x0a, 0xc3, 0x3b, 0x18, 0xd7,
	0x87, 0x32, 0x1d, 0x5d, 0x11, 0x7b, 0x9d, 0xb9, 0xb7, 0xe4, 0x85, 0x01, 0xbb, 0x05, 0x6e, 0xed,
	0xa5, 0x9a, 0xe9, 0xd3, 0x6d, 0x95, 0x31, 0x22, 0x4e, 0xc2, 0xa3, 0x7b, 0x61, 0x84, 0x72, 0xc2,
	0x7c, 0x11, 0x65, 0xb8, 0x97, 0xa2, 0x6c, 0x2f, 0xeb, 0xfb, 0x06, 0x2b, 0x2a, 0x31, 0xdb, 0x0c,
	0xb5, 0x5d, 0x99, 0xf2, 0x7e, 0xea, 0xc0, 0x9a, 0x55, 0xeb, 0x65, 0x86, 0x5b, 0xf5, 0x5a, 0xad,
	0xda, 0xac, 0x1a, 0x46, 0xb8, 0x5e, 0x36, 0xc2, 0xd3, 0x07, 0x0a, 0xef, 0x6d, 0x38, 0xcf, 0x26,
	0x80, 0x87, 0x98, 0xdd, 0x8b, 0xaa, 0x96, 0xc5, 0xfb, 0x43, 0x87, 0xb2, 0xed, 0x25, 0xbe, 0x8f,
	0x60, 0x51, 0x92, 0xd2, 0x0a, 0xcc, 0x14, 0x94, 0xe2, 0x73, 0x7f, 0x1d, 0xd6, 0xe5, 0xa7, 0xd4,
	0x01, 0x19, 0xcb, 0xcd, 0xac, 0x59, 0x62, 0xf7, 0x7e, 0x17, 0xce, 0xed, 0x05, 0xd1, 0xb0, 0x3b,
	0x48, 0xd2, 0x5c, 0x09, 0x14, 0x8f, 0x0b, 0xa1, 0x3e, 0x2e, 0x84, 0x74, 0x2b, 0x23, 0xe2, 0xd0,
	0xf0, 0x4f, 0x9a, 0x46, 0x31, 0x3c, 0x88, 0xf2, 0xa1, 0x92, 0x24, 0x13, 0x28, 0x5e, 0xba, 0x74,
	0x66, 0xcf, 0x4d, 0xdf, 0x85, 0xc0, 0xea, 0xa6, 0xc0, 0x0e, 0x60, 0x05, 0xfb, 0xf7, 0xc5, 0x71,
	0x90, 0x86, 0x14, 0x14, 0xa0, 0x59, 0x36, 0xcc, 0x91, 0xa6, 0xb1, 0x01, 0x4e, 0xe9, 0xca, 0xcc,
	0x1f, 0xe7, 0x71, 0x2b, 0xaf, 0xd4, 0xbd, 0xb7, 0x94, 0x29, 0xc6, 0xc6, 0x67, 0xad, 0xc2, 0x33,
	0x78, 0x85, 0x17, 0xa1, 0x60, 0xba, 0x05, 0x75, 0x22, 0xe4, 0x02, 0x5c, 0x35, 0x02, 0xa1, 0x92,
	0x94, 0x7c, 0x66, 0x44, 0xdb, 0x82, 0x1f, 0x07, 0xe3, 0xb1, 0x48, 0xef, 0x45, 0xa3, 0x48, 0x0d,
	0xaf, 0x84, 0x7a, 0x9b, 0xea, 0xdd, 0x02, 0xe2, 0xa4, 0xe1, 0x25, 0x31, 0x7b, 0x7f, 0xc7, 0x77,
	0x6e, 0xa7, 0xb0, 0xbc, 0xc4, 0x4a, 0x18, 0x36, 0x64, 0xde, 0xb2, 0x21, 0x7a, 0x8d, 0xea, 0xc6,
	0x1a, 0xdd, 0x84, 0x45, 0xb9, 0x12, 0xd3, 0x61, 0xb5, 0xb1, 0x4c, 0xbe, 0xe2, 0x2a, 0x16, 0x75,
	0xd1, 0x5c, 0xd4, 0xb7, 0xd4, 0x2e, 0x30, 0x97, 0xb6, 0x3c, 0xdd, 0x4f, 0xd4, 0x16, 0x38, 0x85,
	0x69, 0xa6, 0x15, 0xb8, 0x4e, 0xef, 0x17, 0x5b, 0x62, 0x28, 0x72, 0xb1, 0x9f, 0x70, 0x6d, 0x5e,
	0x8f, 0x72, 0x37, 0x37, 0xe1, 0x0d, 0x1e, 0xcb, 0xce, 0xf3, 0x1e, 0x5d, 0xa6, 0xd2, 0x22, 0x16,
	0x0e, 0x74, 0xaa, 0x82, 0x0f, 0x57, 0xab, 0x59, 0xc9, 0x59, 0x17, 0x51, 0x84, 0x53, 0x8e, 0x22,
	0xba, 0x42, 0xdd, 0x39, 0xc8, 0x43, 0xae, 0x06, 0x3c, 0x01, 0x6f, 0xf0, 0x5c, 0x67, 0x0d, 0xa2,
	0x55, 0x11, 0x03, 0x5c, 0x2b, 0x64, 0x3f, 0x7b, 0x40, 0x56, 0x2c, 0xf0, 0x7d, 0xd8, 0xb4, 0xe7,
	0xda, 0x12, 0x79, 0x10, 0x0d, 0x45, 0x68, 0xf4, 0x34, 0x63, 0x02, 0xde, 0x8f, 0x1c, 0x78, 0x63,
	0x66, 0x35, 0x9a, 0xfa, 0x36, 0xac, 0x59, 0x40, 0xc5, 0xd3, 0xd8, 0xe9, 0x50, 0xc5, 0xae, 0x22,
	0xcf, 0x3e, 0x41, 0x14, 0x87, 0xda, 0xc5, 0xf3, 0xd9, 0x47, 0x41, 0xde, 0x33, 0xd8, 0xb4, 0x45,
	0x55, 0x31, 0x87, 0xdd, 0x0a, 0x69, 0xbd, 0x3b, 0x2d, 0xad, 0xca, 0x69, 0x94, 0x82, 0xa7, 0x2b,
	0x1c, 0x3c, 0xa9, 0x2a, 0x45, 0x10, 0x55, 0x7e, 0x82, 0xdb, 0xa7, 0xd7, 0x44, 0xdd, 0x81, 0x18,
	0x3e, 0x9d, 0x66, 0xbe, 0x0c, 0x0b, 0xdb, 0x41, 0xdf, 0x78, 0x93, 0xc1, 0x94, 0x1d, 0x5b, 0xd6,
	0x66, 0xc6, 0x96, 0x73, 0xe6, 0xe3, 0xd3, 0x0f, 0xe1, 0xb5, 0x66, 0xf7, 0xf0, 0x20, 0x9e, 0xd1,
	0x55, 0x79, 0x5c, 0xfc, 0x7c, 0x18, 0x83, 0x4e, 0x31, 0x1c, 0x1e, 0xb4, 0xb5, 0xd9, 0x30, 0x79,
	0x7e, 0x7f, 0x0e, 0xce, 0xb1, 0x50, 0x0d, 0xa6, 0x1b, 0xe0, 0x5a, 0x5d, 0xb0, 0xf1, 0xe2, 0x4a,
	0x15, 0x25, 0xee, 0x75, 0x7a, 0x1b, 0x3d, 0x54, 0xe0, 0x83, 0xe0, 0xb9, 0xbc, 0x79, 0x2a, 0xc3,
	0xee, 0x0f, 0xe0, 0x55, 0xab, 0xfe, 0x1d, 0x21, 0xca, 0x11, 0xf6, 0x6c, 0x06, 0xf7, 0x63, 0xb8,
	0x54, 0x59, 0x28, 0xdd, 0x72, 0x75, 0x21, 0x8e, 0x6e, 0x6b, 0x92, 0x27, 0x52, 0x6c, 0xa4, 0x5c,
	0xec, 0x67, 0xca, 0x70, 0x49, 0x79, 0x16, 0x5e, 0x5a, 0x79, 0x8c, 0xd7, 0x31, 0x8b, 0x67, 0xbf,
	0x8e, 0x61, 0x4d, 0xdb, 0x15, 0xf9, 0xc3, 0x24, 0x1d, 0x86, 0x5b, 0x13, 0xba, 0x39, 0xe1, 0x13,
	0x78, 0x79, 0xb5, 0xee, 0xc0, 0x15, 0x5e, 0xac, 0x69, 0xd6, 0x0f, 0xa0, 0xce, 0xa7, 0x79, 0xa7,
	0x6c, 0x9d, 0x0d, 0x36, 0x9f, 0x79, 0xbc, 0x26, 0x29, 0xd2, 0xbe, 0x38, 0x26, 0x09, 0x95, 0x1b,
	0x9b, 0x4a, 0x0a, 0x6a, 0x6d, 0xac, 0x99, 0xda, 0xf8, 0xb6, 0x7a, 0x21, 0xb6, 0x35, 0x1c, 0x52,
	0x32, 0x3a, 0xab, 0xd4, 0xb0, 0x7f, 0xab, 0xc1, 0x3a, 0x15, 0x6b, 0x17, 0xf9, 0x42, 0x2f, 0xa6,
	0xab, 0xdf, 0xc3, 0xd9, 0x17, 0x67, 0xf3, 0x67, 0x5f, 0x9c, 0xd5, 0xab, 0x2e, 0xce, 0xde, 0x81,
	0x75, 0x1d, 0xf1, 0xb1, 0x59, 0x5e, 0x90, 0x17, 0x9b, 0x16, 0x2a, 0x2f, 0x82, 0x99, 0x63, 0x51,
	0x5f, 0x04, 0x73, 0xd9, 0x35, 0x58, 0xeb, 0xa4, 0x22, 0x8b, 0x42, 0x11, 0xe7, 0x34, 0x78, 0xbe,
	0x0f, 0xb4, 0x41, 0xdc, 0xe5, 0xbf, 0x91, 0x44, 0x71, 0x30, 0x09, 0xa3, 0x5c, 0x26, 0x05, 0x0a,
	0x00, 0xc7, 0x81, 0xc4, 0x10, 0xa7, 0x36, 0xa4, 0x3d, 0xc6, 0xb7, 0x84, 0x25, 0x14, 0x6d, 0x08,
	0x3f, 0x82, 0xa0, 0x8c, 0xf1, 0xb2, 0x2f, 0x29, 0x94, 0x1b, 0x25, 0xeb, 0xf9, 0x76, 0x90, 0xbe,
	0xbd, 0x1f, 0xeb, 0x87, 0x78, 0xf6, 0xb2, 0xdc, 0x82, 0x05, 0xa6, 0xa4, 0x82, 0x18, 0x19, 0x23,
	0x7b, 0x75, 0x7c, 0xc9, 0x87, 0xfb, 0xa6, 0x99, 0x8a, 0x20, 0x17, 0x65, 0x3b, 0x55, 0x86, 0x29,
	0xa8, 0x2e, 0x20, 0xf5, 0x12, 0xc6, 0x80, 0xbc, 0x6b, 0x14, 0xe2, 0x30, 0x42, 0xcd, 0x57, 0xe5,
	0x84, 0xbc, 0x0d, 0x58, 0x6d, 0x76, 0x0f, 0x71, 0xf2, 0xcc, 0x53, 0x56, 0xa5, 0x37, 0x55, 0xe8,
	0xc6, 0xf7, 0x22, 0x55, 0xda, 0xf6, 0x47, 0x8e, 0x8a, 0xdc, 0x0a, 0x9e, 0x4f, 0x61, 0x8d, 0x88,
	0xed, 0x20, 0x13, 0xc6, 0x59, 0x63, 0xb6, 0x04, 0x6c, 0x76, 0xf7, 0xdb, 0x56, 0xce, 0x83, 0xa3,
	0xe8, 0xcb, 0xa5, 0xca, 0xcd, 0x01, 0xbd, 0x77, 0xb4, 0xb2, 0x1d, 0x7f, 0x5b, 0x83, 0x55, 0xb3,
	0xf0, 0xff, 0xe8, 0x38, 0x72, 0x15, 0x96, 0x3a, 0x51, 0xcc, 0x15, 0x64, 0xde, 0x4b, 0xd1, 0xa4,
	0xc5, 0xd6, 0xed, 0x10, 0xab, 0xb9, 0x0d, 0xe2, 0x18, 0x3a, 0x49, 0x96, 0xcb, 0xbc, 0x17, 0x7d,
	0xe3, 0xe1, 0x5a, 0xb5, 0x42, 0xe3, 0x5b, 0xa6, 0xf1, 0x59, 0x18, 0xf5, 0x9c, 0x64, 0xbc, 0x3d,
	0x40, 0xfe, 0x6b, 0x47, 0xd2, 0xee, 0xfb, 0x70, 0xae, 0x13, 0xc5, 0xf6, 0x66, 0xe5, 0x8b, 0xf0,
	0x29, 0xdc, 0x7b, 0x97, 0xde, 0x0f, 0xee, 0x8a, 0x5c, 0xab, 0x06, 0x9f, 0x84, 0xa7, 0x56, 0xff,
	0xb7, 0xe1, 0x12, 0x2f, 0x7e, 0x99, 0xb1, 0x05, 0xe7, 0xe5, 0xb1, 0xc6, 0x58, 0x49, 0xe7, 0xd4,
	0x95, 0x9c, 0xae, 0xe0, 0x7d, 0x0e, 0x57, 0x8d, 0x57, 0x64, 0xe5, 0x3e, 0xce, 0xce, 0xe4, 0xcd,
	0x0a, 0x59, 0xbf, 0x4b, 0x27, 0x64, 0x0e, 0x59, 0xbf, 0x56, 0x8b, 0x2a, 0xaf, 0x84, 0x75, 0xee,
	0x8f, 0x45, 0x8a, 0x81, 0x7a, 0x45, 0x1e, 0xcd, 0xdb, 0xa1, 0xf7, 0x94, 0xfc, 0x62, 0x90, 0x56,
	0xef, 0x85, 0xb2, 0x8e, 0xb4, 0xe6, 0xb5, 0x62, 0xcd, 0xe5, 0xbb, 0xd3, 0x9d, 0x30, 0xca, 0x93,
	0x94, 0xaf, 0x1f, 0xd9, 0x0e, 0x15, 0xf6, 0xc9, 0x31, 0xed, 0x93, 0x77, 0x8d, 0x5e, 0xdd, 0xa1,
	0x29, 0x3a, 0xcd, 0xa9, 0x6d, 0x81, 0x2b, 0x0d, 0xd6, 0x4b, 0xfb, 0xb3, 0xbf, 0xaa, 0xc1, 0xca,
	0x69, 0x0e, 0xec, 0x97, 0x9e, 0xe0, 0x73, 0x6f, 0xc1, 0x85, 0xed, 0x28, 0x0c, 0x45, 0xaa, 0x65,
	0x48, 0x5a, 0xcf, 0xc9, 0x99, 0xaa, 0x22, 0x0c, 0x66, 0x7c, 0xd1, 0x13, 0xd1, 0x91, 0xe8, 0x69,
	0x0d, 0xa3, 0x3a, 0x8b, 0xf4, 0x8c, 0xad, 0xba, 0xb0, 0xf4, 0xbe, 0x67, 0x49, 0xa5, 0xe5, 0xf4,
	0xfb, 0x9e, 0x0d, 0x00, 0xee, 0xcc, 0x48, 0x43, 0x1b, 0x88, 0xf7, 0x29, 0x9d, 0x8e, 0x94, 0xe7,
	0xff, 0x5f, 0x38, 0x7d, 0x5a, 0x7f, 0xf4, 0x38, 0x95, 0x66, 0xf8, 0x44, 0x39, 0x21, 0x9b, 0xed,
	0xeb, 0x3b, 0xa1, 0x5b, 0xb0, 0xb8, 0x17, 0x8c, 0xc9, 0x6a, 0xd7, 0xc8, 0x6a, 0x97, 0xb7, 0xab,
	0x2c, 0xf5, 0x15, 0x9b, 0xf7, 0x81, 0x7a, 0xdb, 0xaf, 0xbb, 0xe6, 0x4b, 0xec, 0xca, 0x71, 0xfe,
	0xa7, 0x03, 0x97, 0x4b, 0x7c, 0xca, 0x58, 0xbf, 0x5c, 0x62, 0x7e, 0xe6, 0x3f, 0xcd, 0x7e, 0x53,
	0x3f, 0x3b, 0x93, 0xff, 0x34, 0xd3, 0x00, 0xbd, 0xa1, 0x11, 0x41, 0x3e, 0xe0, 0x62, 0x56, 0x2b,
	0x03, 0x29, 0xde, 0x05, 0xa8, 0x6b, 0x3d, 0x45, 0xda, 0xef, 0x02, 0x16, 0xcb, 0xef, 0x02, 0x0a,
	0x87, 0xb0, 0x64, 0x3a, 0x04, 0xef, 0x40, 0xfd, 0x7b, 0xa1, 0x4a, 0x42, 0xdf, 0x85, 0x85, 0xad,
	0xe1, 0xb0, 0x39, 0x08, 0xe4, 0x12, 0x6d, 0x96, 0xe4, 0x3d, 0x25, 0x28, 0x5f, 0xf2, 0x97, 0x54,
	0x63, 0x2f, 0x18, 0x57, 0xc7, 0x83, 0x5b, 0x96, 0x6a, 0x68, 0xb6, 0xf7, 0x61, 0x1e, 0xbf, 0x67,
	0x18, 0x65, 0xb5, 0xca, 0xc4, 0xe3, 0xfd, 0x97, 0x23, 0x1d, 0xab, 0x84, 0xa7, 0x74, 0xd7, 0x83,
	0xd5, 0xfb, 0x63, 0x11, 0xef, 0x25, 0x71, 0x3e, 0x68, 0x05, 0x27, 0xea, 0x26, 0xd6, 0xc4, 0x70,
	0x7d, 0x91, 0x7e, 0x28, 0xc4, 0x33, 0x64, 0x61, 0xff, 0x6a, 0x42, 0xe8, 0x1c, 0x91, 0xa4, 0x8b,
	0x7c, 0xda, 0x6e, 0x9c, 0x26, 0xb1, 0x41, 0xd5, 0xce, 0x8e, 0x3c, 0xb7, 0xd6, 0x8b, 0x76, 0x24,
	0x84, 0x61, 0xde, 0xbe, 0x10, 0x21, 0x8d, 0xd8, 0x74, 0xc3, 0x25, 0x14, 0x5b, 0xda, 0x17, 0xcf,
	0x73, 0x75, 0x7d, 0xc5, 0xae, 0xd8, 0x84, 0x54, 0x00, 0x94, 0xe4, 0x89, 0x9a, 0xfe, 0x94, 0x78,
	0xdf, 0xe3, 0xf8, 0xc7, 0x64, 0x29, 0xdc, 0x8e, 0x53, 0x91, 0x29, 0x41, 0xc3, 0xdb, 0xcb, 0xa3,
	0xa3, 0x28, 0x3f, 0x99, 0xb9, 0x66, 0xbb, 0xea, 0xdf, 0x9d, 0x53, 0x9c, 0x1f, 0x5a, 0xcb, 0xf6,
	0xaa, 0x61, 0xa5, 0x0b, 0x4e, 0x63, 0xe5, 0xfe, 0xb2, 0x06, 0xaf, 0x94, 0x4a, 0xfe, 0x9f, 0x2f,
	0xde, 0xeb, 0xb0, 0x5c, 0xfc, 0xbb, 0x84, 0xd7, 0xad, 0x00, 0xce, 0x5e, 0x32, 0xdb, 0xc5, 0x2c,
	0xcd, 0x74, 0x31, 0xcb, 0xa6, 0x91, 0x7d, 0x4f, 0xfd, 0x5d, 0x45, 0x89, 0x68, 0xf6, 0x5f, 0x84,
	0x47, 0xf4, 0xf7, 0xde, 0x17, 0x61, 0x45, 0x89, 0x6c, 0x27, 0x59, 0x76, 0x27, 0x15, 0xd9, 0xc0,
	0x48, 0xb1, 0xd8, 0xa0, 0xfd, 0x9f, 0xb0, 0x39, 0xba, 0x19, 0x2e, 0x00, 0xe5, 0xd1, 0x13, 0xf9,
	0xe2, 0x96, 0x57, 0x71, 0x4a, 0x5d, 0xbe, 0xc9, 0x1e, 0xbd, 0xc4, 0x35, 0x4b, 0x0d, 0x75, 0x9a,
	0xa2, 0x35, 0x49, 0xb6, 0x83, 0xa4, 0x52, 0x01, 0xff, 0xc2, 0x51, 0x69, 0x0a, 0x83, 0xe9, 0x13,
	0x58, 0xd9, 0x0b, 0xc6, 0xbb, 0x49, 0x3b, 0x36, 0xa2, 0xfa, 0x53, 0x54, 0xd0, 0xe4, 0x76, 0x3f,
	0x2a, 0x3b, 0x16, 0x23, 0x2f, 0x6e, 0x49, 0x54, 0x7b, 0x16, 0x9c, 0x80, 0xbc, 0x20, 0x96, 0x97,
	0xae, 0x4c, 0x15, 0x61, 0x4e, 0x33, 0x19, 0xcf, 0xde, 0x43, 0x91, 0x0a, 0x73, 0x2c, 0xae, 0xf7,
	0xac, 0xfd, 0x73, 0xc9, 0x4c, 0x98, 0x8d, 0xed, 0xbd, 0x83, 0xe7, 0x31, 0x76, 0xf4, 0x18, 0x1d,
	0xe2, 0x5a, 0xa9, 0x8b, 0xf3, 0x32, 0xec, 0xfd, 0xb9, 0x03, 0x2b, 0x46, 0xfd, 0xa9, 0x1d, 0x66,
	0xe9, 0x74, 0xed, 0x0c, 0x9d, 0x9e, 0x9b, 0xd6, 0xe9, 0x4d, 0x58, 0xe1, 0x08, 0xd5, 0x74, 0x68,
	0x26, 0x34, 0x23, 0xa3, 0x7f, 0x93, 0xff, 0xea, 0xcd, 0x23, 0xeb, 0x44, 0x1d, 0x11, 0xf1, 0x0b,
	0x20, 0x1e, 0xa9, 0x1a, 0x61, 0x01, 0x78, 0xb7, 0xf8, 0xef, 0x58, 0x4c, 0xf3, 0x5f, 0xc4, 0xcf,
	0xa8, 0x71, 0x9b, 0xf4, 0xa4, 0x3b, 0x48, 0x8e, 0xa9, 0x7d, 0x9a, 0xfe, 0x06, 0x00, 0x11, 0x3c,
	0x22, 0x79, 0x95, 0x59, 0x20, 0x9e, 0x4f, 0x61, 0x2d, 0xfd, 0x3b, 0x4c, 0xbd, 0x76, 0xa3, 0x7a,
	0xf4, 0x57, 0xd8, 0xf8, 0x19, 0xff, 0x91, 0xc8, 0x51, 0x7f, 0x85, 0x95, 0x80, 0x2a, 0xb5, 0xd2,
	0xba, 0x1a, 0x28, 0x9c, 0x21, 0xb7, 0x39, 0x63, 0x25, 0xbc, 0x3f, 0x71, 0xe0, 0x22, 0x6b, 0x45,
	0xa9, 0xef, 0xef, 0xc0, 0x92, 0xfa, 0x96, 0xba, 0xf1, 0x9a, 0xf1, 0x8c, 0x45, 0xf3, 0xde, 0x8f,
	0xc9, 0x6b, 0xfb, 0x9a, 0xd9, 0xfd, 0x04, 0x60, 0xef, 0x44, 0x57, 0x65, 0xd5, 0x3e, 0xb5, 0xaa,
	0xc1, 0xee, 0xf9, 0xca, 0x37, 0xdb, 0xa3, 0xfe, 0x04, 0xd6, 0x2c, 0x40, 0x6e, 0xb5, 0x19, 0xda,
	0x6a, 0xf3, 0x7a, 0x7f, 0xec, 0xc0, 0xf9, 0xa9, 0x5e, 0x7f, 0xc1, 0xcf, 0x1e, 0x54, 0x22, 0x64,
	0xbe, 0x48, 0x84, 0x90, 0x0a, 0xf6, 0x92, 0xb4, 0x50, 0x41, 0x24, 0xbc, 0x1b, 0x94, 0x88, 0xe0,
	0xf1, 0xbc, 0x88, 0x06, 0xb2, 0xca, 0xca, 0x80, 0xe7, 0x45, 0x14, 0xf0, 0x96, 0xad, 0x4c, 0x77,
	0x45, 0x9a, 0x9c, 0x61, 0xc2, 0xff, 0xba, 0xa4, 0x03, 0xba, 0xca, 0xf7, 0x60, 0x81, 0x1e, 0x72,
	0x7e, 0x24, 0x35, 0xe0, 0xcd, 0xf2, 0x32, 0xde, 0x3f, 0x12, 0x29, 0xef, 0x3a, 0xb5, 0x98, 0xb2,
	0x82, 0xae, 0x7a, 0x5b, 0xa6, 0x2b, 0x5e, 0xb8, 0xea, 0x6d, 0x5c, 0x99, 0x87, 0x51, 0x1c, 0x8b,
	0x94, 0x68, 0xb5, 0xfd, 0x0d, 0xc8, 0xfb, 0x0f, 0x07, 0xae, 0xcc, 0x68, 0xe5, 0x17, 0xff, 0x9c,
	0x85, 0xd7, 0x70, 0xde, 0x58, 0x43, 0x3b, 0x9a, 0xae, 0x9f, 0x1e, 0x4d, 0x2f, 0x4c, 0x45, 0xd3,
	0x3a, 0x42, 0x5f, 0x2c, 0x27, 0x16, 0x8b, 0x3f, 0xd3, 0x2e, 0x95, 0xff, 0x4c, 0xbb, 0x7d, 0xee,
	0xef, 0xbf, 0xda, 0x70, 0xfe, 0xf1, 0xab, 0x0d, 0xe7, 0x9f, 0xbf, 0xda, 0x70, 0x7e, 0xf2, 0x2f,
	0x1b, 0xbf, 0xf2, 0x64, 0x81, 0x24, 0xfa, 0xab, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0xd7, 0xc2,
	0x5f, 0xaf, 0x03, 0x46, 0x00, 0x00,
}

func (m *MsgBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Datas) > 0 {
		i -= len(m.Datas)
		copy(dAtA[i:], m.Datas)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Datas)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ConnectId != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ConnectId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.MsgType) > 0 {
		i -= len(m.MsgType)
		copy(dAtA[i:], m.MsgType)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.MsgType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Uid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ModeType) > 0 {
		i -= len(m.ModeType)
		copy(dAtA[i:], m.ModeType)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ModeType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterToGate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterToGate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterToGate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ModeType) > 0 {
		i -= len(m.ModeType)
		copy(dAtA[i:], m.ModeType)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ModeType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CS_MsgQuickLogin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_MsgQuickLogin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_MsgQuickLogin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Machineid) > 0 {
		i -= len(m.Machineid)
		copy(dAtA[i:], m.Machineid)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Machineid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CS_Login) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_Login) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_Login) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.QQId) > 0 {
		i -= len(m.QQId)
		copy(dAtA[i:], m.QQId)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.QQId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.WechatId) > 0 {
		i -= len(m.WechatId)
		copy(dAtA[i:], m.WechatId)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.WechatId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Machineid) > 0 {
		i -= len(m.Machineid)
		copy(dAtA[i:], m.Machineid)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Machineid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Platform) > 0 {
		i -= len(m.Platform)
		copy(dAtA[i:], m.Platform)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Platform)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Phonenumber) > 0 {
		i -= len(m.Phonenumber)
		copy(dAtA[i:], m.Phonenumber)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Phonenumber)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CS_SelectCharacter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_SelectCharacter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_SelectCharacter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SelectCharacter != nil {
		{
			size, err := m.SelectCharacter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CS_LodingScene) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_LodingScene) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_LodingScene) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SceneID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SceneID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_LookVedioSucc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_LookVedioSucc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_LookVedioSucc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_UseAI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_UseAI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_UseAI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AIid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.AIid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_NeedLineUp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_NeedLineUp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_NeedLineUp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FrontCount != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.FrontCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetLineUpFrontCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetLineUpFrontCount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetLineUpFrontCount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Nothing1 != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Nothing1))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetLineUpFrontCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetLineUpFrontCount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetLineUpFrontCount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.FrontCount != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.FrontCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_CancelLineUp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_CancelLineUp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_CancelLineUp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Nothing != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Nothing))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnitEquip) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnitEquip) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnitEquip) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Price != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x28
	}
	if m.PriceType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.PriceType))
		i--
		dAtA[i] = 0x20
	}
	if m.Level != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.TypdID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TypdID))
		i--
		dAtA[i] = 0x10
	}
	if m.Pos != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Pos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnitBoardDatas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnitBoardDatas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnitBoardDatas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Equips) > 0 {
		for iNdEx := len(m.Equips) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Equips[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xa2
		}
	}
	if m.RemainExperience != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.RemainExperience))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if len(m.DropItems) > 0 {
		i -= len(m.DropItems)
		copy(dAtA[i:], m.DropItems)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.DropItems)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if m.AttributePrimary != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.AttributePrimary))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.RawHPRegain != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RawHPRegain))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x85
	}
	if m.RawDodge != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RawDodge))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfd
	}
	if m.RawStatusAmaor != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RawStatusAmaor))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf5
	}
	if m.RawMagicAmaor != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RawMagicAmaor))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xed
	}
	if m.RawPhysicalResist != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RawPhysicalResist))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe5
	}
	if m.RawPhysicalAmaor != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RawPhysicalAmaor))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xdd
	}
	if m.RawMPRegain != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RawMPRegain))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd5
	}
	if m.RawMagicScale != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RawMagicScale))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xcd
	}
	if m.RawMoveSpeed != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RawMoveSpeed))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc5
	}
	if m.RawAttackRange != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RawAttackRange))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xbd
	}
	if m.RawAttackSpeed != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RawAttackSpeed))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb5
	}
	if m.RawAttack != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.RawAttack))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.RawAttributeIntelligence != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RawAttributeIntelligence))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa5
	}
	if m.RawAttributeAgility != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RawAttributeAgility))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9d
	}
	if m.RawAttributeStrength != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RawAttributeStrength))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x95
	}
	if m.HPRegain != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HPRegain))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8d
	}
	if m.Dodge != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Dodge))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x85
	}
	if m.StatusAmaor != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.StatusAmaor))))
		i--
		dAtA[i] = 0x7d
	}
	if m.MagicAmaor != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MagicAmaor))))
		i--
		dAtA[i] = 0x75
	}
	if m.PhysicalResist != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PhysicalResist))))
		i--
		dAtA[i] = 0x6d
	}
	if m.PhysicalAmaor != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.PhysicalAmaor))))
		i--
		dAtA[i] = 0x65
	}
	if m.MPRegain != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MPRegain))))
		i--
		dAtA[i] = 0x5d
	}
	if m.MagicScale != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MagicScale))))
		i--
		dAtA[i] = 0x55
	}
	if m.MoveSpeed != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.MoveSpeed))))
		i--
		dAtA[i] = 0x4d
	}
	if m.AttackRange != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AttackRange))))
		i--
		dAtA[i] = 0x45
	}
	if m.AttackSpeed != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AttackSpeed))))
		i--
		dAtA[i] = 0x3d
	}
	if m.Attack != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Attack))
		i--
		dAtA[i] = 0x30
	}
	if m.AttributeIntelligence != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AttributeIntelligence))))
		i--
		dAtA[i] = 0x2d
	}
	if m.AttributeAgility != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AttributeAgility))))
		i--
		dAtA[i] = 0x25
	}
	if m.AttributeStrength != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AttributeStrength))))
		i--
		dAtA[i] = 0x1d
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SimpleSkillDatas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SimpleSkillDatas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SimpleSkillDatas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Index != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x28
	}
	if m.Level != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if m.TypeID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetUnitInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetUnitInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetUnitInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UnitID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.UnitID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetCharacterSimpleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetCharacterSimpleInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetCharacterSimpleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CharacterID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.CharacterID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetCharacterSimpleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetCharacterSimpleInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetCharacterSimpleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LastLoginDate) > 0 {
		i -= len(m.LastLoginDate)
		copy(dAtA[i:], m.LastLoginDate)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.LastLoginDate)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Skills) > 0 {
		i -= len(m.Skills)
		copy(dAtA[i:], m.Skills)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Skills)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EquipItems) > 0 {
		for iNdEx := len(m.EquipItems) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EquipItems[iNdEx])
			copy(dAtA[i:], m.EquipItems[iNdEx])
			i = encodeVarintMsg(dAtA, i, uint64(len(m.EquipItems[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ModeType) > 0 {
		i -= len(m.ModeType)
		copy(dAtA[i:], m.ModeType)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ModeType)))
		i--
		dAtA[i] = 0x22
	}
	if m.Level != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.CharacterID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.CharacterID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetItemExtraInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetItemExtraInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetItemExtraInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TypeId != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TypeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetItemExtraInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetItemExtraInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetItemExtraInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EquipNeedLevel != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.EquipNeedLevel))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ExceptionParam) > 0 {
		i -= len(m.ExceptionParam)
		copy(dAtA[i:], m.ExceptionParam)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ExceptionParam)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Exception != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Exception))
		i--
		dAtA[i] = 0x10
	}
	if m.TypeId != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TypeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetBagInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetBagInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetBagInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UnitID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.UnitID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_ChangeItemPos) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_ChangeItemPos) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_ChangeItemPos) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DestType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.DestType))
		i--
		dAtA[i] = 0x20
	}
	if m.SrcType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SrcType))
		i--
		dAtA[i] = 0x18
	}
	if m.DestPos != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.DestPos))
		i--
		dAtA[i] = 0x10
	}
	if m.SrcPos != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SrcPos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_DestroyItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_DestroyItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_DestroyItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SrcPos != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SrcPos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_SystemHuiShouItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_SystemHuiShouItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_SystemHuiShouItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SrcPos != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SrcPos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_UnitInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_UnitInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_UnitInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UnitData != nil {
		{
			size, err := m.UnitData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SC_BagInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_BagInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_BagInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Equips) > 0 {
		for iNdEx := len(m.Equips) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Equips[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CS_PlayerUpgradeSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_PlayerUpgradeSkill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_PlayerUpgradeSkill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TypeID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_PlayerMove) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_PlayerMove) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_PlayerMove) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsStart {
		i--
		if m.IsStart {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Y != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
		i--
		dAtA[i] = 0x1d
	}
	if m.X != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
		i--
		dAtA[i] = 0x15
	}
	if len(m.IDs) > 0 {
		dAtA4 := make([]byte, len(m.IDs)*10)
		var j3 int
		for _, num1 := range m.IDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintMsg(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CS_PlayerAttack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_PlayerAttack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_PlayerAttack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TargetUnitID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TargetUnitID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.IDs) > 0 {
		dAtA6 := make([]byte, len(m.IDs)*10)
		var j5 int
		for _, num1 := range m.IDs {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		i -= j5
		copy(dAtA[i:], dAtA6[:j5])
		i = encodeVarintMsg(dAtA, i, uint64(j5))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CS_PlayerSkill) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_PlayerSkill) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_PlayerSkill) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TargetUnitID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TargetUnitID))
		i--
		dAtA[i] = 0x28
	}
	if m.Y != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
		i--
		dAtA[i] = 0x25
	}
	if m.X != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
		i--
		dAtA[i] = 0x1d
	}
	if m.SkillID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SkillID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_ChangeAttackMode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_ChangeAttackMode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_ChangeAttackMode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AttackMode != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.AttackMode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_OrganizeTeam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_OrganizeTeam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_OrganizeTeam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Player2 != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Player2))
		i--
		dAtA[i] = 0x10
	}
	if m.Player1 != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Player1))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_RequestTeam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_RequestTeam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_RequestTeam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RequestType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.RequestType))
		i--
		dAtA[i] = 0x28
	}
	if m.SrcLevel != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SrcLevel))
		i--
		dAtA[i] = 0x20
	}
	if m.SrcUnitTypeID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SrcUnitTypeID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SrcName) > 0 {
		i -= len(m.SrcName)
		copy(dAtA[i:], m.SrcName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.SrcName)))
		i--
		dAtA[i] = 0x12
	}
	if m.SrcPlayerUID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SrcPlayerUID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_ResponseOrgTeam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_ResponseOrgTeam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_ResponseOrgTeam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RequestType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.RequestType))
		i--
		dAtA[i] = 0x18
	}
	if m.IsAgree != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.IsAgree))
		i--
		dAtA[i] = 0x10
	}
	if m.SrcPlayerUID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SrcPlayerUID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_OutTeam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_OutTeam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_OutTeam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.OutPlayerUID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.OutPlayerUID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TeamPlayerInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TeamPlayerInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TeamPlayerInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x38
	}
	if m.MaxMP != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.MaxMP))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxHP != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.MaxHP))
		i--
		dAtA[i] = 0x28
	}
	if m.MP != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.MP))
		i--
		dAtA[i] = 0x20
	}
	if m.HP != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.HP))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.UID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.UID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_UpdateTeamInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_UpdateTeamInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_UpdateTeamInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.TPInfo) > 0 {
		for iNdEx := len(m.TPInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TPInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.MainUID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.MainUID))
		i--
		dAtA[i] = 0x10
	}
	if m.TeamID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_NoticeWords) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_NoticeWords) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_NoticeWords) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.P) > 0 {
		for iNdEx := len(m.P) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.P[iNdEx])
			copy(dAtA[i:], m.P[iNdEx])
			i = encodeVarintMsg(dAtA, i, uint64(len(m.P[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.TypeID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SkillDatas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SkillDatas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SkillDatas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.InitLevel != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.InitLevel))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.LevelsBetweenUpgrades != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.LevelsBetweenUpgrades))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.RequiredLevel != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.RequiredLevel))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.MaxLevel != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.MaxLevel))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.RemainSkillCount != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.RemainSkillCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Visible != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Visible))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.AttackAutoActive != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.AttackAutoActive))
		i--
		dAtA[i] = 0x78
	}
	if m.ManaCost != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ManaCost))
		i--
		dAtA[i] = 0x70
	}
	if m.HurtRange != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.HurtRange))))
		i--
		dAtA[i] = 0x6d
	}
	if m.Cooldown != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Cooldown))))
		i--
		dAtA[i] = 0x65
	}
	if m.CastRange != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.CastRange))))
		i--
		dAtA[i] = 0x5d
	}
	if m.NoCareMagicImmune != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.NoCareMagicImmune))
		i--
		dAtA[i] = 0x50
	}
	if m.UnitTargetCamp != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.UnitTargetCamp))
		i--
		dAtA[i] = 0x48
	}
	if m.UnitTargetTeam != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.UnitTargetTeam))
		i--
		dAtA[i] = 0x40
	}
	if m.CastTargetType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.CastTargetType))
		i--
		dAtA[i] = 0x38
	}
	if m.CastType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.CastType))
		i--
		dAtA[i] = 0x30
	}
	if m.Index != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x28
	}
	if m.CanUpgrade != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.CanUpgrade))
		i--
		dAtA[i] = 0x20
	}
	if m.RemainCDTime != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RemainCDTime))))
		i--
		dAtA[i] = 0x1d
	}
	if m.Level != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if m.TypeID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BuffDatas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuffDatas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuffDatas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ConnectionZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ConnectionZ))))
		i--
		dAtA[i] = 0x45
	}
	if m.ConnectionY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ConnectionY))))
		i--
		dAtA[i] = 0x3d
	}
	if m.ConnectionX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.ConnectionX))))
		i--
		dAtA[i] = 0x35
	}
	if m.ConnectionType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ConnectionType))
		i--
		dAtA[i] = 0x28
	}
	if m.TagNum != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TagNum))
		i--
		dAtA[i] = 0x20
	}
	if m.Time != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Time))))
		i--
		dAtA[i] = 0x1d
	}
	if m.RemainTime != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RemainTime))))
		i--
		dAtA[i] = 0x15
	}
	if m.TypeID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnitDatas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnitDatas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnitDatas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.ISD) > 0 {
		for iNdEx := len(m.ISD) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ISD[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.BD) > 0 {
		for iNdEx := len(m.BD) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BD[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.SD) > 0 {
		for iNdEx := len(m.SD) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SD[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3
			i--
			dAtA[i] = 0x82
		}
	}
	if m.BattleRank != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.BattleRank))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf8
	}
	if m.RemainExperience != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.RemainExperience))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xf0
	}
	if m.GroupID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.GroupID))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe8
	}
	if len(m.GuildName) > 0 {
		i -= len(m.GuildName)
		copy(dAtA[i:], m.GuildName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.GuildName)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xe2
	}
	if m.GuildID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.GuildID))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd8
	}
	if m.WatchVedioAddDiamond != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.WatchVedioAddDiamond))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xd0
	}
	if m.RemainWatchVedioCountToday != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.RemainWatchVedioCountToday))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc8
	}
	if m.Characterid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Characterid))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xc0
	}
	if m.ReviveDiamond != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ReviveDiamond))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb8
	}
	if m.ReviveGold != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ReviveGold))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xb0
	}
	if m.Diamond != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Diamond))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa8
	}
	if m.Gold != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Gold))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.TeamID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TeamID))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if m.RemainReviveTime != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.RemainReviveTime))))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x95
	}
	if m.TypeID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x88
	}
	if m.AttackAnim != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.AttackAnim))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x80
	}
	if m.AttackRange != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AttackRange))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfd
	}
	if m.IsMirrorImage != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.IsMirrorImage))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if m.Z != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Z))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xed
	}
	if m.ItemEnable != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ItemEnable))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe0
	}
	if m.SkillEnable != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SkillEnable))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd8
	}
	if m.AnimotorPause != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.AnimotorPause))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.IsMiss {
		i--
		if m.IsMiss {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.Camp != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Camp))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.Invisible != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Invisible))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.IsDeath != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.IsDeath))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.IsMain != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.IsMain))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.AttackMode != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.AttackMode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.AttackAcpabilities != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.AttackAcpabilities))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.UnitType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.UnitType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.DirectionY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DirectionY))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8d
	}
	if m.DirectionX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.DirectionX))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x85
	}
	if m.AttackTime != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.AttackTime))))
		i--
		dAtA[i] = 0x7d
	}
	if m.AnimotorState != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.AnimotorState))
		i--
		dAtA[i] = 0x70
	}
	if m.ControlID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ControlID))
		i--
		dAtA[i] = 0x68
	}
	if m.MaxExperience != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.MaxExperience))
		i--
		dAtA[i] = 0x60
	}
	if m.Experience != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Experience))
		i--
		dAtA[i] = 0x58
	}
	if m.MaxMP != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.MaxMP))
		i--
		dAtA[i] = 0x50
	}
	if m.MaxHP != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.MaxHP))
		i--
		dAtA[i] = 0x48
	}
	if len(m.ModeType) > 0 {
		i -= len(m.ModeType)
		copy(dAtA[i:], m.ModeType)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ModeType)))
		i--
		dAtA[i] = 0x42
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x38
	}
	if m.Y != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
		i--
		dAtA[i] = 0x35
	}
	if m.X != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
		i--
		dAtA[i] = 0x2d
	}
	if m.MP != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.MP))
		i--
		dAtA[i] = 0x20
	}
	if m.HP != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.HP))
		i--
		dAtA[i] = 0x18
	}
	if m.Level != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BulletDatas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BulletDatas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BulletDatas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.EndZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EndZ))))
		i--
		dAtA[i] = 0x65
	}
	if m.EndY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EndY))))
		i--
		dAtA[i] = 0x5d
	}
	if m.EndX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.EndX))))
		i--
		dAtA[i] = 0x55
	}
	if m.StartZ != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.StartZ))))
		i--
		dAtA[i] = 0x4d
	}
	if m.StartY != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.StartY))))
		i--
		dAtA[i] = 0x45
	}
	if m.StartX != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.StartX))))
		i--
		dAtA[i] = 0x3d
	}
	if m.State != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x30
	}
	if m.Z != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Z))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Y != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
		i--
		dAtA[i] = 0x25
	}
	if m.X != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
		i--
		dAtA[i] = 0x1d
	}
	if len(m.ModeType) > 0 {
		i -= len(m.ModeType)
		copy(dAtA[i:], m.ModeType)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ModeType)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SceneItemDatas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SceneItemDatas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SceneItemDatas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Y != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
		i--
		dAtA[i] = 0x25
	}
	if m.X != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
		i--
		dAtA[i] = 0x1d
	}
	if m.TypeID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HaloDatas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HaloDatas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HaloDatas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Z != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Z))))
		i--
		dAtA[i] = 0x2d
	}
	if m.Y != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Y))))
		i--
		dAtA[i] = 0x25
	}
	if m.X != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.X))))
		i--
		dAtA[i] = 0x1d
	}
	if len(m.ModeType) > 0 {
		i -= len(m.ModeType)
		copy(dAtA[i:], m.ModeType)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ModeType)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUserEnterScene) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUserEnterScene) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUserEnterScene) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Datas) > 0 {
		i -= len(m.Datas)
		copy(dAtA[i:], m.Datas)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Datas)))
		i--
		dAtA[i] = 0x32
	}
	if m.SceneID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SceneID))
		i--
		dAtA[i] = 0x28
	}
	if len(m.DestServerName) > 0 {
		i -= len(m.DestServerName)
		copy(dAtA[i:], m.DestServerName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.DestServerName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SrcServerName) > 0 {
		i -= len(m.SrcServerName)
		copy(dAtA[i:], m.SrcServerName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.SrcServerName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.ConnectId != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ConnectId))
		i--
		dAtA[i] = 0x10
	}
	if m.Uid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgPlayerHurt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgPlayerHurt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgPlayerHurt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.GetDiamond != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.GetDiamond))
		i--
		dAtA[i] = 0x30
	}
	if m.GetGold != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.GetGold))
		i--
		dAtA[i] = 0x28
	}
	if m.IsCrit != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.IsCrit))
		i--
		dAtA[i] = 0x20
	}
	if m.HurtMagicValue != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.HurtMagicValue))
		i--
		dAtA[i] = 0x18
	}
	if m.HurtAllValue != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.HurtAllValue))
		i--
		dAtA[i] = 0x10
	}
	if m.HurtUnitID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.HurtUnitID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_Update) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_Update) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_Update) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.PlayerHurt) > 0 {
		for iNdEx := len(m.PlayerHurt) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PlayerHurt[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.RemoveSceneItems) > 0 {
		dAtA8 := make([]byte, len(m.RemoveSceneItems)*10)
		var j7 int
		for _, num1 := range m.RemoveSceneItems {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA8[j7] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j7++
			}
			dAtA8[j7] = uint8(num)
			j7++
		}
		i -= j7
		copy(dAtA[i:], dAtA8[:j7])
		i = encodeVarintMsg(dAtA, i, uint64(j7))
		i--
		dAtA[i] = 0x62
	}
	if len(m.NewSceneItems) > 0 {
		for iNdEx := len(m.NewSceneItems) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NewSceneItems[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.RemoveHalos) > 0 {
		dAtA10 := make([]byte, len(m.RemoveHalos)*10)
		var j9 int
		for _, num1 := range m.RemoveHalos {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		i -= j9
		copy(dAtA[i:], dAtA10[:j9])
		i = encodeVarintMsg(dAtA, i, uint64(j9))
		i--
		dAtA[i] = 0x52
	}
	if len(m.OldHalos) > 0 {
		for iNdEx := len(m.OldHalos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OldHalos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.NewHalos) > 0 {
		for iNdEx := len(m.NewHalos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NewHalos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.RemoveBullets) > 0 {
		dAtA12 := make([]byte, len(m.RemoveBullets)*10)
		var j11 int
		for _, num1 := range m.RemoveBullets {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintMsg(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.OldBullets) > 0 {
		for iNdEx := len(m.OldBullets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OldBullets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.NewBullets) > 0 {
		for iNdEx := len(m.NewBullets) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NewBullets[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RemoveUnits) > 0 {
		dAtA14 := make([]byte, len(m.RemoveUnits)*10)
		var j13 int
		for _, num1 := range m.RemoveUnits {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintMsg(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OldUnits) > 0 {
		for iNdEx := len(m.OldUnits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OldUnits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.NewUnits) > 0 {
		for iNdEx := len(m.NewUnits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NewUnits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.CurFrame != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.CurFrame))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_NewScene) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_NewScene) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_NewScene) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DataShowType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.DataShowType))
		i--
		dAtA[i] = 0x48
	}
	if m.TimeSecond != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TimeSecond))
		i--
		dAtA[i] = 0x40
	}
	if m.TimeMinute != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TimeMinute))
		i--
		dAtA[i] = 0x38
	}
	if m.TimeHour != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TimeHour))
		i--
		dAtA[i] = 0x30
	}
	if m.SceneID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SceneID))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0x22
	}
	if m.CurFrame != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.CurFrame))
		i--
		dAtA[i] = 0x18
	}
	if m.LogicFps != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.LogicFps))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CharacterBaseDatas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CharacterBaseDatas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CharacterBaseDatas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Level != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x20
	}
	if m.Typeid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Typeid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Characterid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Characterid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_Logined) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_Logined) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_Logined) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Characters) > 0 {
		for iNdEx := len(m.Characters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Characters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Uid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x10
	}
	if m.Code != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_SelectCharacterResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_SelectCharacterResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_SelectCharacterResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Error != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Error))
		i--
		dAtA[i] = 0x18
	}
	if m.Characterid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Characterid))
		i--
		dAtA[i] = 0x10
	}
	if m.Code != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommodityDataProto) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommodityDataProto) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommodityDataProto) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Level != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x28
	}
	if m.Price != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x20
	}
	if m.PriceType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.PriceType))
		i--
		dAtA[i] = 0x18
	}
	if m.ItemID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ItemID))
		i--
		dAtA[i] = 0x10
	}
	if m.TypeID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetStoreData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetStoreData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetStoreData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Test != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Test))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_StoreData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_StoreData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_StoreData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Commoditys) > 0 {
		for iNdEx := len(m.Commoditys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commoditys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CS_BuyCommodity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_BuyCommodity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_BuyCommodity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TypeID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.TypeID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_QuickRevive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_QuickRevive) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_QuickRevive) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LookVideoState != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.LookVideoState))
		i--
		dAtA[i] = 0x10
	}
	if m.ReviveType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ReviveType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CC_Disconnect) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CC_Disconnect) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CC_Disconnect) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Err) > 0 {
		i -= len(m.Err)
		copy(dAtA[i:], m.Err)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Err)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SC_ChatInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_ChatInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_ChatInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x3a
	}
	if m.DestPlayerUID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.DestPlayerUID))
		i--
		dAtA[i] = 0x30
	}
	if m.SrcCharacterID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SrcCharacterID))
		i--
		dAtA[i] = 0x28
	}
	if m.SrcPlayerUID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SrcPlayerUID))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SrcName) > 0 {
		i -= len(m.SrcName)
		copy(dAtA[i:], m.SrcName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.SrcName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Time) > 0 {
		i -= len(m.Time)
		copy(dAtA[i:], m.Time)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Time)))
		i--
		dAtA[i] = 0x12
	}
	if m.Channel != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Channel))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_ChatInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_ChatInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_ChatInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x32
	}
	if m.DestPlayerUID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.DestPlayerUID))
		i--
		dAtA[i] = 0x28
	}
	if m.Channel != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Channel))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_AddFriendRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_AddFriendRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_AddFriendRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Characterid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Characterid))
		i--
		dAtA[i] = 0x10
	}
	if m.Uid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_RemoveFriend) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_RemoveFriend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_RemoveFriend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Characterid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Characterid))
		i--
		dAtA[i] = 0x10
	}
	if m.Uid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_AddFriendResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_AddFriendResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_AddFriendResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x10
	}
	if m.FriendInfo != nil {
		{
			size, err := m.FriendInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FriendInfoMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FriendInfoMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FriendInfoMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x30
	}
	if m.Typeid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Typeid))
		i--
		dAtA[i] = 0x28
	}
	if m.Level != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Characterid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Characterid))
		i--
		dAtA[i] = 0x10
	}
	if m.Uid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetFriendsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetFriendsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetFriendsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Uid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetFriendsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetFriendsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetFriendsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.FriendsRequest) > 0 {
		for iNdEx := len(m.FriendsRequest) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FriendsRequest[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Friends) > 0 {
		for iNdEx := len(m.Friends) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Friends[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MailShortInfoMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailShortInfoMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MailShortInfoMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SendName) > 0 {
		i -= len(m.SendName)
		copy(dAtA[i:], m.SendName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.SendName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MailRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MailRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MailRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Level != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.Count != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if m.ItemType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ItemType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetMailsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetMailsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetMailsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Uid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetMailsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetMailsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetMailsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MailUpperLimit != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.MailUpperLimit))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Mails) > 0 {
		for iNdEx := len(m.Mails) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Mails[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetMailInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetMailInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetMailInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetMailInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetMailInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetMailInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Rewards) > 0 {
		for iNdEx := len(m.Rewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Date) > 0 {
		i -= len(m.Date)
		copy(dAtA[i:], m.Date)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Date)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SendName) > 0 {
		i -= len(m.SendName)
		copy(dAtA[i:], m.SendName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.SendName)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetMailRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetMailRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetMailRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetMailRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetMailRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetMailRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_DeleteNoRewardMails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_DeleteNoRewardMails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_DeleteNoRewardMails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetExchangeShortCommoditys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetExchangeShortCommoditys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetExchangeShortCommoditys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Id != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExchangeShortCommodityData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeShortCommodityData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExchangeShortCommodityData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SellCount != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SellCount))
		i--
		dAtA[i] = 0x10
	}
	if m.ItemID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ItemID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetExchangeShortCommoditys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetExchangeShortCommoditys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetExchangeShortCommoditys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Commoditys) > 0 {
		for iNdEx := len(m.Commoditys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commoditys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetExchangeDetailedCommoditys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetExchangeDetailedCommoditys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetExchangeDetailedCommoditys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ItemID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ItemID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ExchangeDetailedCommodityData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeDetailedCommodityData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExchangeDetailedCommodityData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RemaindTime != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.RemaindTime))
		i--
		dAtA[i] = 0x10
	}
	if m.CommodityData != nil {
		{
			size, err := m.CommodityData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetExchangeDetailedCommoditys) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetExchangeDetailedCommoditys) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetExchangeDetailedCommoditys) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Commoditys) > 0 {
		for iNdEx := len(m.Commoditys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commoditys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CS_BuyExchangeCommodity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_BuyExchangeCommodity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_BuyExchangeCommodity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_ShelfExchangeCommodity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_ShelfExchangeCommodity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_ShelfExchangeCommodity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Price != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x18
	}
	if m.PriceType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.PriceType))
		i--
		dAtA[i] = 0x10
	}
	if m.BagPos != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.BagPos))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_UnShelfExchangeCommodity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_UnShelfExchangeCommodity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_UnShelfExchangeCommodity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetSellUIInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetSellUIInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetSellUIInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetSellUIInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetSellUIInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetSellUIInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Equips) > 0 {
		for iNdEx := len(m.Equips) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Equips[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Commoditys) > 0 {
		for iNdEx := len(m.Commoditys) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Commoditys[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.AutoUnShelfTime != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.AutoUnShelfTime))
		i--
		dAtA[i] = 0x28
	}
	if m.ShelfExchangeFeePrice != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ShelfExchangeFeePrice))
		i--
		dAtA[i] = 0x20
	}
	if m.ShelfExchangeFeePriceType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ShelfExchangeFeePriceType))
		i--
		dAtA[i] = 0x18
	}
	if m.SellExchangeTax != 0 {
		i -= 4
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.SellExchangeTax))))
		i--
		dAtA[i] = 0x15
	}
	if m.ShelfExchangeLimit != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ShelfExchangeLimit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetWorldAuctionItems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetWorldAuctionItems) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetWorldAuctionItems) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetWorldAuctionItems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetWorldAuctionItems) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetWorldAuctionItems) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CS_NewPriceWorldAuctionItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_NewPriceWorldAuctionItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_NewPriceWorldAuctionItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Price != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetAllGuildsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetAllGuildsInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetAllGuildsInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GuildShortInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildShortInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GuildShortInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Rank != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x60
	}
	if len(m.Notice) > 0 {
		i -= len(m.Notice)
		copy(dAtA[i:], m.Notice)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Notice)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Joinlevellimit != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Joinlevellimit))
		i--
		dAtA[i] = 0x50
	}
	if m.Joinaudit != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Joinaudit))
		i--
		dAtA[i] = 0x48
	}
	if len(m.PresidentName) > 0 {
		i -= len(m.PresidentName)
		copy(dAtA[i:], m.PresidentName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PresidentName)))
		i--
		dAtA[i] = 0x42
	}
	if m.MaxCount != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.MaxCount))
		i--
		dAtA[i] = 0x38
	}
	if m.CharacterCount != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.CharacterCount))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxExperience != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.MaxExperience))
		i--
		dAtA[i] = 0x28
	}
	if m.Experience != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Experience))
		i--
		dAtA[i] = 0x20
	}
	if m.Level != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetAllGuildsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetAllGuildsInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetAllGuildsInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CreatePrice != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.CreatePrice))
		i--
		dAtA[i] = 0x18
	}
	if m.CreatePriceType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.CreatePriceType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Guilds) > 0 {
		for iNdEx := len(m.Guilds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Guilds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CS_CreateGuild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_CreateGuild) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_CreateGuild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CS_JoinGuild) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_JoinGuild) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_JoinGuild) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetGuildInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetGuildInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetGuildInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetGuildInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetGuildInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetGuildInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Characters) > 0 {
		for iNdEx := len(m.Characters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Characters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.GuildBaseInfo != nil {
		{
			size, err := m.GuildBaseInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GuildChaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildChaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GuildChaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PinMaxExperience != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.PinMaxExperience))
		i--
		dAtA[i] = 0x58
	}
	if len(m.PostName) > 0 {
		i -= len(m.PostName)
		copy(dAtA[i:], m.PostName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PostName)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.PinLevelName) > 0 {
		i -= len(m.PinLevelName)
		copy(dAtA[i:], m.PinLevelName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.PinLevelName)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Post != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Post))
		i--
		dAtA[i] = 0x40
	}
	if m.PinExperience != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.PinExperience))
		i--
		dAtA[i] = 0x38
	}
	if m.PinLevel != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.PinLevel))
		i--
		dAtA[i] = 0x30
	}
	if m.Typeid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Typeid))
		i--
		dAtA[i] = 0x28
	}
	if m.Level != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Characterid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Characterid))
		i--
		dAtA[i] = 0x10
	}
	if m.Uid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetJoinGuildPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetJoinGuildPlayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetJoinGuildPlayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetJoinGuildPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetJoinGuildPlayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetJoinGuildPlayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.RequestCharacters) > 0 {
		for iNdEx := len(m.RequestCharacters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequestCharacters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CS_ResponseJoinGuildPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_ResponseJoinGuildPlayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_ResponseJoinGuildPlayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x10
	}
	if m.Characterid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Characterid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_DeleteGuildPlayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_DeleteGuildPlayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_DeleteGuildPlayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Characterid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Characterid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GuildOperate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GuildOperate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GuildOperate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Code != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_ChangePost) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_ChangePost) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_ChangePost) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Post != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Post))
		i--
		dAtA[i] = 0x10
	}
	if m.Characterid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Characterid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_EditorGuildNotice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_EditorGuildNotice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_EditorGuildNotice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Notice) > 0 {
		i -= len(m.Notice)
		copy(dAtA[i:], m.Notice)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Notice)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetAuctionItems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetAuctionItems) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetAuctionItems) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetAuctionItems) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetAuctionItems) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetAuctionItems) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Items) > 0 {
		for iNdEx := len(m.Items) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Items[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AuctionItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuctionItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuctionItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BidderType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.BidderType))
		i--
		dAtA[i] = 0x48
	}
	if m.RemainTime != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.RemainTime))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ReceivecharactersName) > 0 {
		for iNdEx := len(m.ReceivecharactersName) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ReceivecharactersName[iNdEx])
			copy(dAtA[i:], m.ReceivecharactersName[iNdEx])
			i = encodeVarintMsg(dAtA, i, uint64(len(m.ReceivecharactersName[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.BidderCharacterName) > 0 {
		i -= len(m.BidderCharacterName)
		copy(dAtA[i:], m.BidderCharacterName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.BidderCharacterName)))
		i--
		dAtA[i] = 0x32
	}
	if m.Level != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x28
	}
	if m.Price != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x20
	}
	if m.PriceType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.PriceType))
		i--
		dAtA[i] = 0x18
	}
	if m.ItemID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ItemID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_NewPriceAuctionItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_NewPriceAuctionItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_NewPriceAuctionItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Price != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetGuildRankInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetGuildRankInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetGuildRankInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetGuildRankInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetGuildRankInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetGuildRankInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MapInfo != nil {
		{
			size, err := m.MapInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Guilds) > 0 {
		for iNdEx := len(m.Guilds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Guilds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetGuildRankBattleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetGuildRankBattleInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetGuildRankBattleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GuildRankBattleChaInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildRankBattleChaInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GuildRankBattleChaInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Typeid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Typeid))
		i--
		dAtA[i] = 0x40
	}
	if len(m.GuildName) > 0 {
		i -= len(m.GuildName)
		copy(dAtA[i:], m.GuildName)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.GuildName)))
		i--
		dAtA[i] = 0x3a
	}
	if m.GuildId != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.GuildId))
		i--
		dAtA[i] = 0x30
	}
	if m.DeathCount != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.DeathCount))
		i--
		dAtA[i] = 0x28
	}
	if m.KillCount != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.KillCount))
		i--
		dAtA[i] = 0x20
	}
	if m.Level != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Characterid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Characterid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetGuildRankBattleInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetGuildRankBattleInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetGuildRankBattleInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.AllCha) > 0 {
		for iNdEx := len(m.AllCha) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AllCha[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetGuildMapsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetGuildMapsInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetGuildMapsInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetGuildMapsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetGuildMapsInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetGuildMapsInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Maps) > 0 {
		for iNdEx := len(m.Maps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Maps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *GuildMapInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GuildMapInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GuildMapInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.NextSceneID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.NextSceneID))
		i--
		dAtA[i] = 0x38
	}
	if m.NeedGuildLevel != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.NeedGuildLevel))
		i--
		dAtA[i] = 0x30
	}
	if len(m.OpenEndTime) > 0 {
		i -= len(m.OpenEndTime)
		copy(dAtA[i:], m.OpenEndTime)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.OpenEndTime)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OpenStartTime) > 0 {
		i -= len(m.OpenStartTime)
		copy(dAtA[i:], m.OpenStartTime)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.OpenStartTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OpenWeekDay) > 0 {
		i -= len(m.OpenWeekDay)
		copy(dAtA[i:], m.OpenWeekDay)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.OpenWeekDay)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OpenMonthDay != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.OpenMonthDay))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GotoGuildMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GotoGuildMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GotoGuildMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GotoGuildMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GotoGuildMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GotoGuildMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetActivityMapsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetActivityMapsInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetActivityMapsInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetActivityMapsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetActivityMapsInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetActivityMapsInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Maps) > 0 {
		for iNdEx := len(m.Maps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Maps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ActivityMapInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ActivityMapInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ActivityMapInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Price != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Price))
		i--
		dAtA[i] = 0x48
	}
	if m.PriceType != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.PriceType))
		i--
		dAtA[i] = 0x40
	}
	if m.NextSceneID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.NextSceneID))
		i--
		dAtA[i] = 0x38
	}
	if m.NeedLevel != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.NeedLevel))
		i--
		dAtA[i] = 0x30
	}
	if len(m.OpenEndTime) > 0 {
		i -= len(m.OpenEndTime)
		copy(dAtA[i:], m.OpenEndTime)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.OpenEndTime)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OpenStartTime) > 0 {
		i -= len(m.OpenStartTime)
		copy(dAtA[i:], m.OpenStartTime)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.OpenStartTime)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OpenWeekDay) > 0 {
		i -= len(m.OpenWeekDay)
		copy(dAtA[i:], m.OpenWeekDay)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.OpenWeekDay)))
		i--
		dAtA[i] = 0x1a
	}
	if m.OpenMonthDay != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.OpenMonthDay))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetMapInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetMapInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetMapInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SceneID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SceneID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetMapInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetMapInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetMapInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DropItems) > 0 {
		dAtA20 := make([]byte, len(m.DropItems)*10)
		var j19 int
		for _, num1 := range m.DropItems {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintMsg(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0x1a
	}
	if m.BossFreshTime != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.BossFreshTime))
		i--
		dAtA[i] = 0x10
	}
	if m.SceneID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SceneID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GotoActivityMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GotoActivityMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GotoActivityMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GotoActivityMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GotoActivityMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GotoActivityMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Result != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Result))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetDuoBaoInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetDuoBaoInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetDuoBaoInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetDuoBaoInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetDuoBaoInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetDuoBaoInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Minute != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Minute))
		i--
		dAtA[i] = 0x18
	}
	if m.MapInfo != nil {
		{
			size, err := m.MapInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.MapGoInInfo != nil {
		{
			size, err := m.MapGoInInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetCopyMapsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetCopyMapsInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetCopyMapsInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetCopyMapsInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetCopyMapsInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetCopyMapsInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RemainPlayTimes != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.RemainPlayTimes))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Maps) > 0 {
		for iNdEx := len(m.Maps) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Maps[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CopyMapInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CopyMapInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CopyMapInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x28
	}
	if m.PlayerCount != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.PlayerCount))
		i--
		dAtA[i] = 0x20
	}
	if m.NextSceneID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.NextSceneID))
		i--
		dAtA[i] = 0x18
	}
	if m.NeedLevel != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.NeedLevel))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_CopyMapPiPei) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_CopyMapPiPei) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_CopyMapPiPei) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CopyMapID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.CopyMapID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_CopyMapCancel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_CopyMapCancel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_CopyMapCancel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CopyMapID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.CopyMapID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_ShowPiPeiInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_ShowPiPeiInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_ShowPiPeiInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.PiPeiState != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.PiPeiState))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetBattleRankInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetBattleRankInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetBattleRankInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RankCount != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.RankCount))
		i--
		dAtA[i] = 0x10
	}
	if m.RankStart != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.RankStart))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetBattleMapInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetBattleMapInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetBattleMapInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetBattleRankInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetBattleRankInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetBattleRankInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MyRankInfo != nil {
		{
			size, err := m.MyRankInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.RankInfo) > 0 {
		for iNdEx := len(m.RankInfo) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RankInfo[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetBattleMapInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetBattleMapInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetBattleMapInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.BattleMapInfo != nil {
		{
			size, err := m.BattleMapInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMsg(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BattleRankOneInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BattleRankOneInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BattleRankOneInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Score != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x28
	}
	if m.Rank != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Rank))
		i--
		dAtA[i] = 0x20
	}
	if m.Typeid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Typeid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Characterid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Characterid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_BattlePiPei) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_BattlePiPei) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_BattlePiPei) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CopyMapID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.CopyMapID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_BattleCancel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_BattleCancel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_BattleCancel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CopyMapID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.CopyMapID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CS_GetBattleHeroInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CS_GetBattleHeroInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CS_GetBattleHeroInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.SceneID != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.SceneID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SC_GetBattleHeroInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SC_GetBattleHeroInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SC_GetBattleHeroInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WinnerGroup != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.WinnerGroup))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Group2) > 0 {
		for iNdEx := len(m.Group2) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Group2[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Group1) > 0 {
		for iNdEx := len(m.Group1) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Group1[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMsg(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BattleOverPlayerOneInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BattleOverPlayerOneInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BattleOverPlayerOneInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EquipItems) > 0 {
		for iNdEx := len(m.EquipItems) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EquipItems[iNdEx])
			copy(dAtA[i:], m.EquipItems[iNdEx])
			i = encodeVarintMsg(dAtA, i, uint64(len(m.EquipItems[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.Level != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x38
	}
	if m.DeathCount != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.DeathCount))
		i--
		dAtA[i] = 0x30
	}
	if m.KillCount != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.KillCount))
		i--
		dAtA[i] = 0x28
	}
	if m.Score != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x20
	}
	if m.Typeid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Typeid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMsg(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.Characterid != 0 {
		i = encodeVarintMsg(dAtA, i, uint64(m.Characterid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMsg(dAtA []byte, offset int, v uint64) int {
	offset -= sovMsg(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModeType)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovMsg(uint64(m.Uid))
	}
	l = len(m.MsgType)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.ConnectId != 0 {
		n += 1 + sovMsg(uint64(m.ConnectId))
	}
	l = len(m.Datas)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgRegisterToGate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModeType)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_MsgQuickLogin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.Machineid)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_Login) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Phonenumber)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.Platform)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.Machineid)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.WechatId)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.QQId)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_SelectCharacter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SelectCharacter != nil {
		l = m.SelectCharacter.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_LodingScene) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SceneID != 0 {
		n += 1 + sovMsg(uint64(m.SceneID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_LookVedioSucc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_UseAI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AIid != 0 {
		n += 1 + sovMsg(uint64(m.AIid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_NeedLineUp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FrontCount != 0 {
		n += 1 + sovMsg(uint64(m.FrontCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetLineUpFrontCount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nothing1 != 0 {
		n += 1 + sovMsg(uint64(m.Nothing1))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetLineUpFrontCount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FrontCount != 0 {
		n += 1 + sovMsg(uint64(m.FrontCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_CancelLineUp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nothing != 0 {
		n += 1 + sovMsg(uint64(m.Nothing))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnitEquip) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pos != 0 {
		n += 1 + sovMsg(uint64(m.Pos))
	}
	if m.TypdID != 0 {
		n += 1 + sovMsg(uint64(m.TypdID))
	}
	if m.Level != 0 {
		n += 1 + sovMsg(uint64(m.Level))
	}
	if m.PriceType != 0 {
		n += 1 + sovMsg(uint64(m.PriceType))
	}
	if m.Price != 0 {
		n += 1 + sovMsg(uint64(m.Price))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnitBoardDatas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.AttributeStrength != 0 {
		n += 5
	}
	if m.AttributeAgility != 0 {
		n += 5
	}
	if m.AttributeIntelligence != 0 {
		n += 5
	}
	if m.Attack != 0 {
		n += 1 + sovMsg(uint64(m.Attack))
	}
	if m.AttackSpeed != 0 {
		n += 5
	}
	if m.AttackRange != 0 {
		n += 5
	}
	if m.MoveSpeed != 0 {
		n += 5
	}
	if m.MagicScale != 0 {
		n += 5
	}
	if m.MPRegain != 0 {
		n += 5
	}
	if m.PhysicalAmaor != 0 {
		n += 5
	}
	if m.PhysicalResist != 0 {
		n += 5
	}
	if m.MagicAmaor != 0 {
		n += 5
	}
	if m.StatusAmaor != 0 {
		n += 5
	}
	if m.Dodge != 0 {
		n += 6
	}
	if m.HPRegain != 0 {
		n += 6
	}
	if m.RawAttributeStrength != 0 {
		n += 6
	}
	if m.RawAttributeAgility != 0 {
		n += 6
	}
	if m.RawAttributeIntelligence != 0 {
		n += 6
	}
	if m.RawAttack != 0 {
		n += 2 + sovMsg(uint64(m.RawAttack))
	}
	if m.RawAttackSpeed != 0 {
		n += 6
	}
	if m.RawAttackRange != 0 {
		n += 6
	}
	if m.RawMoveSpeed != 0 {
		n += 6
	}
	if m.RawMagicScale != 0 {
		n += 6
	}
	if m.RawMPRegain != 0 {
		n += 6
	}
	if m.RawPhysicalAmaor != 0 {
		n += 6
	}
	if m.RawPhysicalResist != 0 {
		n += 6
	}
	if m.RawMagicAmaor != 0 {
		n += 6
	}
	if m.RawStatusAmaor != 0 {
		n += 6
	}
	if m.RawDodge != 0 {
		n += 6
	}
	if m.RawHPRegain != 0 {
		n += 6
	}
	if m.AttributePrimary != 0 {
		n += 2 + sovMsg(uint64(m.AttributePrimary))
	}
	l = len(m.DropItems)
	if l > 0 {
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.RemainExperience != 0 {
		n += 2 + sovMsg(uint64(m.RemainExperience))
	}
	if len(m.Equips) > 0 {
		for _, e := range m.Equips {
			l = e.Size()
			n += 2 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SimpleSkillDatas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovMsg(uint64(m.TypeID))
	}
	if m.Level != 0 {
		n += 1 + sovMsg(uint64(m.Level))
	}
	if m.Index != 0 {
		n += 1 + sovMsg(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetUnitInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnitID != 0 {
		n += 1 + sovMsg(uint64(m.UnitID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetCharacterSimpleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CharacterID != 0 {
		n += 1 + sovMsg(uint64(m.CharacterID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetCharacterSimpleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CharacterID != 0 {
		n += 1 + sovMsg(uint64(m.CharacterID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovMsg(uint64(m.Level))
	}
	l = len(m.ModeType)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if len(m.EquipItems) > 0 {
		for _, s := range m.EquipItems {
			l = len(s)
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	l = len(m.Skills)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.LastLoginDate)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetItemExtraInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeId != 0 {
		n += 1 + sovMsg(uint64(m.TypeId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetItemExtraInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeId != 0 {
		n += 1 + sovMsg(uint64(m.TypeId))
	}
	if m.Exception != 0 {
		n += 1 + sovMsg(uint64(m.Exception))
	}
	l = len(m.ExceptionParam)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.EquipNeedLevel != 0 {
		n += 1 + sovMsg(uint64(m.EquipNeedLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetBagInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnitID != 0 {
		n += 1 + sovMsg(uint64(m.UnitID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_ChangeItemPos) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcPos != 0 {
		n += 1 + sovMsg(uint64(m.SrcPos))
	}
	if m.DestPos != 0 {
		n += 1 + sovMsg(uint64(m.DestPos))
	}
	if m.SrcType != 0 {
		n += 1 + sovMsg(uint64(m.SrcType))
	}
	if m.DestType != 0 {
		n += 1 + sovMsg(uint64(m.DestType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_DestroyItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcPos != 0 {
		n += 1 + sovMsg(uint64(m.SrcPos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_SystemHuiShouItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcPos != 0 {
		n += 1 + sovMsg(uint64(m.SrcPos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_UnitInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UnitData != nil {
		l = m.UnitData.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_BagInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Equips) > 0 {
		for _, e := range m.Equips {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_PlayerUpgradeSkill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovMsg(uint64(m.TypeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_PlayerMove) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IDs) > 0 {
		l = 0
		for _, e := range m.IDs {
			l += sovMsg(uint64(e))
		}
		n += 1 + sovMsg(uint64(l)) + l
	}
	if m.X != 0 {
		n += 5
	}
	if m.Y != 0 {
		n += 5
	}
	if m.IsStart {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_PlayerAttack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IDs) > 0 {
		l = 0
		for _, e := range m.IDs {
			l += sovMsg(uint64(e))
		}
		n += 1 + sovMsg(uint64(l)) + l
	}
	if m.TargetUnitID != 0 {
		n += 1 + sovMsg(uint64(m.TargetUnitID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_PlayerSkill) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.SkillID != 0 {
		n += 1 + sovMsg(uint64(m.SkillID))
	}
	if m.X != 0 {
		n += 5
	}
	if m.Y != 0 {
		n += 5
	}
	if m.TargetUnitID != 0 {
		n += 1 + sovMsg(uint64(m.TargetUnitID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_ChangeAttackMode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttackMode != 0 {
		n += 1 + sovMsg(uint64(m.AttackMode))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_OrganizeTeam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Player1 != 0 {
		n += 1 + sovMsg(uint64(m.Player1))
	}
	if m.Player2 != 0 {
		n += 1 + sovMsg(uint64(m.Player2))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_RequestTeam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcPlayerUID != 0 {
		n += 1 + sovMsg(uint64(m.SrcPlayerUID))
	}
	l = len(m.SrcName)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.SrcUnitTypeID != 0 {
		n += 1 + sovMsg(uint64(m.SrcUnitTypeID))
	}
	if m.SrcLevel != 0 {
		n += 1 + sovMsg(uint64(m.SrcLevel))
	}
	if m.RequestType != 0 {
		n += 1 + sovMsg(uint64(m.RequestType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_ResponseOrgTeam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SrcPlayerUID != 0 {
		n += 1 + sovMsg(uint64(m.SrcPlayerUID))
	}
	if m.IsAgree != 0 {
		n += 1 + sovMsg(uint64(m.IsAgree))
	}
	if m.RequestType != 0 {
		n += 1 + sovMsg(uint64(m.RequestType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_OutTeam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.OutPlayerUID != 0 {
		n += 1 + sovMsg(uint64(m.OutPlayerUID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TeamPlayerInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UID != 0 {
		n += 1 + sovMsg(uint64(m.UID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.HP != 0 {
		n += 1 + sovMsg(uint64(m.HP))
	}
	if m.MP != 0 {
		n += 1 + sovMsg(uint64(m.MP))
	}
	if m.MaxHP != 0 {
		n += 1 + sovMsg(uint64(m.MaxHP))
	}
	if m.MaxMP != 0 {
		n += 1 + sovMsg(uint64(m.MaxMP))
	}
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_UpdateTeamInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TeamID != 0 {
		n += 1 + sovMsg(uint64(m.TeamID))
	}
	if m.MainUID != 0 {
		n += 1 + sovMsg(uint64(m.MainUID))
	}
	if len(m.TPInfo) > 0 {
		for _, e := range m.TPInfo {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_NoticeWords) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovMsg(uint64(m.TypeID))
	}
	if len(m.P) > 0 {
		for _, s := range m.P {
			l = len(s)
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SkillDatas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovMsg(uint64(m.TypeID))
	}
	if m.Level != 0 {
		n += 1 + sovMsg(uint64(m.Level))
	}
	if m.RemainCDTime != 0 {
		n += 5
	}
	if m.CanUpgrade != 0 {
		n += 1 + sovMsg(uint64(m.CanUpgrade))
	}
	if m.Index != 0 {
		n += 1 + sovMsg(uint64(m.Index))
	}
	if m.CastType != 0 {
		n += 1 + sovMsg(uint64(m.CastType))
	}
	if m.CastTargetType != 0 {
		n += 1 + sovMsg(uint64(m.CastTargetType))
	}
	if m.UnitTargetTeam != 0 {
		n += 1 + sovMsg(uint64(m.UnitTargetTeam))
	}
	if m.UnitTargetCamp != 0 {
		n += 1 + sovMsg(uint64(m.UnitTargetCamp))
	}
	if m.NoCareMagicImmune != 0 {
		n += 1 + sovMsg(uint64(m.NoCareMagicImmune))
	}
	if m.CastRange != 0 {
		n += 5
	}
	if m.Cooldown != 0 {
		n += 5
	}
	if m.HurtRange != 0 {
		n += 5
	}
	if m.ManaCost != 0 {
		n += 1 + sovMsg(uint64(m.ManaCost))
	}
	if m.AttackAutoActive != 0 {
		n += 1 + sovMsg(uint64(m.AttackAutoActive))
	}
	if m.Visible != 0 {
		n += 2 + sovMsg(uint64(m.Visible))
	}
	if m.RemainSkillCount != 0 {
		n += 2 + sovMsg(uint64(m.RemainSkillCount))
	}
	if m.MaxLevel != 0 {
		n += 2 + sovMsg(uint64(m.MaxLevel))
	}
	if m.RequiredLevel != 0 {
		n += 2 + sovMsg(uint64(m.RequiredLevel))
	}
	if m.LevelsBetweenUpgrades != 0 {
		n += 2 + sovMsg(uint64(m.LevelsBetweenUpgrades))
	}
	if m.InitLevel != 0 {
		n += 2 + sovMsg(uint64(m.InitLevel))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuffDatas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovMsg(uint64(m.TypeID))
	}
	if m.RemainTime != 0 {
		n += 5
	}
	if m.Time != 0 {
		n += 5
	}
	if m.TagNum != 0 {
		n += 1 + sovMsg(uint64(m.TagNum))
	}
	if m.ConnectionType != 0 {
		n += 1 + sovMsg(uint64(m.ConnectionType))
	}
	if m.ConnectionX != 0 {
		n += 5
	}
	if m.ConnectionY != 0 {
		n += 5
	}
	if m.ConnectionZ != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UnitDatas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovMsg(uint64(m.Level))
	}
	if m.HP != 0 {
		n += 1 + sovMsg(uint64(m.HP))
	}
	if m.MP != 0 {
		n += 1 + sovMsg(uint64(m.MP))
	}
	if m.X != 0 {
		n += 5
	}
	if m.Y != 0 {
		n += 5
	}
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	l = len(m.ModeType)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.MaxHP != 0 {
		n += 1 + sovMsg(uint64(m.MaxHP))
	}
	if m.MaxMP != 0 {
		n += 1 + sovMsg(uint64(m.MaxMP))
	}
	if m.Experience != 0 {
		n += 1 + sovMsg(uint64(m.Experience))
	}
	if m.MaxExperience != 0 {
		n += 1 + sovMsg(uint64(m.MaxExperience))
	}
	if m.ControlID != 0 {
		n += 1 + sovMsg(uint64(m.ControlID))
	}
	if m.AnimotorState != 0 {
		n += 1 + sovMsg(uint64(m.AnimotorState))
	}
	if m.AttackTime != 0 {
		n += 5
	}
	if m.DirectionX != 0 {
		n += 6
	}
	if m.DirectionY != 0 {
		n += 6
	}
	if m.UnitType != 0 {
		n += 2 + sovMsg(uint64(m.UnitType))
	}
	if m.AttackAcpabilities != 0 {
		n += 2 + sovMsg(uint64(m.AttackAcpabilities))
	}
	if m.AttackMode != 0 {
		n += 2 + sovMsg(uint64(m.AttackMode))
	}
	if m.IsMain != 0 {
		n += 2 + sovMsg(uint64(m.IsMain))
	}
	if m.IsDeath != 0 {
		n += 2 + sovMsg(uint64(m.IsDeath))
	}
	if m.Invisible != 0 {
		n += 2 + sovMsg(uint64(m.Invisible))
	}
	if m.Camp != 0 {
		n += 2 + sovMsg(uint64(m.Camp))
	}
	if m.IsMiss {
		n += 3
	}
	if m.AnimotorPause != 0 {
		n += 2 + sovMsg(uint64(m.AnimotorPause))
	}
	if m.SkillEnable != 0 {
		n += 2 + sovMsg(uint64(m.SkillEnable))
	}
	if m.ItemEnable != 0 {
		n += 2 + sovMsg(uint64(m.ItemEnable))
	}
	if m.Z != 0 {
		n += 6
	}
	if m.IsMirrorImage != 0 {
		n += 2 + sovMsg(uint64(m.IsMirrorImage))
	}
	if m.AttackRange != 0 {
		n += 6
	}
	if m.AttackAnim != 0 {
		n += 2 + sovMsg(uint64(m.AttackAnim))
	}
	if m.TypeID != 0 {
		n += 2 + sovMsg(uint64(m.TypeID))
	}
	if m.RemainReviveTime != 0 {
		n += 6
	}
	if m.TeamID != 0 {
		n += 2 + sovMsg(uint64(m.TeamID))
	}
	if m.Gold != 0 {
		n += 2 + sovMsg(uint64(m.Gold))
	}
	if m.Diamond != 0 {
		n += 2 + sovMsg(uint64(m.Diamond))
	}
	if m.ReviveGold != 0 {
		n += 2 + sovMsg(uint64(m.ReviveGold))
	}
	if m.ReviveDiamond != 0 {
		n += 2 + sovMsg(uint64(m.ReviveDiamond))
	}
	if m.Characterid != 0 {
		n += 2 + sovMsg(uint64(m.Characterid))
	}
	if m.RemainWatchVedioCountToday != 0 {
		n += 2 + sovMsg(uint64(m.RemainWatchVedioCountToday))
	}
	if m.WatchVedioAddDiamond != 0 {
		n += 2 + sovMsg(uint64(m.WatchVedioAddDiamond))
	}
	if m.GuildID != 0 {
		n += 2 + sovMsg(uint64(m.GuildID))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 2 + l + sovMsg(uint64(l))
	}
	if m.GroupID != 0 {
		n += 2 + sovMsg(uint64(m.GroupID))
	}
	if m.RemainExperience != 0 {
		n += 2 + sovMsg(uint64(m.RemainExperience))
	}
	if m.BattleRank != 0 {
		n += 2 + sovMsg(uint64(m.BattleRank))
	}
	if len(m.SD) > 0 {
		for _, e := range m.SD {
			l = e.Size()
			n += 2 + l + sovMsg(uint64(l))
		}
	}
	if len(m.BD) > 0 {
		for _, e := range m.BD {
			l = e.Size()
			n += 2 + l + sovMsg(uint64(l))
		}
	}
	if len(m.ISD) > 0 {
		for _, e := range m.ISD {
			l = e.Size()
			n += 2 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BulletDatas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	l = len(m.ModeType)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.X != 0 {
		n += 5
	}
	if m.Y != 0 {
		n += 5
	}
	if m.Z != 0 {
		n += 5
	}
	if m.State != 0 {
		n += 1 + sovMsg(uint64(m.State))
	}
	if m.StartX != 0 {
		n += 5
	}
	if m.StartY != 0 {
		n += 5
	}
	if m.StartZ != 0 {
		n += 5
	}
	if m.EndX != 0 {
		n += 5
	}
	if m.EndY != 0 {
		n += 5
	}
	if m.EndZ != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SceneItemDatas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.TypeID != 0 {
		n += 1 + sovMsg(uint64(m.TypeID))
	}
	if m.X != 0 {
		n += 5
	}
	if m.Y != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HaloDatas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	l = len(m.ModeType)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.X != 0 {
		n += 5
	}
	if m.Y != 0 {
		n += 5
	}
	if m.Z != 0 {
		n += 5
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgUserEnterScene) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovMsg(uint64(m.Uid))
	}
	if m.ConnectId != 0 {
		n += 1 + sovMsg(uint64(m.ConnectId))
	}
	l = len(m.SrcServerName)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.DestServerName)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.SceneID != 0 {
		n += 1 + sovMsg(uint64(m.SceneID))
	}
	l = len(m.Datas)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MsgPlayerHurt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HurtUnitID != 0 {
		n += 1 + sovMsg(uint64(m.HurtUnitID))
	}
	if m.HurtAllValue != 0 {
		n += 1 + sovMsg(uint64(m.HurtAllValue))
	}
	if m.HurtMagicValue != 0 {
		n += 1 + sovMsg(uint64(m.HurtMagicValue))
	}
	if m.IsCrit != 0 {
		n += 1 + sovMsg(uint64(m.IsCrit))
	}
	if m.GetGold != 0 {
		n += 1 + sovMsg(uint64(m.GetGold))
	}
	if m.GetDiamond != 0 {
		n += 1 + sovMsg(uint64(m.GetDiamond))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_Update) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurFrame != 0 {
		n += 1 + sovMsg(uint64(m.CurFrame))
	}
	if len(m.NewUnits) > 0 {
		for _, e := range m.NewUnits {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if len(m.OldUnits) > 0 {
		for _, e := range m.OldUnits {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if len(m.RemoveUnits) > 0 {
		l = 0
		for _, e := range m.RemoveUnits {
			l += sovMsg(uint64(e))
		}
		n += 1 + sovMsg(uint64(l)) + l
	}
	if len(m.NewBullets) > 0 {
		for _, e := range m.NewBullets {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if len(m.OldBullets) > 0 {
		for _, e := range m.OldBullets {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if len(m.RemoveBullets) > 0 {
		l = 0
		for _, e := range m.RemoveBullets {
			l += sovMsg(uint64(e))
		}
		n += 1 + sovMsg(uint64(l)) + l
	}
	if len(m.NewHalos) > 0 {
		for _, e := range m.NewHalos {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if len(m.OldHalos) > 0 {
		for _, e := range m.OldHalos {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if len(m.RemoveHalos) > 0 {
		l = 0
		for _, e := range m.RemoveHalos {
			l += sovMsg(uint64(e))
		}
		n += 1 + sovMsg(uint64(l)) + l
	}
	if len(m.NewSceneItems) > 0 {
		for _, e := range m.NewSceneItems {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if len(m.RemoveSceneItems) > 0 {
		l = 0
		for _, e := range m.RemoveSceneItems {
			l += sovMsg(uint64(e))
		}
		n += 1 + sovMsg(uint64(l)) + l
	}
	if len(m.PlayerHurt) > 0 {
		for _, e := range m.PlayerHurt {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_NewScene) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.LogicFps != 0 {
		n += 1 + sovMsg(uint64(m.LogicFps))
	}
	if m.CurFrame != 0 {
		n += 1 + sovMsg(uint64(m.CurFrame))
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.SceneID != 0 {
		n += 1 + sovMsg(uint64(m.SceneID))
	}
	if m.TimeHour != 0 {
		n += 1 + sovMsg(uint64(m.TimeHour))
	}
	if m.TimeMinute != 0 {
		n += 1 + sovMsg(uint64(m.TimeMinute))
	}
	if m.TimeSecond != 0 {
		n += 1 + sovMsg(uint64(m.TimeSecond))
	}
	if m.DataShowType != 0 {
		n += 1 + sovMsg(uint64(m.DataShowType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CharacterBaseDatas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Characterid != 0 {
		n += 1 + sovMsg(uint64(m.Characterid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Typeid != 0 {
		n += 1 + sovMsg(uint64(m.Typeid))
	}
	if m.Level != 0 {
		n += 1 + sovMsg(uint64(m.Level))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_Logined) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovMsg(uint64(m.Code))
	}
	if m.Uid != 0 {
		n += 1 + sovMsg(uint64(m.Uid))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if len(m.Characters) > 0 {
		for _, e := range m.Characters {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_SelectCharacterResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovMsg(uint64(m.Code))
	}
	if m.Characterid != 0 {
		n += 1 + sovMsg(uint64(m.Characterid))
	}
	if m.Error != 0 {
		n += 1 + sovMsg(uint64(m.Error))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommodityDataProto) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovMsg(uint64(m.TypeID))
	}
	if m.ItemID != 0 {
		n += 1 + sovMsg(uint64(m.ItemID))
	}
	if m.PriceType != 0 {
		n += 1 + sovMsg(uint64(m.PriceType))
	}
	if m.Price != 0 {
		n += 1 + sovMsg(uint64(m.Price))
	}
	if m.Level != 0 {
		n += 1 + sovMsg(uint64(m.Level))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetStoreData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Test != 0 {
		n += 1 + sovMsg(uint64(m.Test))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_StoreData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Commoditys) > 0 {
		for _, e := range m.Commoditys {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_BuyCommodity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TypeID != 0 {
		n += 1 + sovMsg(uint64(m.TypeID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_QuickRevive) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReviveType != 0 {
		n += 1 + sovMsg(uint64(m.ReviveType))
	}
	if m.LookVideoState != 0 {
		n += 1 + sovMsg(uint64(m.LookVideoState))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CC_Disconnect) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Err)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_ChatInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Channel != 0 {
		n += 1 + sovMsg(uint64(m.Channel))
	}
	l = len(m.Time)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.SrcName)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.SrcPlayerUID != 0 {
		n += 1 + sovMsg(uint64(m.SrcPlayerUID))
	}
	if m.SrcCharacterID != 0 {
		n += 1 + sovMsg(uint64(m.SrcCharacterID))
	}
	if m.DestPlayerUID != 0 {
		n += 1 + sovMsg(uint64(m.DestPlayerUID))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_ChatInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Channel != 0 {
		n += 1 + sovMsg(uint64(m.Channel))
	}
	if m.DestPlayerUID != 0 {
		n += 1 + sovMsg(uint64(m.DestPlayerUID))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_AddFriendRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovMsg(uint64(m.Uid))
	}
	if m.Characterid != 0 {
		n += 1 + sovMsg(uint64(m.Characterid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_RemoveFriend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovMsg(uint64(m.Uid))
	}
	if m.Characterid != 0 {
		n += 1 + sovMsg(uint64(m.Characterid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_AddFriendResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FriendInfo != nil {
		l = m.FriendInfo.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Result != 0 {
		n += 1 + sovMsg(uint64(m.Result))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *FriendInfoMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovMsg(uint64(m.Uid))
	}
	if m.Characterid != 0 {
		n += 1 + sovMsg(uint64(m.Characterid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovMsg(uint64(m.Level))
	}
	if m.Typeid != 0 {
		n += 1 + sovMsg(uint64(m.Typeid))
	}
	if m.State != 0 {
		n += 1 + sovMsg(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetFriendsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovMsg(uint64(m.Uid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetFriendsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Friends) > 0 {
		for _, e := range m.Friends {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if len(m.FriendsRequest) > 0 {
		for _, e := range m.FriendsRequest {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MailShortInfoMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMsg(uint64(m.Id))
	}
	l = len(m.SendName)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMsg(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *MailRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemType != 0 {
		n += 1 + sovMsg(uint64(m.ItemType))
	}
	if m.Count != 0 {
		n += 1 + sovMsg(uint64(m.Count))
	}
	if m.Level != 0 {
		n += 1 + sovMsg(uint64(m.Level))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetMailsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovMsg(uint64(m.Uid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetMailsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Mails) > 0 {
		for _, e := range m.Mails {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.MailUpperLimit != 0 {
		n += 1 + sovMsg(uint64(m.MailUpperLimit))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetMailInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMsg(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetMailInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMsg(uint64(m.Id))
	}
	l = len(m.SendName)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.Date)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if len(m.Rewards) > 0 {
		for _, e := range m.Rewards {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.State != 0 {
		n += 1 + sovMsg(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetMailRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMsg(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetMailRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMsg(uint64(m.Id))
	}
	if m.Result != 0 {
		n += 1 + sovMsg(uint64(m.Result))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_DeleteNoRewardMails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMsg(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetExchangeShortCommoditys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovMsg(uint64(m.Id))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExchangeShortCommodityData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemID != 0 {
		n += 1 + sovMsg(uint64(m.ItemID))
	}
	if m.SellCount != 0 {
		n += 1 + sovMsg(uint64(m.SellCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetExchangeShortCommoditys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Commoditys) > 0 {
		for _, e := range m.Commoditys {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetExchangeDetailedCommoditys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ItemID != 0 {
		n += 1 + sovMsg(uint64(m.ItemID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExchangeDetailedCommodityData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CommodityData != nil {
		l = m.CommodityData.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.RemaindTime != 0 {
		n += 1 + sovMsg(uint64(m.RemaindTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetExchangeDetailedCommoditys) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Commoditys) > 0 {
		for _, e := range m.Commoditys {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_BuyExchangeCommodity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_ShelfExchangeCommodity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BagPos != 0 {
		n += 1 + sovMsg(uint64(m.BagPos))
	}
	if m.PriceType != 0 {
		n += 1 + sovMsg(uint64(m.PriceType))
	}
	if m.Price != 0 {
		n += 1 + sovMsg(uint64(m.Price))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_UnShelfExchangeCommodity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetSellUIInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetSellUIInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShelfExchangeLimit != 0 {
		n += 1 + sovMsg(uint64(m.ShelfExchangeLimit))
	}
	if m.SellExchangeTax != 0 {
		n += 5
	}
	if m.ShelfExchangeFeePriceType != 0 {
		n += 1 + sovMsg(uint64(m.ShelfExchangeFeePriceType))
	}
	if m.ShelfExchangeFeePrice != 0 {
		n += 1 + sovMsg(uint64(m.ShelfExchangeFeePrice))
	}
	if m.AutoUnShelfTime != 0 {
		n += 1 + sovMsg(uint64(m.AutoUnShelfTime))
	}
	if len(m.Commoditys) > 0 {
		for _, e := range m.Commoditys {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if len(m.Equips) > 0 {
		for _, e := range m.Equips {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetWorldAuctionItems) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetWorldAuctionItems) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_NewPriceWorldAuctionItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.Price != 0 {
		n += 1 + sovMsg(uint64(m.Price))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetAllGuildsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuildShortInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovMsg(uint64(m.Level))
	}
	if m.Experience != 0 {
		n += 1 + sovMsg(uint64(m.Experience))
	}
	if m.MaxExperience != 0 {
		n += 1 + sovMsg(uint64(m.MaxExperience))
	}
	if m.CharacterCount != 0 {
		n += 1 + sovMsg(uint64(m.CharacterCount))
	}
	if m.MaxCount != 0 {
		n += 1 + sovMsg(uint64(m.MaxCount))
	}
	l = len(m.PresidentName)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Joinaudit != 0 {
		n += 1 + sovMsg(uint64(m.Joinaudit))
	}
	if m.Joinlevellimit != 0 {
		n += 1 + sovMsg(uint64(m.Joinlevellimit))
	}
	l = len(m.Notice)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Rank != 0 {
		n += 1 + sovMsg(uint64(m.Rank))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetAllGuildsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Guilds) > 0 {
		for _, e := range m.Guilds {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.CreatePriceType != 0 {
		n += 1 + sovMsg(uint64(m.CreatePriceType))
	}
	if m.CreatePrice != 0 {
		n += 1 + sovMsg(uint64(m.CreatePrice))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_CreateGuild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_JoinGuild) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetGuildInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetGuildInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GuildBaseInfo != nil {
		l = m.GuildBaseInfo.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if len(m.Characters) > 0 {
		for _, e := range m.Characters {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuildChaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovMsg(uint64(m.Uid))
	}
	if m.Characterid != 0 {
		n += 1 + sovMsg(uint64(m.Characterid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovMsg(uint64(m.Level))
	}
	if m.Typeid != 0 {
		n += 1 + sovMsg(uint64(m.Typeid))
	}
	if m.PinLevel != 0 {
		n += 1 + sovMsg(uint64(m.PinLevel))
	}
	if m.PinExperience != 0 {
		n += 1 + sovMsg(uint64(m.PinExperience))
	}
	if m.Post != 0 {
		n += 1 + sovMsg(uint64(m.Post))
	}
	l = len(m.PinLevelName)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.PostName)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.PinMaxExperience != 0 {
		n += 1 + sovMsg(uint64(m.PinMaxExperience))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetJoinGuildPlayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetJoinGuildPlayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RequestCharacters) > 0 {
		for _, e := range m.RequestCharacters {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_ResponseJoinGuildPlayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Characterid != 0 {
		n += 1 + sovMsg(uint64(m.Characterid))
	}
	if m.Result != 0 {
		n += 1 + sovMsg(uint64(m.Result))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_DeleteGuildPlayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Characterid != 0 {
		n += 1 + sovMsg(uint64(m.Characterid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GuildOperate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovMsg(uint64(m.Code))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_ChangePost) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Characterid != 0 {
		n += 1 + sovMsg(uint64(m.Characterid))
	}
	if m.Post != 0 {
		n += 1 + sovMsg(uint64(m.Post))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_EditorGuildNotice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Notice)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetAuctionItems) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetAuctionItems) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuctionItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.ItemID != 0 {
		n += 1 + sovMsg(uint64(m.ItemID))
	}
	if m.PriceType != 0 {
		n += 1 + sovMsg(uint64(m.PriceType))
	}
	if m.Price != 0 {
		n += 1 + sovMsg(uint64(m.Price))
	}
	if m.Level != 0 {
		n += 1 + sovMsg(uint64(m.Level))
	}
	l = len(m.BidderCharacterName)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if len(m.ReceivecharactersName) > 0 {
		for _, s := range m.ReceivecharactersName {
			l = len(s)
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.RemainTime != 0 {
		n += 1 + sovMsg(uint64(m.RemainTime))
	}
	if m.BidderType != 0 {
		n += 1 + sovMsg(uint64(m.BidderType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_NewPriceAuctionItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.Price != 0 {
		n += 1 + sovMsg(uint64(m.Price))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetGuildRankInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetGuildRankInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Guilds) > 0 {
		for _, e := range m.Guilds {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.MapInfo != nil {
		l = m.MapInfo.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetGuildRankBattleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuildRankBattleChaInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Characterid != 0 {
		n += 1 + sovMsg(uint64(m.Characterid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Level != 0 {
		n += 1 + sovMsg(uint64(m.Level))
	}
	if m.KillCount != 0 {
		n += 1 + sovMsg(uint64(m.KillCount))
	}
	if m.DeathCount != 0 {
		n += 1 + sovMsg(uint64(m.DeathCount))
	}
	if m.GuildId != 0 {
		n += 1 + sovMsg(uint64(m.GuildId))
	}
	l = len(m.GuildName)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Typeid != 0 {
		n += 1 + sovMsg(uint64(m.Typeid))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetGuildRankBattleInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AllCha) > 0 {
		for _, e := range m.AllCha {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetGuildMapsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetGuildMapsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Maps) > 0 {
		for _, e := range m.Maps {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GuildMapInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.OpenMonthDay != 0 {
		n += 1 + sovMsg(uint64(m.OpenMonthDay))
	}
	l = len(m.OpenWeekDay)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.OpenStartTime)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.OpenEndTime)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.NeedGuildLevel != 0 {
		n += 1 + sovMsg(uint64(m.NeedGuildLevel))
	}
	if m.NextSceneID != 0 {
		n += 1 + sovMsg(uint64(m.NextSceneID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GotoGuildMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GotoGuildMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovMsg(uint64(m.Result))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetActivityMapsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetActivityMapsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Maps) > 0 {
		for _, e := range m.Maps {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ActivityMapInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.OpenMonthDay != 0 {
		n += 1 + sovMsg(uint64(m.OpenMonthDay))
	}
	l = len(m.OpenWeekDay)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.OpenStartTime)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	l = len(m.OpenEndTime)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.NeedLevel != 0 {
		n += 1 + sovMsg(uint64(m.NeedLevel))
	}
	if m.NextSceneID != 0 {
		n += 1 + sovMsg(uint64(m.NextSceneID))
	}
	if m.PriceType != 0 {
		n += 1 + sovMsg(uint64(m.PriceType))
	}
	if m.Price != 0 {
		n += 1 + sovMsg(uint64(m.Price))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetMapInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SceneID != 0 {
		n += 1 + sovMsg(uint64(m.SceneID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetMapInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SceneID != 0 {
		n += 1 + sovMsg(uint64(m.SceneID))
	}
	if m.BossFreshTime != 0 {
		n += 1 + sovMsg(uint64(m.BossFreshTime))
	}
	if len(m.DropItems) > 0 {
		l = 0
		for _, e := range m.DropItems {
			l += sovMsg(uint64(e))
		}
		n += 1 + sovMsg(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GotoActivityMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GotoActivityMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Result != 0 {
		n += 1 + sovMsg(uint64(m.Result))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetDuoBaoInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetDuoBaoInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MapGoInInfo != nil {
		l = m.MapGoInInfo.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.MapInfo != nil {
		l = m.MapInfo.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Minute != 0 {
		n += 1 + sovMsg(uint64(m.Minute))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetCopyMapsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetCopyMapsInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Maps) > 0 {
		for _, e := range m.Maps {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.RemainPlayTimes != 0 {
		n += 1 + sovMsg(uint64(m.RemainPlayTimes))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CopyMapInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.NeedLevel != 0 {
		n += 1 + sovMsg(uint64(m.NeedLevel))
	}
	if m.NextSceneID != 0 {
		n += 1 + sovMsg(uint64(m.NextSceneID))
	}
	if m.PlayerCount != 0 {
		n += 1 + sovMsg(uint64(m.PlayerCount))
	}
	if m.State != 0 {
		n += 1 + sovMsg(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_CopyMapPiPei) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CopyMapID != 0 {
		n += 1 + sovMsg(uint64(m.CopyMapID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_CopyMapCancel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CopyMapID != 0 {
		n += 1 + sovMsg(uint64(m.CopyMapID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_ShowPiPeiInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PiPeiState != 0 {
		n += 1 + sovMsg(uint64(m.PiPeiState))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetBattleRankInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RankStart != 0 {
		n += 1 + sovMsg(uint64(m.RankStart))
	}
	if m.RankCount != 0 {
		n += 1 + sovMsg(uint64(m.RankCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetBattleMapInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMsg(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetBattleRankInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RankInfo) > 0 {
		for _, e := range m.RankInfo {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.MyRankInfo != nil {
		l = m.MyRankInfo.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetBattleMapInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BattleMapInfo != nil {
		l = m.BattleMapInfo.Size()
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BattleRankOneInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Characterid != 0 {
		n += 1 + sovMsg(uint64(m.Characterid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Typeid != 0 {
		n += 1 + sovMsg(uint64(m.Typeid))
	}
	if m.Rank != 0 {
		n += 1 + sovMsg(uint64(m.Rank))
	}
	if m.Score != 0 {
		n += 1 + sovMsg(uint64(m.Score))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_BattlePiPei) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CopyMapID != 0 {
		n += 1 + sovMsg(uint64(m.CopyMapID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_BattleCancel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CopyMapID != 0 {
		n += 1 + sovMsg(uint64(m.CopyMapID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CS_GetBattleHeroInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SceneID != 0 {
		n += 1 + sovMsg(uint64(m.SceneID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SC_GetBattleHeroInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Group1) > 0 {
		for _, e := range m.Group1 {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if len(m.Group2) > 0 {
		for _, e := range m.Group2 {
			l = e.Size()
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.WinnerGroup != 0 {
		n += 1 + sovMsg(uint64(m.WinnerGroup))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BattleOverPlayerOneInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Characterid != 0 {
		n += 1 + sovMsg(uint64(m.Characterid))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMsg(uint64(l))
	}
	if m.Typeid != 0 {
		n += 1 + sovMsg(uint64(m.Typeid))
	}
	if m.Score != 0 {
		n += 1 + sovMsg(uint64(m.Score))
	}
	if m.KillCount != 0 {
		n += 1 + sovMsg(uint64(m.KillCount))
	}
	if m.DeathCount != 0 {
		n += 1 + sovMsg(uint64(m.DeathCount))
	}
	if m.Level != 0 {
		n += 1 + sovMsg(uint64(m.Level))
	}
	if len(m.EquipItems) > 0 {
		for _, s := range m.EquipItems {
			l = len(s)
			n += 1 + l + sovMsg(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMsg(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMsg(x uint64) (n int) {
	return sovMsg(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MsgType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectId", wireType)
			}
			m.ConnectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datas", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datas = append(m.Datas[:0], dAtA[iNdEx:postIndex]...)
			if m.Datas == nil {
				m.Datas = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterToGate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterToGate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterToGate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_MsgQuickLogin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_MsgQuickLogin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_MsgQuickLogin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Machineid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Machineid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_Login) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_Login: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_Login: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phonenumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phonenumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Platform", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Platform = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Machineid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Machineid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WechatId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WechatId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QQId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QQId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_SelectCharacter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_SelectCharacter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_SelectCharacter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectCharacter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelectCharacter == nil {
				m.SelectCharacter = &CharacterBaseDatas{}
			}
			if err := m.SelectCharacter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_LodingScene) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_LodingScene: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_LodingScene: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneID", wireType)
			}
			m.SceneID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SceneID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_LookVedioSucc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_LookVedioSucc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_LookVedioSucc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_UseAI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_UseAI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_UseAI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AIid", wireType)
			}
			m.AIid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AIid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_NeedLineUp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_NeedLineUp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_NeedLineUp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrontCount", wireType)
			}
			m.FrontCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrontCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetLineUpFrontCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetLineUpFrontCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetLineUpFrontCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nothing1", wireType)
			}
			m.Nothing1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nothing1 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetLineUpFrontCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetLineUpFrontCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetLineUpFrontCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FrontCount", wireType)
			}
			m.FrontCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FrontCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_CancelLineUp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_CancelLineUp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_CancelLineUp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nothing", wireType)
			}
			m.Nothing = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nothing |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnitEquip) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnitEquip: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnitEquip: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pos", wireType)
			}
			m.Pos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypdID", wireType)
			}
			m.TypdID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypdID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceType", wireType)
			}
			m.PriceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnitBoardDatas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnitBoardDatas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnitBoardDatas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeStrength", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AttributeStrength = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeAgility", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AttributeAgility = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributeIntelligence", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AttributeIntelligence = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attack", wireType)
			}
			m.Attack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Attack |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackSpeed", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AttackSpeed = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackRange", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AttackRange = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoveSpeed", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MoveSpeed = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MagicScale = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MPRegain", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MPRegain = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalAmaor", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PhysicalAmaor = float32(math.Float32frombits(v))
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhysicalResist", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.PhysicalResist = float32(math.Float32frombits(v))
		case 14:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field MagicAmaor", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.MagicAmaor = float32(math.Float32frombits(v))
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusAmaor", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.StatusAmaor = float32(math.Float32frombits(v))
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dodge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Dodge = float32(math.Float32frombits(v))
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HPRegain", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HPRegain = float32(math.Float32frombits(v))
		case 18:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawAttributeStrength", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RawAttributeStrength = float32(math.Float32frombits(v))
		case 19:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawAttributeAgility", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RawAttributeAgility = float32(math.Float32frombits(v))
		case 20:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawAttributeIntelligence", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RawAttributeIntelligence = float32(math.Float32frombits(v))
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawAttack", wireType)
			}
			m.RawAttack = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RawAttack |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawAttackSpeed", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RawAttackSpeed = float32(math.Float32frombits(v))
		case 23:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawAttackRange", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RawAttackRange = float32(math.Float32frombits(v))
		case 24:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawMoveSpeed", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RawMoveSpeed = float32(math.Float32frombits(v))
		case 25:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawMagicScale", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RawMagicScale = float32(math.Float32frombits(v))
		case 26:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawMPRegain", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RawMPRegain = float32(math.Float32frombits(v))
		case 27:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawPhysicalAmaor", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RawPhysicalAmaor = float32(math.Float32frombits(v))
		case 28:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawPhysicalResist", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RawPhysicalResist = float32(math.Float32frombits(v))
		case 29:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawMagicAmaor", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RawMagicAmaor = float32(math.Float32frombits(v))
		case 30:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawStatusAmaor", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RawStatusAmaor = float32(math.Float32frombits(v))
		case 31:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawDodge", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RawDodge = float32(math.Float32frombits(v))
		case 32:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawHPRegain", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RawHPRegain = float32(math.Float32frombits(v))
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttributePrimary", wireType)
			}
			m.AttributePrimary = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttributePrimary |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DropItems", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DropItems = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainExperience", wireType)
			}
			m.RemainExperience = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainExperience |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Equips = append(m.Equips, &UnitEquip{})
			if err := m.Equips[len(m.Equips)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SimpleSkillDatas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SimpleSkillDatas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SimpleSkillDatas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetUnitInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetUnitInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetUnitInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitID", wireType)
			}
			m.UnitID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetCharacterSimpleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetCharacterSimpleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetCharacterSimpleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CharacterID", wireType)
			}
			m.CharacterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CharacterID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetCharacterSimpleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetCharacterSimpleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetCharacterSimpleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CharacterID", wireType)
			}
			m.CharacterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CharacterID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipItems", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EquipItems = append(m.EquipItems, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skills", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Skills = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLoginDate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastLoginDate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetItemExtraInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetItemExtraInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetItemExtraInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeId", wireType)
			}
			m.TypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetItemExtraInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetItemExtraInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetItemExtraInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeId", wireType)
			}
			m.TypeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exception", wireType)
			}
			m.Exception = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exception |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExceptionParam", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExceptionParam = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipNeedLevel", wireType)
			}
			m.EquipNeedLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EquipNeedLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetBagInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetBagInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetBagInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitID", wireType)
			}
			m.UnitID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_ChangeItemPos) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_ChangeItemPos: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_ChangeItemPos: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPos", wireType)
			}
			m.SrcPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestPos", wireType)
			}
			m.DestPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcType", wireType)
			}
			m.SrcType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestType", wireType)
			}
			m.DestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_DestroyItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_DestroyItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_DestroyItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPos", wireType)
			}
			m.SrcPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_SystemHuiShouItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_SystemHuiShouItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_SystemHuiShouItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPos", wireType)
			}
			m.SrcPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_UnitInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_UnitInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_UnitInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnitData == nil {
				m.UnitData = &UnitBoardDatas{}
			}
			if err := m.UnitData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_BagInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_BagInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_BagInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Equips = append(m.Equips, &UnitEquip{})
			if err := m.Equips[len(m.Equips)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_PlayerUpgradeSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_PlayerUpgradeSkill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_PlayerUpgradeSkill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_PlayerMove) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_PlayerMove: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_PlayerMove: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IDs = append(m.IDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IDs) == 0 {
					m.IDs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IDs = append(m.IDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsStart", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsStart = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_PlayerAttack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_PlayerAttack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_PlayerAttack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IDs = append(m.IDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IDs) == 0 {
					m.IDs = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IDs = append(m.IDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetUnitID", wireType)
			}
			m.TargetUnitID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetUnitID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_PlayerSkill) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_PlayerSkill: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_PlayerSkill: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillID", wireType)
			}
			m.SkillID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetUnitID", wireType)
			}
			m.TargetUnitID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetUnitID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_ChangeAttackMode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_ChangeAttackMode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_ChangeAttackMode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackMode", wireType)
			}
			m.AttackMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_OrganizeTeam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_OrganizeTeam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_OrganizeTeam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player1", wireType)
			}
			m.Player1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Player1 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player2", wireType)
			}
			m.Player2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Player2 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_RequestTeam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_RequestTeam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_RequestTeam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPlayerUID", wireType)
			}
			m.SrcPlayerUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPlayerUID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcUnitTypeID", wireType)
			}
			m.SrcUnitTypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcUnitTypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcLevel", wireType)
			}
			m.SrcLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestType", wireType)
			}
			m.RequestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_ResponseOrgTeam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_ResponseOrgTeam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_ResponseOrgTeam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPlayerUID", wireType)
			}
			m.SrcPlayerUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPlayerUID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsAgree", wireType)
			}
			m.IsAgree = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsAgree |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestType", wireType)
			}
			m.RequestType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_OutTeam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_OutTeam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_OutTeam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutPlayerUID", wireType)
			}
			m.OutPlayerUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OutPlayerUID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TeamPlayerInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TeamPlayerInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TeamPlayerInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UID", wireType)
			}
			m.UID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HP", wireType)
			}
			m.HP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HP |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MP", wireType)
			}
			m.MP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MP |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHP", wireType)
			}
			m.MaxHP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxHP |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMP", wireType)
			}
			m.MaxMP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMP |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_UpdateTeamInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_UpdateTeamInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_UpdateTeamInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainUID", wireType)
			}
			m.MainUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MainUID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TPInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TPInfo = append(m.TPInfo, &TeamPlayerInfo{})
			if err := m.TPInfo[len(m.TPInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_NoticeWords) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_NoticeWords: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_NoticeWords: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.P = append(m.P, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SkillDatas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SkillDatas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SkillDatas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainCDTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RemainCDTime = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CanUpgrade", wireType)
			}
			m.CanUpgrade = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CanUpgrade |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CastType", wireType)
			}
			m.CastType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CastType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CastTargetType", wireType)
			}
			m.CastTargetType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CastTargetType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTargetTeam", wireType)
			}
			m.UnitTargetTeam = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitTargetTeam |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitTargetCamp", wireType)
			}
			m.UnitTargetCamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitTargetCamp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoCareMagicImmune", wireType)
			}
			m.NoCareMagicImmune = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NoCareMagicImmune |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field CastRange", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.CastRange = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cooldown", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Cooldown = float32(math.Float32frombits(v))
		case 13:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtRange", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.HurtRange = float32(math.Float32frombits(v))
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManaCost", wireType)
			}
			m.ManaCost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ManaCost |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackAutoActive", wireType)
			}
			m.AttackAutoActive = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackAutoActive |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Visible", wireType)
			}
			m.Visible = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Visible |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainSkillCount", wireType)
			}
			m.RemainSkillCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainSkillCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLevel", wireType)
			}
			m.MaxLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredLevel", wireType)
			}
			m.RequiredLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LevelsBetweenUpgrades", wireType)
			}
			m.LevelsBetweenUpgrades = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LevelsBetweenUpgrades |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitLevel", wireType)
			}
			m.InitLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuffDatas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuffDatas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuffDatas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RemainTime = float32(math.Float32frombits(v))
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Time = float32(math.Float32frombits(v))
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TagNum", wireType)
			}
			m.TagNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TagNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionType", wireType)
			}
			m.ConnectionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectionType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ConnectionX = float32(math.Float32frombits(v))
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ConnectionY = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectionZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.ConnectionZ = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnitDatas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnitDatas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnitDatas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HP", wireType)
			}
			m.HP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HP |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MP", wireType)
			}
			m.MP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MP |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 6:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxHP", wireType)
			}
			m.MaxHP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxHP |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMP", wireType)
			}
			m.MaxMP = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMP |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Experience", wireType)
			}
			m.Experience = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Experience |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxExperience", wireType)
			}
			m.MaxExperience = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxExperience |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ControlID", wireType)
			}
			m.ControlID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ControlID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnimotorState", wireType)
			}
			m.AnimotorState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnimotorState |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AttackTime = float32(math.Float32frombits(v))
		case 16:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectionX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DirectionX = float32(math.Float32frombits(v))
		case 17:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirectionY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.DirectionY = float32(math.Float32frombits(v))
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitType", wireType)
			}
			m.UnitType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnitType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackAcpabilities", wireType)
			}
			m.AttackAcpabilities = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackAcpabilities |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackMode", wireType)
			}
			m.AttackMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackMode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMain", wireType)
			}
			m.IsMain = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsMain |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeath", wireType)
			}
			m.IsDeath = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsDeath |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invisible", wireType)
			}
			m.Invisible = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Invisible |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Camp", wireType)
			}
			m.Camp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Camp |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMiss", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMiss = bool(v != 0)
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnimotorPause", wireType)
			}
			m.AnimotorPause = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnimotorPause |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 27:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkillEnable", wireType)
			}
			m.SkillEnable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SkillEnable |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 28:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemEnable", wireType)
			}
			m.ItemEnable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemEnable |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Z = float32(math.Float32frombits(v))
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMirrorImage", wireType)
			}
			m.IsMirrorImage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsMirrorImage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackRange", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.AttackRange = float32(math.Float32frombits(v))
		case 32:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttackAnim", wireType)
			}
			m.AttackAnim = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttackAnim |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 34:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainReviveTime", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.RemainReviveTime = float32(math.Float32frombits(v))
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeamID", wireType)
			}
			m.TeamID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeamID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gold", wireType)
			}
			m.Gold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Diamond", wireType)
			}
			m.Diamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Diamond |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 38:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReviveGold", wireType)
			}
			m.ReviveGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReviveGold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 39:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReviveDiamond", wireType)
			}
			m.ReviveDiamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReviveDiamond |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 40:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characterid", wireType)
			}
			m.Characterid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Characterid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainWatchVedioCountToday", wireType)
			}
			m.RemainWatchVedioCountToday = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainWatchVedioCountToday |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 42:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WatchVedioAddDiamond", wireType)
			}
			m.WatchVedioAddDiamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WatchVedioAddDiamond |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildID", wireType)
			}
			m.GuildID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 44:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainExperience", wireType)
			}
			m.RemainExperience = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainExperience |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleRank", wireType)
			}
			m.BattleRank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BattleRank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 48:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SD", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SD = append(m.SD, &SkillDatas{})
			if err := m.SD[len(m.SD)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 49:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BD", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BD = append(m.BD, &BuffDatas{})
			if err := m.BD[len(m.BD)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ISD", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ISD = append(m.ISD, &SkillDatas{})
			if err := m.ISD[len(m.ISD)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BulletDatas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BulletDatas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BulletDatas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Z = float32(math.Float32frombits(v))
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.StartX = float32(math.Float32frombits(v))
		case 8:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.StartY = float32(math.Float32frombits(v))
		case 9:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.StartZ = float32(math.Float32frombits(v))
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndX", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EndX = float32(math.Float32frombits(v))
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndY", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EndY = float32(math.Float32frombits(v))
		case 12:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndZ", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.EndZ = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SceneItemDatas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SceneItemDatas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SceneItemDatas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HaloDatas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HaloDatas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HaloDatas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.X = float32(math.Float32frombits(v))
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Y = float32(math.Float32frombits(v))
		case 5:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Z = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUserEnterScene) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUserEnterScene: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUserEnterScene: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConnectId", wireType)
			}
			m.ConnectId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConnectId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneID", wireType)
			}
			m.SceneID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SceneID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datas", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datas = append(m.Datas[:0], dAtA[iNdEx:postIndex]...)
			if m.Datas == nil {
				m.Datas = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgPlayerHurt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgPlayerHurt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgPlayerHurt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtUnitID", wireType)
			}
			m.HurtUnitID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HurtUnitID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtAllValue", wireType)
			}
			m.HurtAllValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HurtAllValue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HurtMagicValue", wireType)
			}
			m.HurtMagicValue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HurtMagicValue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCrit", wireType)
			}
			m.IsCrit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsCrit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetGold", wireType)
			}
			m.GetGold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetGold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetDiamond", wireType)
			}
			m.GetDiamond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetDiamond |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_Update) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_Update: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_Update: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurFrame", wireType)
			}
			m.CurFrame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurFrame |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewUnits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewUnits = append(m.NewUnits, &UnitDatas{})
			if err := m.NewUnits[len(m.NewUnits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldUnits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldUnits = append(m.OldUnits, &UnitDatas{})
			if err := m.OldUnits[len(m.OldUnits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RemoveUnits = append(m.RemoveUnits, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RemoveUnits) == 0 {
					m.RemoveUnits = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RemoveUnits = append(m.RemoveUnits, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveUnits", wireType)
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewBullets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewBullets = append(m.NewBullets, &BulletDatas{})
			if err := m.NewBullets[len(m.NewBullets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldBullets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldBullets = append(m.OldBullets, &BulletDatas{})
			if err := m.OldBullets[len(m.OldBullets)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RemoveBullets = append(m.RemoveBullets, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RemoveBullets) == 0 {
					m.RemoveBullets = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RemoveBullets = append(m.RemoveBullets, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveBullets", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewHalos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewHalos = append(m.NewHalos, &HaloDatas{})
			if err := m.NewHalos[len(m.NewHalos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldHalos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldHalos = append(m.OldHalos, &HaloDatas{})
			if err := m.OldHalos[len(m.OldHalos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RemoveHalos = append(m.RemoveHalos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RemoveHalos) == 0 {
					m.RemoveHalos = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RemoveHalos = append(m.RemoveHalos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveHalos", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSceneItems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewSceneItems = append(m.NewSceneItems, &SceneItemDatas{})
			if err := m.NewSceneItems[len(m.NewSceneItems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RemoveSceneItems = append(m.RemoveSceneItems, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RemoveSceneItems) == 0 {
					m.RemoveSceneItems = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RemoveSceneItems = append(m.RemoveSceneItems, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveSceneItems", wireType)
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerHurt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerHurt = append(m.PlayerHurt, &MsgPlayerHurt{})
			if err := m.PlayerHurt[len(m.PlayerHurt)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_NewScene) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_NewScene: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_NewScene: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogicFps", wireType)
			}
			m.LogicFps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogicFps |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurFrame", wireType)
			}
			m.CurFrame = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurFrame |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneID", wireType)
			}
			m.SceneID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SceneID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeHour", wireType)
			}
			m.TimeHour = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeHour |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeMinute", wireType)
			}
			m.TimeMinute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeMinute |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeSecond", wireType)
			}
			m.TimeSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeSecond |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataShowType", wireType)
			}
			m.DataShowType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataShowType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CharacterBaseDatas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CharacterBaseDatas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CharacterBaseDatas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characterid", wireType)
			}
			m.Characterid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Characterid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typeid", wireType)
			}
			m.Typeid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typeid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_Logined) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_Logined: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_Logined: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Characters = append(m.Characters, &CharacterBaseDatas{})
			if err := m.Characters[len(m.Characters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_SelectCharacterResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_SelectCharacterResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_SelectCharacterResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characterid", wireType)
			}
			m.Characterid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Characterid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			m.Error = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Error |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommodityDataProto) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommodityDataProto: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommodityDataProto: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceType", wireType)
			}
			m.PriceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetStoreData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetStoreData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetStoreData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Test", wireType)
			}
			m.Test = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Test |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_StoreData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_StoreData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_StoreData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commoditys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commoditys = append(m.Commoditys, &CommodityDataProto{})
			if err := m.Commoditys[len(m.Commoditys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_BuyCommodity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_BuyCommodity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_BuyCommodity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeID", wireType)
			}
			m.TypeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TypeID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_QuickRevive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_QuickRevive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_QuickRevive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReviveType", wireType)
			}
			m.ReviveType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReviveType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LookVideoState", wireType)
			}
			m.LookVideoState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LookVideoState |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CC_Disconnect) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CC_Disconnect: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CC_Disconnect: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Err = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_ChatInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_ChatInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_ChatInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Time = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SrcName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcPlayerUID", wireType)
			}
			m.SrcPlayerUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcPlayerUID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SrcCharacterID", wireType)
			}
			m.SrcCharacterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SrcCharacterID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestPlayerUID", wireType)
			}
			m.DestPlayerUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestPlayerUID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_ChatInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_ChatInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_ChatInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			m.Channel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Channel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestPlayerUID", wireType)
			}
			m.DestPlayerUID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DestPlayerUID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_AddFriendRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_AddFriendRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_AddFriendRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characterid", wireType)
			}
			m.Characterid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Characterid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_RemoveFriend) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_RemoveFriend: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_RemoveFriend: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characterid", wireType)
			}
			m.Characterid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Characterid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_AddFriendResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_AddFriendResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_AddFriendResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FriendInfo == nil {
				m.FriendInfo = &FriendInfoMsg{}
			}
			if err := m.FriendInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FriendInfoMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FriendInfoMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FriendInfoMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characterid", wireType)
			}
			m.Characterid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Characterid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typeid", wireType)
			}
			m.Typeid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typeid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetFriendsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetFriendsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetFriendsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetFriendsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetFriendsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetFriendsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Friends", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Friends = append(m.Friends, &FriendInfoMsg{})
			if err := m.Friends[len(m.Friends)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FriendsRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FriendsRequest = append(m.FriendsRequest, &FriendInfoMsg{})
			if err := m.FriendsRequest[len(m.FriendsRequest)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailShortInfoMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailShortInfoMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailShortInfoMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SendName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MailRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MailRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MailRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemType", wireType)
			}
			m.ItemType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetMailsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetMailsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetMailsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetMailsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetMailsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetMailsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Mails = append(m.Mails, &MailShortInfoMsg{})
			if err := m.Mails[len(m.Mails)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MailUpperLimit", wireType)
			}
			m.MailUpperLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MailUpperLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetMailInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetMailInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetMailInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetMailInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetMailInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetMailInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SendName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Date = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rewards = append(m.Rewards, &MailRewards{})
			if err := m.Rewards[len(m.Rewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetMailRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetMailRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetMailRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetMailRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetMailRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetMailRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_DeleteNoRewardMails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_DeleteNoRewardMails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_DeleteNoRewardMails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetExchangeShortCommoditys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetExchangeShortCommoditys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetExchangeShortCommoditys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeShortCommodityData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeShortCommodityData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeShortCommodityData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellCount", wireType)
			}
			m.SellCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SellCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetExchangeShortCommoditys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetExchangeShortCommoditys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetExchangeShortCommoditys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commoditys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commoditys = append(m.Commoditys, &ExchangeShortCommodityData{})
			if err := m.Commoditys[len(m.Commoditys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetExchangeDetailedCommoditys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetExchangeDetailedCommoditys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetExchangeDetailedCommoditys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExchangeDetailedCommodityData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeDetailedCommodityData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeDetailedCommodityData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommodityData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommodityData == nil {
				m.CommodityData = &CommodityDataProto{}
			}
			if err := m.CommodityData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemaindTime", wireType)
			}
			m.RemaindTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemaindTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetExchangeDetailedCommoditys) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetExchangeDetailedCommoditys: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetExchangeDetailedCommoditys: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commoditys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commoditys = append(m.Commoditys, &ExchangeDetailedCommodityData{})
			if err := m.Commoditys[len(m.Commoditys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_BuyExchangeCommodity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_BuyExchangeCommodity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_BuyExchangeCommodity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_ShelfExchangeCommodity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_ShelfExchangeCommodity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_ShelfExchangeCommodity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BagPos", wireType)
			}
			m.BagPos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BagPos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceType", wireType)
			}
			m.PriceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_UnShelfExchangeCommodity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_UnShelfExchangeCommodity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_UnShelfExchangeCommodity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetSellUIInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetSellUIInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetSellUIInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetSellUIInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetSellUIInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetSellUIInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShelfExchangeLimit", wireType)
			}
			m.ShelfExchangeLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShelfExchangeLimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field SellExchangeTax", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.SellExchangeTax = float32(math.Float32frombits(v))
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShelfExchangeFeePriceType", wireType)
			}
			m.ShelfExchangeFeePriceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShelfExchangeFeePriceType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShelfExchangeFeePrice", wireType)
			}
			m.ShelfExchangeFeePrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShelfExchangeFeePrice |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AutoUnShelfTime", wireType)
			}
			m.AutoUnShelfTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AutoUnShelfTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commoditys", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Commoditys = append(m.Commoditys, &ExchangeDetailedCommodityData{})
			if err := m.Commoditys[len(m.Commoditys)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Equips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Equips = append(m.Equips, &UnitEquip{})
			if err := m.Equips[len(m.Equips)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetWorldAuctionItems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetWorldAuctionItems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetWorldAuctionItems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetWorldAuctionItems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetWorldAuctionItems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetWorldAuctionItems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &AuctionItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_NewPriceWorldAuctionItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_NewPriceWorldAuctionItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_NewPriceWorldAuctionItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetAllGuildsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetAllGuildsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetAllGuildsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildShortInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildShortInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildShortInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Experience", wireType)
			}
			m.Experience = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Experience |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxExperience", wireType)
			}
			m.MaxExperience = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxExperience |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CharacterCount", wireType)
			}
			m.CharacterCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CharacterCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCount", wireType)
			}
			m.MaxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PresidentName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PresidentName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Joinaudit", wireType)
			}
			m.Joinaudit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Joinaudit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Joinlevellimit", wireType)
			}
			m.Joinlevellimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Joinlevellimit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetAllGuildsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetAllGuildsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetAllGuildsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guilds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Guilds = append(m.Guilds, &GuildShortInfo{})
			if err := m.Guilds[len(m.Guilds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatePriceType", wireType)
			}
			m.CreatePriceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatePriceType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatePrice", wireType)
			}
			m.CreatePrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatePrice |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_CreateGuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_CreateGuild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_CreateGuild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_JoinGuild) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_JoinGuild: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_JoinGuild: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetGuildInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetGuildInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetGuildInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetGuildInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetGuildInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetGuildInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildBaseInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GuildBaseInfo == nil {
				m.GuildBaseInfo = &GuildShortInfo{}
			}
			if err := m.GuildBaseInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Characters = append(m.Characters, &GuildChaInfo{})
			if err := m.Characters[len(m.Characters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildChaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildChaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildChaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characterid", wireType)
			}
			m.Characterid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Characterid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typeid", wireType)
			}
			m.Typeid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typeid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinLevel", wireType)
			}
			m.PinLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PinLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinExperience", wireType)
			}
			m.PinExperience = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PinExperience |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Post", wireType)
			}
			m.Post = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Post |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinLevelName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PinLevelName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PostName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PostName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinMaxExperience", wireType)
			}
			m.PinMaxExperience = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PinMaxExperience |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetJoinGuildPlayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetJoinGuildPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetJoinGuildPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetJoinGuildPlayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetJoinGuildPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetJoinGuildPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestCharacters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestCharacters = append(m.RequestCharacters, &GuildChaInfo{})
			if err := m.RequestCharacters[len(m.RequestCharacters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_ResponseJoinGuildPlayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_ResponseJoinGuildPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_ResponseJoinGuildPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characterid", wireType)
			}
			m.Characterid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Characterid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_DeleteGuildPlayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_DeleteGuildPlayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_DeleteGuildPlayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characterid", wireType)
			}
			m.Characterid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Characterid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GuildOperate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GuildOperate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GuildOperate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_ChangePost) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_ChangePost: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_ChangePost: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characterid", wireType)
			}
			m.Characterid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Characterid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Post", wireType)
			}
			m.Post = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Post |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_EditorGuildNotice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_EditorGuildNotice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_EditorGuildNotice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetAuctionItems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetAuctionItems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetAuctionItems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetAuctionItems) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetAuctionItems: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetAuctionItems: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &AuctionItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuctionItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuctionItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuctionItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ItemID", wireType)
			}
			m.ItemID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ItemID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceType", wireType)
			}
			m.PriceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidderCharacterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BidderCharacterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivecharactersName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReceivecharactersName = append(m.ReceivecharactersName, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainTime", wireType)
			}
			m.RemainTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BidderType", wireType)
			}
			m.BidderType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BidderType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_NewPriceAuctionItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_NewPriceAuctionItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_NewPriceAuctionItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetGuildRankInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetGuildRankInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetGuildRankInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetGuildRankInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetGuildRankInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetGuildRankInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Guilds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Guilds = append(m.Guilds, &GuildShortInfo{})
			if err := m.Guilds[len(m.Guilds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInfo == nil {
				m.MapInfo = &GuildMapInfo{}
			}
			if err := m.MapInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetGuildRankBattleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetGuildRankBattleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetGuildRankBattleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildRankBattleChaInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildRankBattleChaInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildRankBattleChaInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characterid", wireType)
			}
			m.Characterid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Characterid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillCount", wireType)
			}
			m.KillCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeathCount", wireType)
			}
			m.DeathCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeathCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildId", wireType)
			}
			m.GuildId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GuildId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GuildName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GuildName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typeid", wireType)
			}
			m.Typeid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typeid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetGuildRankBattleInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetGuildRankBattleInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetGuildRankBattleInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllCha", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllCha = append(m.AllCha, &GuildRankBattleChaInfo{})
			if err := m.AllCha[len(m.AllCha)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetGuildMapsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetGuildMapsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetGuildMapsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetGuildMapsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetGuildMapsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetGuildMapsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Maps = append(m.Maps, &GuildMapInfo{})
			if err := m.Maps[len(m.Maps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GuildMapInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GuildMapInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GuildMapInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenMonthDay", wireType)
			}
			m.OpenMonthDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenMonthDay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenWeekDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenWeekDay = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenStartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenStartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenEndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenEndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedGuildLevel", wireType)
			}
			m.NeedGuildLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedGuildLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSceneID", wireType)
			}
			m.NextSceneID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSceneID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GotoGuildMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GotoGuildMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GotoGuildMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GotoGuildMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GotoGuildMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GotoGuildMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetActivityMapsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetActivityMapsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetActivityMapsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetActivityMapsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetActivityMapsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetActivityMapsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Maps = append(m.Maps, &ActivityMapInfo{})
			if err := m.Maps[len(m.Maps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ActivityMapInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ActivityMapInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ActivityMapInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenMonthDay", wireType)
			}
			m.OpenMonthDay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OpenMonthDay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenWeekDay", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenWeekDay = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenStartTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenStartTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenEndTime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenEndTime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedLevel", wireType)
			}
			m.NeedLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSceneID", wireType)
			}
			m.NextSceneID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSceneID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceType", wireType)
			}
			m.PriceType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PriceType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			m.Price = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Price |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetMapInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetMapInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetMapInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneID", wireType)
			}
			m.SceneID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SceneID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetMapInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetMapInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetMapInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneID", wireType)
			}
			m.SceneID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SceneID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BossFreshTime", wireType)
			}
			m.BossFreshTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BossFreshTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DropItems = append(m.DropItems, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMsg
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthMsg
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthMsg
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DropItems) == 0 {
					m.DropItems = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMsg
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DropItems = append(m.DropItems, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DropItems", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GotoActivityMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GotoActivityMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GotoActivityMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GotoActivityMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GotoActivityMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GotoActivityMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			m.Result = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Result |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetDuoBaoInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetDuoBaoInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetDuoBaoInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetDuoBaoInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetDuoBaoInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetDuoBaoInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapGoInInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapGoInInfo == nil {
				m.MapGoInInfo = &ActivityMapInfo{}
			}
			if err := m.MapGoInInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MapInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MapInfo == nil {
				m.MapInfo = &SC_GetMapInfo{}
			}
			if err := m.MapInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Minute", wireType)
			}
			m.Minute = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Minute |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetCopyMapsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetCopyMapsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetCopyMapsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetCopyMapsInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetCopyMapsInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetCopyMapsInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Maps", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Maps = append(m.Maps, &CopyMapInfo{})
			if err := m.Maps[len(m.Maps)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemainPlayTimes", wireType)
			}
			m.RemainPlayTimes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RemainPlayTimes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CopyMapInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CopyMapInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CopyMapInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedLevel", wireType)
			}
			m.NeedLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NeedLevel |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextSceneID", wireType)
			}
			m.NextSceneID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextSceneID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerCount", wireType)
			}
			m.PlayerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlayerCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_CopyMapPiPei) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_CopyMapPiPei: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_CopyMapPiPei: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyMapID", wireType)
			}
			m.CopyMapID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyMapID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_CopyMapCancel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_CopyMapCancel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_CopyMapCancel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyMapID", wireType)
			}
			m.CopyMapID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyMapID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_ShowPiPeiInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_ShowPiPeiInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_ShowPiPeiInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PiPeiState", wireType)
			}
			m.PiPeiState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PiPeiState |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetBattleRankInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetBattleRankInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetBattleRankInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankStart", wireType)
			}
			m.RankStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankStart |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankCount", wireType)
			}
			m.RankCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RankCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetBattleMapInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetBattleMapInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetBattleMapInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetBattleRankInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetBattleRankInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetBattleRankInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankInfo = append(m.RankInfo, &BattleRankOneInfo{})
			if err := m.RankInfo[len(m.RankInfo)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MyRankInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MyRankInfo == nil {
				m.MyRankInfo = &BattleRankOneInfo{}
			}
			if err := m.MyRankInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetBattleMapInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetBattleMapInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetBattleMapInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BattleMapInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BattleMapInfo == nil {
				m.BattleMapInfo = &CopyMapInfo{}
			}
			if err := m.BattleMapInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BattleRankOneInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BattleRankOneInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BattleRankOneInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characterid", wireType)
			}
			m.Characterid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Characterid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typeid", wireType)
			}
			m.Typeid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typeid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rank", wireType)
			}
			m.Rank = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rank |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_BattlePiPei) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_BattlePiPei: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_BattlePiPei: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyMapID", wireType)
			}
			m.CopyMapID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyMapID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_BattleCancel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_BattleCancel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_BattleCancel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CopyMapID", wireType)
			}
			m.CopyMapID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CopyMapID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CS_GetBattleHeroInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CS_GetBattleHeroInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CS_GetBattleHeroInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SceneID", wireType)
			}
			m.SceneID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SceneID |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SC_GetBattleHeroInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SC_GetBattleHeroInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SC_GetBattleHeroInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group1 = append(m.Group1, &BattleOverPlayerOneInfo{})
			if err := m.Group1[len(m.Group1)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group2 = append(m.Group2, &BattleOverPlayerOneInfo{})
			if err := m.Group2[len(m.Group2)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WinnerGroup", wireType)
			}
			m.WinnerGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WinnerGroup |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BattleOverPlayerOneInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BattleOverPlayerOneInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BattleOverPlayerOneInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Characterid", wireType)
			}
			m.Characterid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Characterid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Typeid", wireType)
			}
			m.Typeid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Typeid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KillCount", wireType)
			}
			m.KillCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KillCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeathCount", wireType)
			}
			m.DeathCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeathCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EquipItems", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMsg
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMsg
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EquipItems = append(m.EquipItems, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMsg(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMsg
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMsg(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMsg
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMsg
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMsg
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMsg
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMsg
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMsg        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMsg          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMsg = fmt.Errorf("proto: unexpected end of group")
)
